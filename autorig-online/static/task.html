<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Task Progress | AutoRig.online</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/static/css/styles.css?v=lazyfix-1">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T4E781EHE4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T4E781EHE4');
    </script>
    
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Loading Overlay Styles -->
    <style>
        /* WebApp Mode - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π UI –¥–ª—è Telegram (—Ç–æ–ª—å–∫–æ viewer) */
        body.webapp-mode .header { display: none !important; }
        body.webapp-mode .queue-status-compact { display: none !important; }
        body.webapp-mode #progress-log { display: none !important; }
        body.webapp-mode #admin-input-url-row { display: none !important; }
        body.webapp-mode #owner-tasks-btn { display: none !important; }
        body.webapp-mode #restart-task-btn { display: none !important; }
        body.webapp-mode #change-rig-btn { display: none !important; }
        body.webapp-mode #task-run-state { display: none !important; }
        body.webapp-mode footer { display: none !important; }
        body.webapp-mode main { padding-top: 0.5rem !important; }
        body.webapp-mode .card:first-child h2 { display: none !important; }
        body.webapp-mode #progress-container { margin-bottom: 0.5rem; }
        body.webapp-mode #telegram-share-btn { display: inline-flex !important; }
        /* Hide downloads and video player in webapp mode - only 3D viewer */
        body.webapp-mode #downloads-card { display: none !important; }
        body.webapp-mode #video-player { display: none !important; }
        body.webapp-mode #video-preview-title { display: none !important; }
        body.webapp-mode #hdrp-renders { display: none !important; }
        body.webapp-mode #video-pending { display: none !important; }
        
        .viewer-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            border-radius: 12px;
        }
        
        .viewer-loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .viewer-loading-overlay.removed {
            display: none;
        }
        
        .viewer-loading-content {
            text-align: center;
            color: #fff;
        }
        
        .viewer-loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #4f46e5;
            border-radius: 50%;
            animation: viewer-spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes viewer-spin {
            to { transform: rotate(360deg); }
        }
        
        .viewer-loading-text {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        /* Texture Gallery */
        .texture-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        .texture-tile {
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            background: rgba(var(--bg-secondary-rgb, 30, 30, 35), 0.5);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .texture-tile:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .texture-tile img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background: #111;
        }
        .texture-tile .label {
            padding: 0.5rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .texture-tile .download-btn {
            display: block;
            padding: 0.4rem;
            text-align: center;
            font-size: 0.75rem;
            background: var(--accent);
            color: #fff;
            text-decoration: none;
            transition: background 0.2s;
        }
        .texture-tile .download-btn:hover {
            background: var(--accent-hover);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-inner">
                <a href="/" class="logo">
                    <img src="/static/images/logo/autorig-logo.png" srcset="/static/images/logo/autorig-logo.png 1x, /static/images/logo/autorig-logo@2x.png 2x" alt="Autorig.Online" class="logo-img" height="120">
                    
                </a>
                
                <div class="header-actions">
                    <!-- Language Selector -->
                    <div class="lang-selector">
                        <button class="lang-btn">
                            <span>EN</span>
                        </button>
                        <div class="lang-dropdown">
                            <button class="lang-option" data-lang="en">English</button>
                            <button class="lang-option" data-lang="ru">–†—É—Å—Å–∫–∏–π</button>
                        </div>
                    </div>
                    
                    <!-- Theme Toggle -->
                    <button class="theme-toggle" id="theme-toggle" title="Toggle theme">üåô</button>
                    
                    <a href="/" class="btn btn-secondary">‚Üê Back</a>
                </div>
            </div>
        </div>
    </header>
    
    <main class="container-sm" style="padding-top: 2rem;">
        <!-- Task Card -->
        <div class="card">
            <!-- Task header title (always fully visible) -->
            <h2 data-i18n="task_title" style="margin: 0 0 0.75rem 0;">
                Conversion Progress
            </h2>
            <div id="task-run-state" style="margin: -0.25rem 0 0.75rem; font-size: 0.9rem; color: var(--text-muted);"></div>

            <!-- Admin-only: Input URL + Worker Progress -->
            <div id="admin-input-url-row" class="hidden"
                 style="margin: -0.25rem 0 0.85rem; padding: 0.65rem 0.85rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.14);">
                <div style="display:flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap;">
                    <div style="min-width: 200px; flex: 1;">
                        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">Input URL (admin)</div>
                        <a id="admin-input-url-link" href="#" target="_blank"
                           style="color: var(--accent); text-decoration: none; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">
                            -
                        </a>
                    </div>
                    <button class="btn btn-secondary" id="admin-input-url-copy"
                            style="padding: 0.35rem 0.6rem; font-size: 0.85rem; white-space: nowrap;">
                        Copy
                    </button>
                </div>
                <!-- Worker Progress Page link -->
                <div id="admin-worker-progress-row" class="hidden" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.08);">
                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">üîß Worker Progress Page</div>
                    <a id="admin-worker-progress-link" href="#" target="_blank"
                       style="color: #f59e0b; text-decoration: none; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%; font-size: 0.9rem;">
                        -
                    </a>
                </div>
            </div>

            <!-- Header actions row (one line): buttons + status -->
            <div style="display: flex; justify-content: flex-start; align-items: center; gap: 0.6rem; flex-wrap: wrap;">
                <div class="flex gap-2" style="align-items: center; flex-wrap: wrap;">
                    <button class="btn btn-secondary" id="owner-tasks-btn"
                            style="padding: 0.55rem 0.9rem; border-color: var(--warning); color: var(--warning); background: rgba(245, 158, 11, 0.08); white-space: nowrap;">
                        <span aria-hidden="true" style="font-size: 1.8rem; line-height: 1; display: inline-block;">üìã</span>
                        <span data-i18n="btn_owner_tasks" style="display: inline-block;">All tasks</span>
                    </button>
                    <button class="btn btn-secondary hidden" id="restart-task-btn"
                            style="padding: 0.55rem 0.9rem; border-color: var(--error); color: var(--error); background: rgba(239, 68, 68, 0.08); white-space: nowrap;">
                        <span aria-hidden="true" style="font-size: 1.8rem; line-height: 1; display: inline-block;">üîÑ</span>
                        <span data-i18n="btn_restart_task" style="display: inline-block;">Restart task</span>
                    </button>

                    <!-- Status Badge (in header row) -->
                    <div id="status-container" style="white-space: nowrap; display: inline-flex; align-items: center;">
                        <span class="alert alert-info" id="status-badge" style="display: inline-block; margin: 0;">
                    <span id="status-text">Processing...</span>
                </span>
                    </div>
                </div>
            </div>
            
            <!-- Queue Status (compact) -->
            <div class="queue-status-compact mt-3" id="queue-status-compact">
                <img src="/static/images/icons/queue.svg" alt="Queue" class="queue-status-icon" width="20" height="20" style="display: none;">
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-active">-</span>
                    <span class="queue-stat-label" data-i18n="queue_active">Active</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-pending">-</span>
                    <span class="queue-stat-label" data-i18n="queue_pending">In Queue</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-wait">-</span>
                    <span class="queue-stat-label" data-i18n="queue_wait">Est. Wait</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-servers">-</span>
                    <span class="queue-stat-label" data-i18n="queue_servers">Servers</span>
                </div>
            </div>
            
            <!-- Progress -->
            <div class="progress-container" id="progress-container">
                <div class="progress-percent" id="progress-percent">0%</div>
                <div id="progress-log" class="hidden"
                     style="margin: 0.5rem 0 0.25rem; padding: 0.75rem 1rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.18); cursor: pointer;">
                    <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.75rem;">
                        <div style="font-size: 0.8rem; color: var(--text-muted); white-space: nowrap;">Log</div>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <button id="progress-log-copy" type="button" 
                                    style="padding: 0.25rem 0.5rem; font-size: 0.7rem; border-radius: 4px; 
                                           background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); 
                                           color: var(--text-muted); cursor: pointer;"
                                    onclick="event.stopPropagation();" data-i18n="log_copy">Copy</button>
                            <div id="progress-log-hint" style="font-size: 0.8rem; color: var(--text-muted); white-space: nowrap;">Click to expand</div>
                        </div>
                    </div>
                    <pre id="progress-log-text"
                         style="margin-top: 0.5rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-size: 0.8rem; line-height: 1.35; color: var(--text-secondary); white-space: pre-wrap; word-break: break-word; overflow: hidden; max-height: 3.2em; transition: max-height 0.25s ease;"></pre>
                </div>
                <div id="progress-failure" class="hidden"
                     style="margin: 0.5rem 0; padding: 0.75rem 1rem; border-radius: 8px; 
                            background: rgba(239, 71, 111, 0.15); border: 1px solid rgba(239, 71, 111, 0.3);
                            color: #ef476f; font-size: 0.85rem; font-weight: 500;">
                    <span style="margin-right: 0.5rem;">‚ö†Ô∏è</span>
                    <span id="progress-failure-text"></span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-text">
                    <span><span id="ready-count">0</span> / <span id="total-count">0</span> <span data-i18n="task_files_ready">files ready</span></span>
                    <span id="eta"></span>
                </div>
            </div>
            
            <!-- Error Message -->
            <div class="alert alert-error hidden mt-3" id="error-container">
                <span id="error-message"></span>
            </div>

            <!-- Video Preview -->
            <div class="video-preview hidden" id="video-container">
                <!-- Model Viewer (GLB) -->
                <div id="model-viewer-wrap" class="hidden" style="margin-bottom: 1rem;">
                    <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <div style="font-weight: 600; font-size: 1.1rem;">üéÆ 3D Preview</div>
                        <div id="model-viewer-status" style="font-size: 0.85rem; color: var(--text-muted); white-space: nowrap;">Loading...</div>
                </div>
                    <div style="display:flex; gap: 0.5rem; align-items:center; flex-wrap: wrap; margin-bottom: 0.75rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted);">Animation:</label>
                        <select id="anim-select" class="hidden" style="padding: 0.5rem 0.75rem; border-radius: 10px; background: var(--bg-input); border: 1px solid var(--border); color: var(--text-primary);">
                        </select>
                        <button id="anim-play-btn" class="btn btn-secondary hidden" style="padding: 0.45rem 0.8rem;">Play</button>
                        <button id="anim-pause-btn" class="btn btn-secondary hidden" style="padding: 0.45rem 0.8rem;">Pause</button>
                </div>
                    <!-- Viewer Container (relative for overlay positioning) -->
                    <div id="model-viewer-container" style="position: relative; width: 100%; height: 420px;">
                        <!-- Three.js Canvas Target -->
                        <div id="model-viewer" style="width: 100%; height: 100%; border-radius: 12px; background: #000; border: 1px solid rgba(255,255,255,0.08); overflow: hidden;"></div>
                        
                        <!-- Loading Overlay (shown until model loads) -->
                        <div id="viewer-loading-overlay" class="viewer-loading-overlay">
                            <div class="viewer-loading-content">
                                <div class="viewer-loading-spinner"></div>
                                <div class="viewer-loading-text" data-i18n="viewer_loading">Loading scene...</div>
                            </div>
                        </div>
                        
                        <!-- Viewer Overlay UI (above canvas) -->
                        <div id="viewer-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; border-radius: 12px;">
                            <!-- Top-left: Channel Selector -->
                            <div id="viewer-channel-wrap" style="position: absolute; top: 0.75rem; left: 0.75rem; pointer-events: auto; display: flex; flex-direction: column; gap: 0.5rem;">
                                <select id="viewer-channel-select" class="form-select" style="
                                    padding: 0.35rem 0.5rem;
                                    font-size: 0.75rem;
                                    min-width: 120px;
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.15);
                                    backdrop-filter: blur(12px);
                                    color: #fff;
                                    border-radius: 8px;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                ">
                                    <option value="1" selected>PBR (Default)</option>
                                    <option value="2">Ambient Occlusion</option>
                                    <option value="3">Normal Map</option>
                                    <option value="4">Albedo</option>
                                    <option value="5">Metalness</option>
                                    <option value="6">Roughness</option>
                                    <option value="7">Emissive</option>
                                </select>

                                <!-- NEW: Model Rotation Fix -->
                                <select id="viewer-rotation-select" class="form-select" style="
                                    padding: 0.35rem 0.5rem;
                                    font-size: 0.75rem;
                                    min-width: 120px;
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.15);
                                    backdrop-filter: blur(12px);
                                    color: #fff;
                                    border-radius: 8px;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                ">
                                    <option value="none" selected>Rotation: None</option>
                                    <option value="x90_neg">X -90¬∞ (Fix)</option>
                                    <option value="x90_pos">X +90¬∞</option>
                                    <option value="y90">Y 90¬∞</option>
                                    <option value="y180">Y 180¬∞</option>
                                    <option value="y270">Y 270¬∞</option>
                                    <option value="z90">Z 90¬∞</option>
                                    <option value="z90_neg">Z -90¬∞</option>
                                </select>
            </div>
            
                            <!-- Top-center: Camera Mode Button -->
                            <div id="viewer-camera-wrap" style="position: absolute; top: 0.75rem; left: 50%; transform: translateX(-50%); pointer-events: auto; display: flex; gap: 0.5rem; align-items: center;">
                                <div id="viewer-fps" style="font-size: 0.65rem; color: rgba(255,255,255,0.4); font-family: monospace; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); white-space: nowrap;">-- FPS</div>
                                <button id="viewer-camera-btn" class="btn btn-secondary" style="
                                    padding: 0.4rem 0.85rem;
                                    font-size: 0.8rem;
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    display: flex;
                                    align-items: center;
                                    gap: 0.5rem;
                                    color: #fff;
                                    cursor: pointer;
                                ">
                                    <span style="font-size: 1.1rem;">üì∑</span>
                                    <span id="viewer-camera-label">Orbit</span>
                                    <span style="font-size: 0.7rem; opacity: 0.6;">‚ñº</span>
                                </button>

                                <button id="viewer-fullscreen-btn" class="btn btn-secondary" style="
                                    padding: 0.4rem 0.85rem;
                                    font-size: 0.8rem;
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    display: flex;
                                    align-items: center;
                                    gap: 0.5rem;
                                    color: #fff;
                                    cursor: pointer;
                                " title="Fullscreen (Space)">
                                    <span style="font-size: 1.1rem;">‚õ∂</span>
                                    <span>Fullscreen</span>
                                </button>

                                <button id="viewer-gizmos-btn" class="btn btn-secondary" title="Toggle Gizmos" style="
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    color: #fff;
                                    padding: 0.4rem 0.6rem;
                                    font-size: 1.1rem;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    width: 36px;
                                    height: 36px;
                                    cursor: pointer;
                                ">ü™Ñ</button>

                                <button id="viewer-default-toggle" class="btn btn-secondary" title="Default/Saved Comparison" style="
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    color: #fff;
                                    padding: 0.4rem 0.6rem;
                                    font-size: 1.1rem;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    width: 36px;
                                    height: 36px;
                                    cursor: pointer;
                                ">üè†</button>
            </div>
            
                            <!-- Top-right: Rig Type Selector -->
                            <div id="viewer-rigtype-wrap" style="position: absolute; top: 0.75rem; right: 0.75rem; pointer-events: auto;">
                                <select id="viewer-rigtype-select" class="form-select" style="
                                    padding: 0.35rem 0.5rem;
                                    font-size: 0.75rem;
                                    min-width: 130px;
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.15);
                                    backdrop-filter: blur(12px);
                                    color: #fff;
                                    border-radius: 8px;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                ">
                                    <option value="char" selected>Mode: Character</option>
                                    <option value="rigidbodies">Mode: Rigid Bodies</option>
                                    <option value="solid">Mode: Solid Object</option>
                                    <option value="animations">Mode: Animations</option>
                                </select>
            </div>
            
                            <!-- Bottom-left: Lighting Sliders -->
                            <div id="viewer-lighting-wrap" style="position: absolute; bottom: 0.75rem; left: 0.75rem; pointer-events: auto;">
                                <div style="
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.1);
                                    backdrop-filter: blur(12px);
                                    border-radius: 10px;
                                    min-width: 180px;
                                    overflow: hidden;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                ">
                                    <!-- Header (Collapsible trigger) -->
                                    <div id="lighting-panel-header" style="
                                        padding: 0.65rem 0.8rem;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        justify-content: space-between;
                                        user-select: none;
                                        background: rgba(255,255,255,0.03);
                                    ">
                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.4rem;">
                                            <span>üîÜ Lighting</span>
                                            <span id="lighting-panel-arrow" style="font-size: 0.6rem; opacity: 0.5; transition: transform 0.2s;">‚ñº</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <button id="ao-rebake-btn" title="Rebake AO" style="
                                                background: rgba(79, 70, 229, 0.3);
                                                border: 1px solid rgba(79, 70, 229, 0.5);
                                                border-radius: 4px;
                                                color: #fff;
                                                cursor: pointer;
                                                padding: 2px 6px;
                                                font-size: 0.6rem;
                                                pointer-events: auto;
                                            " onclick="event.stopPropagation()">AO</button>
                                            <div style="position: relative; width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); overflow: hidden; cursor: pointer; pointer-events: auto;" id="bg-color-preview" onclick="event.stopPropagation()">
                                                <input type="color" id="bg-color-picker" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; cursor: pointer; border: none; padding: 0; background: none;">
                                            </div>
                                            <button class="eye-dropper-btn" data-target="bg-color-picker" title="Pick color from screen" style="
                                                background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 0; font-size: 0.8rem; pointer-events: auto;
                                            " onclick="event.stopPropagation()">üß™</button>
                                        </div>
                                    </div>

                                    <!-- Panel Content -->
                                    <div id="lighting-panel-content" class="hidden" style="padding: 0 0.8rem 0.65rem 0.8rem;">
                                        <!-- Main Light -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Light</label>
                                        <input type="range" id="light-main-slider" min="0" max="10" step="0.01" value="3" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #ffd700);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-main-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">3.0</span>
                                    </div>
                                    <!-- Environment -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Env</label>
                                        <input type="range" id="light-env-slider" min="0" max="10" step="0.01" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #87ceeb);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-env-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.0</span>
                                    </div>
                                    <!-- Reflection -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Reflect</label>
                                        <input type="range" id="light-reflect-slider" min="0" max="10" step="0.01" value="3" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-reflect-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">3.0</span>
                                    </div>

                                    <!-- Bloom Strength -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Bloom</label>
                                        <input type="range" id="bloom-strength-slider" min="0" max="1" step="0.01" value="0" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-strength-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.0</span>
                                    </div>
                                    <!-- Bloom Threshold -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Threshold</label>
                                        <input type="range" id="bloom-threshold-slider" min="0" max="1" step="0.05" value="0.8" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-threshold-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.8</span>
                                    </div>
                                    <!-- Bloom Radius -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Radius</label>
                                        <input type="range" id="bloom-radius-slider" min="0" max="1" step="0.05" value="0.4" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-radius-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.4</span>
                                    </div>

                                    <!-- Ground Settings -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Ground</label>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="ground-color-picker" value="#222222" style="
                                                    padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="ground-color-picker" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                            <input type="range" id="ground-size-slider" min="0.1" max="100" step="0.01" value="100" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="ground-size-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 20px; text-align: right;">100.000</span>
                                        </div>
                                    </div>

                                    <!-- Shadow Settings -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Shadow Soft</label>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                            <input type="range" id="shadow-radius-slider" min="0" max="10" step="0.01" value="1" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="shadow-radius-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 20px; text-align: right;">1.000</span>
                                        </div>
                                    </div>

                                    <!-- Day/Night & Sun -->
                                    <div style="margin-top: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Time/Preset</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="range" id="lighting-time-slider" min="0" max="24" step="0.01" value="12" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <select id="lighting-preset-select" style="background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff; font-size: 0.65rem; padding: 1px 2px; outline: none;">
                                                    <option value="day" style="background: #222;">Day</option>
                                                    <option value="night" style="background: #222;">Night</option>
                                                    <option value="sunset" style="background: #222;">Sunset</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Sun Rot/Inc</label>
                                            <div style="display: flex; gap: 0.3rem; flex: 1;">
                                                <input type="range" id="sun-rotation-slider" min="0" max="360" step="0.1" value="45" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Rotation Y">
                                                <input type="range" id="sun-inclination-slider" min="0" max="90" step="0.1" value="45" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Inclination">
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Ambient</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="color" id="ambient-color-picker" value="#ffffff" style="padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;">
                                                <input type="range" id="ambient-intensity-slider" min="0" max="2" step="0.01" value="0.3" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Fog</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="color" id="fog-color-picker" value="#000000" style="padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;">
                                                <input type="range" id="fog-density-slider" min="0" max="1" step="0.01" value="0" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Fog Density">
                                                <span id="fog-density-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 35px; text-align: right;">0.00</span>
                                            </div>
                                        </div>
                                        
                                        <!-- AO Bake Settings -->
                                        <div style="margin-top: 0.6rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.05em;">AO Bake</div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Samples</label>
                                                <input type="range" id="ao-samples-slider" min="8" max="64" step="8" value="32" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-samples-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 20px; text-align: right;">32</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Radius</label>
                                                <input type="range" id="ao-radius-slider" min="0.05" max="0.5" step="0.01" value="0.15" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-radius-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 30px; text-align: right;">0.15</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Intensity</label>
                                                <input type="range" id="ao-intensity-slider" min="0.5" max="3.0" step="0.1" value="1.5" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-intensity-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 25px; text-align: right;">1.5</span>
                                            </div>
                                        </div>
                                    </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Bottom-right: Texture Adjustments -->
                            <div id="viewer-adjustments-wrap" style="position: absolute; bottom: 0.75rem; right: 0.75rem; pointer-events: auto;">
                                <div style="
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.1);
                                    backdrop-filter: blur(12px);
                                    border-radius: 10px;
                                    min-width: 180px;
                                    overflow: hidden;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                ">
                                    <!-- Header (Collapsible trigger) -->
                                    <div id="adjustments-panel-header" style="
                                        padding: 0.65rem 0.8rem;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        justify-content: space-between;
                                        user-select: none;
                                        background: rgba(255,255,255,0.03);
                                    ">
                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.4rem;">
                                            <span>üé® Adjustments</span>
                                            <span id="adjustments-panel-arrow" style="font-size: 0.6rem; opacity: 0.5; transition: transform 0.2s;">‚ñº</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.35rem;" onclick="event.stopPropagation()">
                                            <button id="adj-sync-view-btn" title="Sync view with channel" style="
                                                background: rgba(255,255,255,0.1);
                                                border: 1px solid rgba(255,255,255,0.2);
                                                border-radius: 4px;
                                                color: #fff;
                                                font-size: 0.75rem;
                                                padding: 0px 4px;
                                                cursor: pointer;
                                                outline: none;
                                                height: 18px;
                                                display: flex;
                                                align-items: center;
                                                transition: all 0.2s;
                                            ">üëÅÔ∏è</button>
                                            <select id="adj-target-channel" style="
                                                background: rgba(0,0,0,0.5);
                                                border: 1px solid rgba(255,255,255,0.2);
                                                border-radius: 4px;
                                                color: #fff;
                                                font-size: 0.65rem;
                                                padding: 1px 4px;
                                                cursor: pointer;
                                                outline: none;
                                            ">
                                                <option value="albedo" style="background: #222;">Albedo</option>
                                                <option value="ao" style="background: #222;">AO</option>
                                                <option value="normal" style="background: #222;">Normal</option>
                                                <option value="roughness" style="background: #222;">Roughness</option>
                                                <option value="metalness" style="background: #222;">Metalness</option>
                                                <option value="emissive" style="background: #222;">Emissive</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- Panel Content -->
                                    <div id="adjustments-panel-content" class="hidden" style="padding: 0 0.8rem 0.65rem 0.8rem;">
                                        <!-- Brightness -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Bright</label>
                                        <input type="range" id="adj-bright-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #000, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-bright-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.00</span>
                                    </div>
                                    <!-- Contrast -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Contrast</label>
                                        <input type="range" id="adj-contrast-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #444, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-contrast-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.00</span>
                                    </div>
                                    <!-- Saturation -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Satur</label>
                                        <input type="range" id="adj-satur-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #888, #f00, #ff0, #0f0, #0ff, #00f, #f0f);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-satur-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.0</span>
                                    </div>

                                    <!-- Mode -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Mode</label>
                                        <select id="adj-mode-select" style="
                                            flex: 1;
                                            background: rgba(0,0,0,0.5);
                                            border: 1px solid rgba(255,255,255,0.2);
                                            border-radius: 4px;
                                            color: #fff;
                                            font-size: 0.65rem;
                                            padding: 2px 4px;
                                            cursor: pointer;
                                            outline: none;
                                        ">
                                            <option value="0" style="background: #222;">Default</option>
                                            <option value="1" style="background: #222;">Emissive Mask</option>
                                        </select>
                                    </div>

                                    <!-- Mask Group -->
                                    <div id="adj-mask-group" class="hidden">
                                        <!-- Mask Color -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Mask Col</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="adj-mask-color" value="#ffffff" style="
                                                    padding: 0;
                                                    border: none;
                                                    width: 30px;
                                                    height: 18px;
                                                    background: none;
                                                    cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="adj-mask-color" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                        </div>
                                        <!-- Softness -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Softness</label>
                                                <input type="range" id="adj-soft-slider" min="0" max="1" step="0.001" value="0.5" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="adj-soft-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.50</span>
                                        </div>
                                        <!-- Emissive Mult -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Emis Mult</label>
                                            <input type="range" id="adj-em-mult-slider" min="0" max="50" step="0.001" value="2" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="adj-em-mult-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">2.0</span>
                                        </div>

                                        <!-- Invert Mask -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Invert</label>
                                            <input type="checkbox" id="adj-invert-mask" style="cursor: pointer;">
                                        </div>

                                        <!-- Blend Color -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Blend Col</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="adj-blend-color" value="#ffffff" style="
                                                    padding: 0;
                                                    border: none;
                                                    width: 30px;
                                                    height: 18px;
                                                    background: none;
                                                    cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="adj-blend-color" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                        </div>
                                    </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Viewer Controls Row (under canvas) -->
                    <div id="viewer-controls-row" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.75rem; margin-top: 0.75rem;">
                        <button id="change-rig-btn" class="btn btn-primary" style="
                            padding: 0.55rem 1rem;
                            font-size: 0.9rem;
                            display: flex;
                            align-items: center;
                            gap: 0.5rem;
                        ">
                            <span style="font-size: 1.2rem;">üîÑ</span>
                    <span data-i18n="btn_restart_task">Restart task</span>
                </button>
                    </div>
            </div>
                <div id="video-preview-title" style="font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem;">üé¨ Video Preview</div>
                <video id="video-player" controls autoplay muted loop playsinline 
                       style="width: 100%; height: auto; max-height: 70vh; object-fit: contain; border-radius: 12px; background: #000; display: block;"></video>
                <div id="hdrp-renders" class="hidden"
                     style="display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 0.75rem; margin-top: 0.75rem;">
                    <!-- HDRP renders injected by JS -->
            </div>
            </div>
            
            <div class="alert alert-info hidden mt-3" id="video-pending">
                <span data-i18n="task_video_pending">Video is being generated...</span>
            </div>
            
            <!-- Actions removed (buttons moved into header) -->
        </div>
        
        <!-- Files List -->
        <div class="card mt-3" id="downloads-card">
            <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                <h3 class="card-title">Downloads (<span id="files-count">0</span>)</h3>
                <button id="telegram-share-btn" class="telegram-share-btn" onclick="TelegramApp.shareTask(TaskUI.taskId)" style="display: none;">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69.01-.03.01-.14-.07-.2-.08-.06-.19-.04-.27-.02-.12.03-1.99 1.27-5.62 3.72-.53.36-1.01.54-1.44.53-.47-.01-1.38-.27-2.06-.49-.83-.27-1.49-.42-1.43-.88.03-.24.37-.49 1.02-.75 4-1.74 6.67-2.89 8.02-3.44 3.82-1.58 4.62-1.86 5.14-1.86.11 0 .37.03.53.17.14.12.18.28.2.45-.01.07.01.23-.01.35z"/></svg>
                    Share
                </button>
            </div>
            <ul class="file-list" id="file-list"
                style="max-height: none; overflow: hidden; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 0.75rem;">
                <!-- Skeleton loading -->
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 200px;"></div>
                </li>
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 180px;"></div>
                </li>
            </ul>
        </div>
        
        <!-- Additional Content (Textures) -->
        <div class="card mt-3" id="additional-content-section" style="display: none;">
            <div class="card-header">
                <h3 class="card-title">üñºÔ∏è Additional Content</h3>
            </div>
            <div id="texture-gallery" class="texture-gallery"></div>
        </div>
    </main>

    <!-- Owner Tasks Modal -->
    <div id="owner-tasks-modal" class="hidden" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 2rem;">
        <div class="card" style="min-width: 900px; max-width: 1100px; max-height: 90vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div>
                    <h3 id="owner-tasks-title">All tasks</h3>
                    <p style="color: var(--text-muted); margin-top: 0.5rem;" id="owner-tasks-subtitle"></p>
                </div>
                <button class="btn btn-ghost" id="owner-tasks-close" style="padding: 0.5rem;">‚úï</button>
            </div>

            <div style="overflow-x: auto; flex: 1; min-height: 0;">
                <table class="admin-table">
                    <thead>
                        <tr>
                            <th>Preview</th>
                            <th>ID</th>
                            <th>Status</th>
                            <th>Progress</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="owner-tasks-table">
                        <tr><td colspan="6" style="text-align:center; color: var(--text-muted);">Loading...</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="flex justify-between items-center mt-3" id="owner-tasks-pagination">
                <span id="owner-tasks-pagination-info" style="color: var(--text-muted); font-size: 0.875rem;"></span>
                <div class="flex gap-1">
                    <button class="btn btn-secondary" id="owner-tasks-prev" disabled>‚Üê Prev</button>
                    <button class="btn btn-secondary" id="owner-tasks-next" disabled>Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal (HDRP renders) -->
    <div id="image-preview-modal" class="hidden" style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1100; padding: 1.5rem;">
        <div style="position: relative; max-width: 95vw; max-height: 95vh;">
            <button class="btn btn-ghost" id="image-preview-close"
                    style="position: absolute; top: -0.25rem; right: -0.25rem; padding: 0.5rem; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.12);">
                ‚úï
            </button>
            <img id="image-preview-img" alt="preview"
                 style="display: block; max-width: 95vw; max-height: 95vh; width: auto; height: auto; border-radius: 12px; background: #000; border: 1px solid rgba(255,255,255,0.08);">
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p data-i18n="footer_text">AutoRig Online ¬© 2025</p>
        </div>
    </footer>
    
    <!-- Scripts -->
    <script src="/static/js/i18n.js"></script>
    <script>
        const TaskPage = {
            taskId: null,
            pollInterval: null,
            task: null,
            ownerTasksPage: 1,
            ownerTasksPerPage: 12,
            ownerTasksTotal: 0,
            // Visual progress derived from progress log (does NOT change backend/DB state)
            lastVisualProgress: 0,
            lastLogLineCount: 0,
            // Cache for file list to avoid unnecessary re-renders
            lastFileListHash: null,
            
            async init() {
                // Init i18n
                await I18n.init();
                
                // Setup theme
                this.setupTheme();
                
                // Get task ID from URL (sanitize to handle malformed URLs like ?id=xxx?mode=webapp)
                const params = new URLSearchParams(window.location.search);
                const rawId = params.get('id') || '';
                this.taskId = rawId.split('?')[0];
                
                // Check webapp mode
                this.isWebAppMode = params.get('mode') === 'webapp';
                if (this.isWebAppMode) {
                    document.body.classList.add('webapp-mode');
                    // Init Telegram Web App if available
                    if (window.Telegram?.WebApp) {
                        window.Telegram.WebApp.ready();
                        window.Telegram.WebApp.expand();
                    }
                }
                
                if (!this.taskId) {
                    this.showError('No task ID provided');
                    return;
                }
                
                // Expose for onclick handlers
                window.TaskUI = this;
                
                // Load purchase state
                await this.loadPurchaseState();
                
                // Start polling
                await this.fetchTask();
                this.pollInterval = setInterval(() => this.fetchTask(), 2000);
                
                // Load queue status (skip in webapp mode)
                if (!this.isWebAppMode) {
                    this.loadQueueStatus();
                    setInterval(() => this.loadQueueStatus(), 10000);
                }
                
                // Setup buttons
                this.setupButtons();

                // Progress log polling (every 10s while page is open)
                this.startProgressLogPolling();
            },
            
            setupTheme() {
                const toggle = document.getElementById('theme-toggle');
                const savedTheme = localStorage.getItem('autorig_theme') || 'dark';
                document.documentElement.setAttribute('data-theme', savedTheme);
                toggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                
                toggle.addEventListener('click', () => {
                    const current = document.documentElement.getAttribute('data-theme');
                    const newTheme = current === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', newTheme);
                    localStorage.setItem('autorig_theme', newTheme);
                    toggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                });
            },
            
            async fetchTask() {
                try {
                    const response = await fetch(`/api/task/${this.taskId}`);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            this.showError('Task not found');
                            this.stopPolling();
                        }
                        return;
                    }
                    
                    this.task = await response.json();
                    this.updateUI();
                    
                    // Stop polling when done or error
                    if (this.task.status === 'done' || this.task.status === 'error') {
                        this.stopPolling();
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                }
            },
            
            updateUI() {
                const task = this.task;
                
                // Status
                const statusBadge = document.getElementById('status-badge');
                const statusText = document.getElementById('status-text');
                
                statusBadge.className = 'alert';
                if (task.status === 'done') {
                    statusBadge.classList.add('alert-success');
                    statusText.textContent = t('task_status_done');
                    // Show Telegram share button when task is done
                    const shareBtn = document.getElementById('telegram-share-btn');
                    if (shareBtn) shareBtn.style.display = 'flex';
                    // Haptic feedback for Telegram Web App
                    if (window.TelegramApp) TelegramApp.hapticFeedback('success');
                } else if (task.status === 'error') {
                    statusBadge.classList.add('alert-error');
                    statusText.textContent = t('task_status_error');
                    if (window.TelegramApp) TelegramApp.hapticFeedback('error');
                } else if (task.status === 'processing') {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_processing');
                } else {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_created');
                }
                
                // Title helper: started vs queued
                const runStateEl = document.getElementById('task-run-state');
                if (runStateEl) {
                    const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                    const isRu = lang.startsWith('ru');
                    let stateText = '';
                    // We no longer rely on worker_api/guid for non-admin views (workers must be hidden).
                    if (task.status === 'processing') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–¥–∞—á–∞ –∑–∞–ø—É—â–µ–Ω–∞' : 'Conversion Progress ‚Äî task is running';
                    else if (task.status === 'created') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–¥–∞—á–∞ –≤ –æ—á–µ—Ä–µ–¥–∏' : 'Conversion Progress ‚Äî task is queued';
                    else if (task.status === 'done') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–≤–µ—Ä—à–µ–Ω–æ' : 'Conversion Progress ‚Äî completed';
                    else if (task.status === 'error') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –æ—à–∏–±–∫–∞' : 'Conversion Progress ‚Äî error';
                    runStateEl.textContent = stateText;
                }

                // Admin-only: Input URL block (visible only when API returns input_url)
                const adminRow = document.getElementById('admin-input-url-row');
                const adminLink = document.getElementById('admin-input-url-link');
                const adminCopy = document.getElementById('admin-input-url-copy');
                const adminWorkerRow = document.getElementById('admin-worker-progress-row');
                const adminWorkerLink = document.getElementById('admin-worker-progress-link');
                if (adminRow && adminLink && adminCopy) {
                    const inputUrl = task && task.input_url ? String(task.input_url) : '';
                    if (inputUrl) {
                        adminRow.classList.remove('hidden');
                        adminLink.href = inputUrl;
                        adminLink.textContent = inputUrl;
                        adminLink.title = inputUrl;
                        
                        // Worker Progress Page link (admin)
                        const progressPage = task && task.progress_page ? String(task.progress_page) : '';
                        if (progressPage && adminWorkerRow && adminWorkerLink) {
                            adminWorkerRow.classList.remove('hidden');
                            adminWorkerLink.href = progressPage;
                            adminWorkerLink.textContent = progressPage;
                            adminWorkerLink.title = progressPage;
                        } else if (adminWorkerRow) {
                            adminWorkerRow.classList.add('hidden');
                        }
                        
                        if (!adminCopy.__wired) {
                            adminCopy.__wired = true;
                            adminCopy.addEventListener('click', async (e) => {
                                e.preventDefault();
                                const cur = (this.task && this.task.input_url) ? String(this.task.input_url) : '';
                                if (!cur) return;
                                try {
                                    await navigator.clipboard.writeText(cur);
                                    adminCopy.textContent = 'Copied';
                                    setTimeout(() => { adminCopy.textContent = 'Copy'; }, 900);
                                } catch (_) {
                                    // fallback
                                    const ta = document.createElement('textarea');
                                    ta.value = cur;
                                    document.body.appendChild(ta);
                                    ta.select();
                                    document.execCommand('copy');
                                    ta.remove();
                                    adminCopy.textContent = 'Copied';
                                    setTimeout(() => { adminCopy.textContent = 'Copy'; }, 900);
                                }
                            });
                        }
                    } else {
                        adminRow.classList.add('hidden');
                        adminLink.href = '#';
                        adminLink.textContent = '-';
                        adminLink.title = '';
                    }
                }
                
                // Progress (visual, can be driven by progress.txt log)
                this.setProgressUI(this.getDisplayedProgress(task));
                document.getElementById('ready-count').textContent = task.ready_count;
                document.getElementById('total-count').textContent = task.total_count;

                // Tooltip: worker_api + guid on hover for debugging (admin only; hidden for public)
                const pc = document.getElementById('progress-container');
                if (pc) {
                    const guid = task.guid || (() => {
                        const urls = []
                            .concat(task.ready_urls || [])
                            .concat(task.output_urls || [])
                            .concat(task.video_url ? [task.video_url] : []);
                        for (const u of urls) {
                            const fn = String(u || '').split('/').pop() || '';
                            const m = fn.match(/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})_/);
                            if (m) return m[1];
                        }
                        return '';
                    })();
                    if (task.worker_api) {
                        pc.title = `worker_api: ${task.worker_api}\nGUID: ${guid || '-'}`;
                    } else {
                        pc.title = '';
                    }
                }

                // Progress log (processing/done)
                this.updateProgressLog(task);
                
                // Error
                if (task.error_message) {
                    document.getElementById('error-container').classList.remove('hidden');
                    document.getElementById('error-message').textContent = task.error_message;
                    } else {
                    document.getElementById('error-container').classList.add('hidden');
                    document.getElementById('error-message').textContent = '';
                }

                // Restart button after 3 hours (always, even if done)
                const restartBtn = document.getElementById('restart-task-btn');
                if (task.created_at) {
                    const createdAt = new Date(task.created_at).getTime();
                    const ageMs = Date.now() - createdAt;
                    const threeHoursMs = 3 * 60 * 60 * 1000;
                    const oneMinuteMs = 60 * 1000;
                    const threshold = task.status === 'error' ? oneMinuteMs : threeHoursMs;
                    if (ageMs >= threshold) {
                        restartBtn.classList.remove('hidden');
                    } else {
                        restartBtn.classList.add('hidden');
                    }
                }
                
                // Video - use proxy to avoid Mixed Content
                if (task.video_ready) {
                    document.getElementById('video-container').classList.remove('hidden');
                    document.getElementById('video-pending').classList.add('hidden');
                    const video = document.getElementById('video-player');
                    const proxyUrl = `/api/video/${this.taskId}`;
                    // Use HDRP render thumbnail as poster for the video (fast preview while loading).
                    video.poster = `/api/thumb/${this.taskId}`;
                    if (!video.src.includes(this.taskId)) {
                        video.src = proxyUrl;
                        video.load();
                        video.play().catch(() => {}); // Auto-play may be blocked
                    }
                } else if (task.status === 'processing' || task.status === 'done') {
                    document.getElementById('video-pending').classList.remove('hidden');
                }
                
                // HDRP renders row (under video)
                this.updateHdrpRenders(task.ready_urls);
                
                // Files list - always visible, purchase buttons shown for non-owners
                const downloadsCard = document.getElementById('downloads-card');
                if (downloadsCard) {
                    // Show downloads section when task has any progress
                    const hasFiles = task.ready_urls && task.ready_urls.length > 0;
                    const isProcessing = task.status === 'processing' || task.status === 'done';
                    downloadsCard.classList.toggle('hidden', !hasFiles && !isProcessing);
                }
                // Use output_urls for Downloads (all expected files), fallback to ready_urls
                const downloadUrls = (task.output_urls && task.output_urls.length > 0) ? task.output_urls : task.ready_urls;
                this.updateFileList(downloadUrls, task, task.ready_urls || []);

            },

            progressLogLoaded: false,
            progressLogExpanded: false,
            progressLogData: null,

            setProgressUI(pct) {
                const p = Math.max(0, Math.min(100, Math.floor(Number(pct) || 0)));
                const percentEl = document.getElementById('progress-percent');
                const fillEl = document.getElementById('progress-fill');
                if (percentEl) percentEl.textContent = `${p}%`;
                if (fillEl) fillEl.style.width = `${p}%`;
            },

            getDisplayedProgress(task) {
                if (!task) return 0;
                if (task.status === 'done') return 100;
                // Keep monotonic: never decrease due to transient log/task data.
                const logP = Math.max(0, Math.min(99, Math.floor(this.lastVisualProgress || 0)));
                const apiP = Math.max(0, Math.min(99, Math.floor(task.progress || 0)));
                return Math.max(apiP, logP);
            },

            computeVisualProgressFromLog(fullText, task) {
                if (!fullText) return null;
                if (task && task.status === 'done') return 100;

                const lines = String(fullText)
                    .split(/\r?\n/)
                    .map(s => s.trim())
                    .filter(Boolean);
                if (!lines.length) return null;

                // Milestones: keyword -> [start,end] percent range.
                // Within a stage, each new log line increments progress by +1 until it reaches stage end.
                const milestones = [
                    { re: /Conversion started\./i, start: 2, end: 10 },
                    { re: /Geometry:/i, start: 10, end: 18 },
                    { re: /Normalization:/i, start: 18, end: 24 },
                    { re: /Model preparation completed\./i, start: 24, end: 30 },
                    { re: /Extracting textures\.\.\./i, start: 30, end: 40 },
                    { re: /Textures prepared\./i, start: 40, end: 48 },
                    { re: /OpenPose analysis:/i, start: 48, end: 60 },
                    { re: /OpenPose analysis completed:/i, start: 60, end: 66 },
                    { re: /Pose preparation:/i, start: 66, end: 74 },
                    { re: /Pose correction completed\./i, start: 74, end: 80 },
                    { re: /Rig created\./i, start: 80, end: 86 },
                    { re: /Animation retargeting completed\./i, start: 86, end: 92 },
                    { re: /Unity package exported\./i, start: 92, end: 96 },
                    { re: /Preview video created\./i, start: 96, end: 99 },
                ];

                let stage = null;
                let stageLineIdx = -1;

                for (const m of milestones) {
                    // Find the last occurrence of each milestone in the full log.
                    for (let i = lines.length - 1; i >= 0; i--) {
                        if (m.re.test(lines[i])) {
                            if (!stage || i > stageLineIdx) {
                                stage = m;
                                stageLineIdx = i;
                            }
                            break;
                        }
                    }
                }

                // Fallback: any log activity should start moving the bar.
                if (!stage) {
                    return Math.min(12, 1 + lines.length);
                }

                const span = Math.max(0, (stage.end - stage.start));
                const linesSince = Math.max(0, lines.length - stageLineIdx - 1);
                const within = Math.min(span, linesSince); // +1% per new line inside the stage (until end)
                const computed = stage.start + within;

                if (task && task.status === 'processing') {
                    return Math.max(1, Math.min(99, computed));
                }
                return Math.max(0, Math.min(99, computed));
            },

            async updateProgressLog(task) {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint) return;

                // Show log for any task that is not error (processing/done), and let refreshProgressLog() fetch it.
                if (task && task.status !== 'error') {
                    if (this.progressLogData) box.classList.remove('hidden');
                }
            },

            async refreshProgressLog() {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint) return;
                if (!this.taskId) return;

                // Only poll while page has a task and it's not error
                if (!this.task || this.task.status === 'error') {
                    box.classList.add('hidden');
                    pre.textContent = '';
                    this.progressLogData = null;
                    return;
                }

                // For visual progress we need enough context, so fetch full log while processing.
                const wantFull = !!this.progressLogExpanded || (this.task && this.task.status === 'processing');
                const url = wantFull
                    ? `/api/task/${this.taskId}/progress_log?full=1`
                    : `/api/task/${this.taskId}/progress_log`;

                try {
                    const resp = await fetch(url, { cache: 'no-store' });
                    const data = await resp.json();
                    // Backend always returns 200; but guard anyway.
                    if (!resp.ok || !data) return;

                    // If log isn't available yet, show a friendly message (no errors)
                    if (data.available === false) {
                        const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                        const isRu = lang.startsWith('ru');
                        const msg = data.state === 'queued'
                            ? (isRu ? '–û–∂–∏–¥–∞–µ–º –∑–∞–ø—É—Å–∫ –∑–∞–¥–∞—á–∏ –Ω–∞ –≤–æ—Ä–∫–µ—Ä–µ‚Ä¶' : 'Waiting for worker to start‚Ä¶')
                            : (isRu ? '–õ–æ–≥ –µ—â–µ –Ω–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –≤–æ—Ä–∫–µ—Ä–æ–º‚Ä¶' : 'Log is not published yet‚Ä¶');
                        box.classList.remove('hidden');
                        hint.textContent = isRu ? '–ö–ª–∏–∫ ‚Äî —Ä–∞—Å–∫—Ä—ã—Ç—å' : 'Click to expand';
                        pre.textContent = msg;
                        pre.style.maxHeight = `3.2em`;
                        pre.style.overflow = 'hidden';
                        this.progressLogData = null;
                        return;
                    }

                    this.progressLogData = data;
                    box.classList.remove('hidden');
                    this.renderProgressLog();

                    // Update visual progress from log (does not change backend state)
                    const logText = (data.full_text && String(data.full_text).trim())
                        ? data.full_text
                        : (data.tail_lines || []).join('\n');
                    const computed = this.computeVisualProgressFromLog(logText, this.task);
                    if (computed !== null && computed !== undefined) {
                        const clamped = Math.max(0, Math.min(100, Math.floor(Number(computed) || 0)));
                        if (clamped > (this.lastVisualProgress || 0)) {
                            this.lastVisualProgress = clamped;
                        }
                        this.setProgressUI(this.getDisplayedProgress(this.task));
                    }
                } catch (_) {
                    // ignore transient errors
                }
            },

            renderProgressLog() {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint || !this.progressLogData) return;

                const tail = (this.progressLogData.tail_lines || []).join('\n');
                let full = this.progressLogData.full_text || '';
                if (this.progressLogData.truncated) {
                    full = full + '\n‚Ä¶ (truncated)';
                }

                const text = this.progressLogExpanded ? full : tail;
                pre.textContent = text || '';

                hint.textContent = this.progressLogExpanded ? 'Click to collapse' : 'Click to expand';

                // Auto-fit height to content by measuring scrollHeight
                requestAnimationFrame(() => {
                    const target = pre.scrollHeight;
                    if (this.progressLogExpanded) {
                        const maxPx = Math.floor(window.innerHeight * 0.6);
                        pre.style.maxHeight = `${Math.min(target, maxPx)}px`;
                        pre.style.overflow = 'auto';
                        // Keep at bottom for real-time logs
                        pre.scrollTop = pre.scrollHeight;
                    } else {
                        pre.style.maxHeight = `3.2em`;
                        pre.style.overflow = 'hidden';
                    }
                });

                // Show FAILURE message if present in log
                const failureBox = document.getElementById('progress-failure');
                const failureText = document.getElementById('progress-failure-text');
                if (failureBox && failureText) {
                    const fullText = this.progressLogData.full_text || tail;
                    const failureMatch = fullText.match(/FAILURE:\s*(.+)/i);
                    if (failureMatch) {
                        failureText.textContent = failureMatch[1];
                        failureBox.classList.remove('hidden');
                    } else {
                        failureBox.classList.add('hidden');
                    }
                }
            },
            
            updateHdrpRenders(urls) {
                const rendersEl = document.getElementById('hdrp-renders');
                const videoContainer = document.getElementById('video-container');
                if (!rendersEl) return;

                // Only show under the video block
                if (!videoContainer || videoContainer.classList.contains('hidden')) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }
                
                if (!urls || urls.length === 0) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }
                
                const matches = [];
                urls.forEach((url, idx) => {
                    const filename = (url || '').split('/').pop() || '';
                    const m = filename.match(/_Unity_HDRP_Render_([1-3])_view\.jpe?g$/i);
                    if (!m) return;
                    const n = Number(m[1]);
                    if (!Number.isFinite(n) || n < 1 || n > 3) return;
                    matches[n - 1] = { idx, filename };
                });

                const items = matches.filter(Boolean);
                if (items.length === 0) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }

                rendersEl.classList.remove('hidden');
                rendersEl.innerHTML = items.map(({ idx, filename }) => {
                    const src = `/api/file/${this.taskId}/${idx}`;
                    return `
                        <img src="${src}"
                             alt="${filename}"
                             loading="lazy"
                             onerror="this.style.display='none'"
                             style="width: 100%; height: 220px; object-fit: cover; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); background: #000;">
                    `;
                }).join('');
            },
            
            // Purchase state
            purchaseState: {
                purchased_all: false,
                purchased_files: [],
                is_owner: false,
                login_required: false,
                user_credits: 0,
                loaded: false
            },

            async loadPurchaseState() {
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchases`);
                    if (resp.ok) {
                        const data = await resp.json();
                        this.purchaseState = { ...data, loaded: true };
                    }
                    // Also get user credits
                    const authResp = await fetch('/auth/me');
                    if (authResp.ok) {
                        const authData = await authResp.json();
                        this.purchaseState.user_credits = authData.credits_remaining || 0;
                        this.purchaseState.login_required = !authData.authenticated;
                    }
                } catch (e) {
                    console.warn('Failed to load purchase state:', e);
                }
            },

            async purchaseFile(fileIndex, displayName) {
                if (this.purchaseState.login_required) {
                    window.location.href = '/auth/login';
                    return;
                }
                if (this.purchaseState.user_credits < 1) {
                    window.location.href = '/buy-credits';
                    return;
                }
                if (!confirm(`${t('purchase_confirm_file')} "${displayName}" for 1 credit?`)) return;
                
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchase`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file_indices: [fileIndex] })
                    });
                    const data = await resp.json();
                    if (resp.ok) {
                        this.purchaseState.purchased_files = data.purchased_files;
                        this.purchaseState.user_credits = data.credits_remaining;
                        await this.fetchTask(); // Refresh file list
                    } else {
                        alert(data.detail || t('error_generic'));
                    }
                } catch (e) {
                    console.error('Purchase error:', e);
                    alert(t('error_generic'));
                }
            },

            async purchaseAll() {
                if (this.purchaseState.login_required) {
                    window.location.href = '/auth/login';
                    return;
                }
                if (this.purchaseState.user_credits < 3) {
                    window.location.href = '/buy-credits';
                    return;
                }
                if (!confirm(`${t('purchase_confirm_all')} 3 credits?`)) return;
                
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchase`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ all: true })
                    });
                    const data = await resp.json();
                    if (resp.ok) {
                        this.purchaseState.purchased_all = true;
                        this.purchaseState.user_credits = data.credits_remaining;
                        await this.fetchTask(); // Refresh file list
                    } else {
                        alert(data.detail || t('error_generic'));
                    }
                } catch (e) {
                    console.error('Purchase error:', e);
                    alert(t('error_generic'));
                }
            },

            updateFileList(urls, task, readyUrls = []) {
                const list = document.getElementById('file-list');
                const count = document.getElementById('files-count');
                
                // Calculate hash of current data to avoid unnecessary re-renders
                const currentHash = JSON.stringify(urls || []) + JSON.stringify(readyUrls || []) + (task?.status || '');
                if (this.lastFileListHash === currentHash && list.children.length > 0) {
                    return; // Data hasn't changed, skip re-render
                }
                this.lastFileListHash = currentHash;
                
                // Create a set of ready filenames for fast lookup
                const readyFilenames = new Set(
                    readyUrls.map(url => (url || '').trim().split('/').pop())
                );
                
                if (!urls || urls.length === 0) {
                    list.innerHTML = `<li class="file-item" style="color: var(--text-muted)">Waiting for files...</li>`;
                    count.textContent = '0';
                    this.renderTextureGallery([]);
                    return;
                }
                
                const blenderIcon = '/static/images/icons/blender_logo.png';
                const unityIcon = '/static/images/icons/unity-logo.png';
                const glbIcon = '/static/images/formats/glb.svg';
                const fbxIcon = '/static/images/formats/fbx.svg';
                const objIcon = '/static/images/formats/obj.svg';
                
                // Function to remove GUID prefix from filename
                // Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx_filename.ext -> filename.ext
                const cleanFilename = (filename) => {
                    return filename.replace(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}_/i, '');
                };
                
                // Function to get icon based on file extension
                const getIconForFile = (filename) => {
                    const ext = filename.split('.').pop().toLowerCase();
                    if (ext === 'blend') return blenderIcon;
                    if (ext === 'glb' || ext === 'gltf') return glbIcon;
                    if (ext === 'fbx') return fbxIcon;
                    if (ext === 'obj') return objIcon;
                    if (ext === 'unitypackage') return unityIcon;
                    if (ext === 'max' || ext === 'ma' || ext === 'c4d') return null;
                    return null;
                };

                const items = [];
                const textures = []; // Collect textures separately
                
                // Texture patterns to filter into separate gallery
                const texturePatterns = [
                    /_Roughness\.jpe?g$/i,
                    /_Metallic\.jpe?g$/i,
                    /_Normal\.jpe?g$/i,
                    /_texture\.jpe?g$/i,
                    /_AO\.jpe?g$/i,
                    /_BaseColor\.jpe?g$/i,
                    /_Albedo\.jpe?g$/i,
                    /_Diffuse\.jpe?g$/i,
                    /_Specular\.jpe?g$/i,
                    /_Height\.jpe?g$/i,
                    /_Displacement\.jpe?g$/i,
                    /_Emissive\.jpe?g$/i,
                ];
                
                // First, expand any concatenated URLs (bug in data - some URLs got merged)
                const guidPattern = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}_/gi;
                const expandedUrls = [];
                urls.forEach((url, idx) => {
                    const urlClean = (url || '').trim();
                    const rawFilename = urlClean.split('/').pop() || '';
                    // Check if filename contains multiple GUIDs (concatenated URLs)
                    const guidMatches = rawFilename.match(guidPattern);
                    if (guidMatches && guidMatches.length > 1) {
                        // Split on GUID pattern, keeping the GUID with each part
                        const parts = rawFilename.split(guidPattern).filter(Boolean);
                        guidMatches.forEach((guid, i) => {
                            if (parts[i]) {
                                const baseUrl = urlClean.substring(0, urlClean.lastIndexOf('/') + 1);
                                expandedUrls.push({ url: baseUrl + guid + parts[i], idx: idx + '_' + i });
                            }
                        });
                    } else {
                        expandedUrls.push({ url: urlClean, idx });
                    }
                });
                
                expandedUrls.forEach(({ url: urlClean, idx }) => {
                    const rawFilename = urlClean.split('/').pop() || '';
                    const filename = cleanFilename(rawFilename);

                    // Hide video artifacts (video is already shown on page)
                    if (/_video\.(mp4|mov)$/i.test(filename)) return;
                    if (/_video_poster\.jpe?g$/i.test(filename)) return;
                    if (/video\.(mp4|mov)$/i.test(filename)) return;
                    if (/video_poster\.jpe?g$/i.test(filename)) return;

                    // HDRP renders are shown as images under the video (not in file list)
                    if (/_Unity_HDRP_Render_[1-3]_view\.jpe?g$/i.test(filename)) return;
                    if (/Unity_HDRP_Render_[1-3]_view\.jpe?g$/i.test(filename)) return;
                    
                    // Hide _model_prepared.glb - used for viewer, not for download
                    if (/model_prepared\.glb$/i.test(filename)) return;

                    // Collect textures for preview gallery (they also appear in Downloads)
                    if (texturePatterns.some(p => p.test(filename))) {
                        const textureProxyUrl = `/api/file/${this.taskId}/download/${encodeURIComponent(rawFilename)}`;
                        textures.push({ url: textureProxyUrl, filename, idx });
                        // Don't return - textures should also be in Downloads list
                    }

                    // Use cleaned filename as display name and download name
                    const displayName = filename;
                    const icon = getIconForFile(filename);
                    const downloadName = filename;
                    // Use proxy URL to avoid mixed content (HTTPS site, HTTP worker)
                    const proxyUrl = `/api/file/${this.taskId}/download/${encodeURIComponent(rawFilename)}`;

                    items.push({
                        idx,
                        url: proxyUrl,
                        filename,
                        displayName,
                        icon,
                        downloadName,
                        isReady: readyFilenames.has(rawFilename),
                    });
                });
                
                // Render texture gallery
                this.renderTextureGallery(textures);

                count.textContent = String(items.length);
                // Use auto-fill grid for responsive layout
                list.style.gridTemplateColumns = `repeat(auto-fill, minmax(150px, 1fr))`;
                if (items.length === 0) {
                    list.innerHTML = `<li class="file-item" style="color: var(--text-muted)">Waiting for files...</li>`;
                    return;
                }

                // Check if user can download (owner or admin has purchased_all=true, others must purchase)
                const canDownloadAll = this.purchaseState.purchased_all || this.purchaseState.is_owner;
                
                // Add "Unlock Downloads" button at the top if not purchased
                let buyAllHtml = '';
                if (!canDownloadAll && items.length > 0) {
                    const hasCredits = this.purchaseState.user_credits >= 1;
                    buyAllHtml = `
                        <li class="file-item" style="flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem; background: linear-gradient(135deg, rgba(var(--accent-rgb), 0.15), rgba(var(--accent-rgb), 0.05)); border: 2px solid var(--accent);">
                            <div style="font-size: 0.95rem; font-weight: 500; color: var(--text-secondary);">
                                Unlock all downloads for this model
                            </div>
                            <button onclick="TaskUI.purchaseAll()" class="btn btn-primary" 
                                    style="width: 100%; justify-content: center; padding: 0.75rem 1rem; font-size: 1rem; gap: 0.5rem;"
                                    ${(hasCredits || this.purchaseState.login_required) ? '' : 'disabled'}>
                                <span style="font-size: 1.5rem;">üíé</span>
                                <span style="font-weight: 700; font-size: 1.1rem;">1</span>
                                <span>${t('btn_download_all')}</span>
                            </button>
                            ${this.purchaseState.login_required ? `
                                <a href="/auth/login" class="btn btn-secondary" style="width: 100%; justify-content: center; padding: 0.5rem; font-size: 0.85rem;">
                                    ${t('btn_login_to_purchase')}
                                </a>
                            ` : ''}
                        </li>
                    `;
                }

                const filesHtml = items.map((item, displayIdx) => {
                    // Use direct URL from output_urls
                    const downloadUrl = item.url;
                    const iconHtml = item.icon
                        ? `<img src="${item.icon}" alt="" aria-hidden="true" style="height: 2.5em; width: auto; object-fit: contain; display: block;" onerror="this.style.display='none'">`
                        : '';
                    
                    if (canDownloadAll) {
                        if (item.isReady) {
                            // Show download button - vertical layout: icon, filename, button
                            return `
                                <li class="file-item"
                                    style="flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; margin-bottom: 0; text-align: center; min-width: 0;">
                                    ${iconHtml}
                                    <div style="font-weight: 700; color: var(--accent); font-size: 0.95rem; word-break: break-all; overflow-wrap: anywhere; max-width: 100%; line-height: 1.3;" title="${item.displayName}">
                                        ${item.displayName}
                                    </div>
                                    <a href="${downloadUrl}" download="${item.downloadName}" class="btn btn-secondary"
                                       style="padding: 0.4rem 0.6rem; font-size: 0.75rem; margin-top: 0.25rem;">
                                        <img src="/static/images/icons/download.svg" alt="" aria-hidden="true" width="14" height="14">
                                        ${t('btn_download')}
                                    </a>
                                </li>
                            `;
                        } else {
                            // File not ready yet - show processing state
                            return `
                                <li class="file-item"
                                    style="flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; margin-bottom: 0; text-align: center; min-width: 0; opacity: 0.7;">
                                    ${iconHtml}
                                    <div style="font-weight: 700; color: var(--accent); font-size: 0.95rem; word-break: break-all; overflow-wrap: anywhere; max-width: 100%; line-height: 1.3;" title="${item.displayName}">
                                        ${item.displayName}
                                    </div>
                                    <span class="btn btn-secondary"
                                          style="padding: 0.4rem 0.6rem; font-size: 0.75rem; margin-top: 0.25rem; cursor: wait;">
                                        ‚è≥ Processing...
                                    </span>
                                </li>
                            `;
                        }
                    } else {
                        // Show locked state - need to purchase first
                        return `
                            <li class="file-item"
                                style="flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; margin-bottom: 0; text-align: center; opacity: 0.6; min-width: 0;">
                                ${iconHtml}
                                <div style="font-weight: 700; color: var(--accent); font-size: 0.95rem; word-break: break-all; overflow-wrap: anywhere; max-width: 100%; line-height: 1.3;" title="${item.displayName}">
                                    ${item.displayName}
                                </div>
                                <span class="btn btn-secondary" style="padding: 0.4rem 0.6rem; font-size: 0.75rem; margin-top: 0.25rem; cursor: not-allowed;">
                                    üîí Locked
                                </span>
                            </li>
                        `;
                    }
                }).join('');
                
                list.innerHTML = buyAllHtml + filesHtml;
            },
            
            renderTextureGallery(textures) {
                const section = document.getElementById('additional-content-section');
                const gallery = document.getElementById('texture-gallery');
                
                if (!textures || textures.length === 0) {
                    if (section) section.style.display = 'none';
                    if (gallery) gallery.innerHTML = '';
                    return;
                }
                
                // Show the section
                if (section) section.style.display = 'block';
                
                // Render texture tiles (preview only, no download buttons - download is in Downloads section)
                const html = textures.map(tex => {
                    // Extract texture type from filename (e.g., "model_Normal.jpg" -> "Normal")
                    const match = tex.filename.match(/_([A-Za-z]+)\.jpe?g$/i);
                    const textureType = match ? match[1] : 'Texture';
                    
                    // Use direct URL for display
                    const imgUrl = tex.url;
                    
                    return `
                        <div class="texture-tile" onclick="TaskUI.openImagePreview('${imgUrl}')">
                            <img src="${imgUrl}" alt="${textureType}" loading="lazy">
                            <div class="label">${textureType}</div>
                        </div>
                    `;
                }).join('');
                
                if (gallery) gallery.innerHTML = html;
            },

            setupButtons() {
                document.getElementById('restart-task-btn').addEventListener('click', async () => {
                    const btn = document.getElementById('restart-task-btn');
                    const statusBadge = document.getElementById('status-badge');
                    const statusText = document.getElementById('status-text');
                    const prevText = btn.textContent;
                    btn.disabled = true;
                    btn.textContent = t('btn_restart_task_working');
                    statusBadge.className = 'alert alert-info';
                    statusText.textContent = t('task_status_restarting');
                    try {
                        const resp = await fetch(`/api/task/${this.taskId}/restart`, { method: 'POST' });
                        const raw = await resp.text();
                        let data = {};
                        try { data = raw ? JSON.parse(raw) : {}; } catch (_) { data = {}; }
                        if (!resp.ok) {
                            alert(data.detail || raw || t('error_generic'));
                            return;
                        }

                        // Ensure polling is running again
                        if (!this.pollInterval) {
                            this.pollInterval = setInterval(() => this.fetchTask(), 2000);
                        }
                        await this.fetchTask();
                    } catch (e) {
                        console.error('Restart error:', e);
                        alert(t('error_generic'));
                    } finally {
                        btn.disabled = false;
                        btn.textContent = prevText;
                    }
                });

                // Owner tasks modal
                document.getElementById('owner-tasks-btn')?.addEventListener('click', () => this.openOwnerTasksModal());
                document.getElementById('owner-tasks-close')?.addEventListener('click', () => this.closeOwnerTasksModal());
                document.getElementById('owner-tasks-modal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'owner-tasks-modal') this.closeOwnerTasksModal();
                });
                document.getElementById('owner-tasks-prev')?.addEventListener('click', () => {
                    if (this.ownerTasksPage > 1) {
                        this.ownerTasksPage--;
                        this.loadOwnerTasks();
                    }
                });
                document.getElementById('owner-tasks-next')?.addEventListener('click', () => {
                    const totalPages = Math.ceil(this.ownerTasksTotal / this.ownerTasksPerPage);
                    if (this.ownerTasksPage < totalPages) {
                        this.ownerTasksPage++;
                        this.loadOwnerTasks();
                    }
                });

                // Progress log toggle
                document.getElementById('progress-log')?.addEventListener('click', () => {
                    this.progressLogExpanded = !this.progressLogExpanded;
                    this.renderProgressLog();
                    // When expanding, refetch full log immediately
                    this.refreshProgressLog();
                });

                // Progress log copy button
                document.getElementById('progress-log-copy')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const full = this.progressLogData?.full_text || 
                                 (this.progressLogData?.tail_lines || []).join('\n');
                    if (full) {
                        navigator.clipboard.writeText(full).then(() => {
                            const btn = e.target;
                            const original = btn.textContent;
                            btn.textContent = t('log_copied');
                            setTimeout(() => btn.textContent = t('log_copy'), 1500);
                        });
                    }
                });

                // HDRP image preview (click to open lightbox)
                const renders = document.getElementById('hdrp-renders');
                renders?.addEventListener('click', (e) => {
                    const t = e.target;
                    if (!(t instanceof HTMLImageElement)) return;
                    this.openImagePreview(t.src);
                });

                const imgModal = document.getElementById('image-preview-modal');
                document.getElementById('image-preview-close')?.addEventListener('click', () => this.closeImagePreview());
                imgModal?.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'image-preview-modal') this.closeImagePreview();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.closeImagePreview();
                });
            },

            openImagePreview(src) {
                const modal = document.getElementById('image-preview-modal');
                const img = document.getElementById('image-preview-img');
                if (!modal || !img) return;
                img.src = src;
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            },

            closeImagePreview() {
                const modal = document.getElementById('image-preview-modal');
                const img = document.getElementById('image-preview-img');
                if (img) img.src = '';
                if (!modal) return;
                modal.classList.add('hidden');
                modal.style.display = 'none';
            },

            openOwnerTasksModal() {
                this.ownerTasksPage = 1;
                const modal = document.getElementById('owner-tasks-modal');
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                this.loadOwnerTasks();
            },

            closeOwnerTasksModal() {
                const modal = document.getElementById('owner-tasks-modal');
                modal.classList.add('hidden');
                modal.style.display = 'none';
            },

            formatDate(dateStr) {
                if (!dateStr) return '-';
                const d = new Date(dateStr);
                return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            },

            async loadOwnerTasks() {
                const tbody = document.getElementById('owner-tasks-table');
                tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; color: var(--text-muted);">Loading...</td></tr>';
                try {
                    const params = new URLSearchParams({
                        page: this.ownerTasksPage,
                        per_page: this.ownerTasksPerPage
                    });
                    const resp = await fetch(`/api/task/${this.taskId}/owner_tasks?${params}`);
                    if (!resp.ok) throw new Error('Failed to load owner tasks');
                    const data = await resp.json();
                    this.ownerTasksTotal = data.total || 0;

                    const subtitle = document.getElementById('owner-tasks-subtitle');
                    if (subtitle) {
                        // owner_id can be email for user owners; don't show it publicly
                        subtitle.textContent = data.owner_type === 'user' ? 'Owner: user' : 'Owner: anon';
                    }

                    const placeholder = '/static/images/placeholder-thumb.svg';
                    const rows = (data.tasks || []).map(t => {
                        const statusColor = {
                            'created': 'var(--text-muted)',
                            'processing': 'var(--accent)',
                            'done': 'var(--success)',
                            'error': 'var(--error)'
                        }[t.status] || 'var(--text-muted)';

                        const thumb = t.thumbnail_url || placeholder;
                        return `
                            <tr>
                                <td style="width: 140px;">
                                    <img src="${thumb}" onerror="this.onerror=null;this.src='${placeholder}';"
                                         alt="thumb" style="width: 120px; height: 68px; object-fit: cover; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: #000;">
                                </td>
                                <td style="font-family: monospace; font-size: 0.875rem;">${t.task_id.substring(0,8)}...</td>
                                <td><span style="color: ${statusColor}; font-weight: 500; text-transform: capitalize;">${t.status}</span></td>
                                <td>${t.progress || 0}%</td>
                                <td style="font-size: 0.875rem;">${this.formatDate(t.created_at)}</td>
                                <td>
                                    <a href="/task?id=${t.task_id}" target="_blank" class="btn btn-secondary"
                                       style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">Open</a>
                                </td>
                            </tr>
                        `;
                    });

                    tbody.innerHTML = rows.length
                        ? rows.join('')
                        : '<tr><td colspan="6" style="text-align:center; color: var(--text-muted);">No tasks found</td></tr>';

                    const totalPages = Math.ceil((this.ownerTasksTotal || 0) / this.ownerTasksPerPage);
                    const start = (this.ownerTasksPage - 1) * this.ownerTasksPerPage + 1;
                    const end = Math.min(this.ownerTasksPage * this.ownerTasksPerPage, this.ownerTasksTotal || 0);
                    document.getElementById('owner-tasks-pagination-info').textContent =
                        `Showing ${this.ownerTasksTotal ? start : 0}-${this.ownerTasksTotal ? end : 0} of ${this.ownerTasksTotal} tasks`;
                    document.getElementById('owner-tasks-prev').disabled = this.ownerTasksPage <= 1;
                    document.getElementById('owner-tasks-next').disabled = this.ownerTasksPage >= (totalPages || 1);
                } catch (e) {
                    console.error('Owner tasks load error:', e);
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; color: var(--error);">Failed to load tasks</td></tr>';
                }
            },
            
            showError(message) {
                document.getElementById('error-container').classList.remove('hidden');
                document.getElementById('error-message').textContent = message;
                document.getElementById('progress-container').classList.add('hidden');
            },
            
            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            },

            progressLogInterval: null,
            startProgressLogPolling() {
                if (this.progressLogInterval) return;
                const tick = async () => {
                    try { await this.refreshProgressLog(); } catch (_) {}
                };
                tick();
                this.progressLogInterval = setInterval(tick, 10000);

                // Cleanup on unload
                window.addEventListener('beforeunload', () => {
                    try {
                        if (this.progressLogInterval) clearInterval(this.progressLogInterval);
                        this.progressLogInterval = null;
                    } catch (_) {}
                }, { once: true });
            },
            
            async loadQueueStatus() {
                const activeEl = document.getElementById('queue-active');
                const pendingEl = document.getElementById('queue-pending');
                const waitEl = document.getElementById('queue-wait');
                const serversEl = document.getElementById('queue-servers');
                
                if (!activeEl) return;
                
                try {
                    const response = await fetch('/api/queue/status');
                    const data = await response.json();
                    
                    activeEl.textContent = data.total_active;
                    pendingEl.textContent = data.total_pending;
                    const s = Number(data.estimated_wait_seconds || 0);
                    if (s < 60) {
                        waitEl.textContent = t('queue_wait_lt1min');
                    } else if (s < 3600) {
                        const minutes = Math.ceil(s / 60);
                        waitEl.textContent = t('queue_wait_minutes', { minutes: String(minutes) });
                    } else {
                        const hours = Math.floor(s / 3600);
                        const minutes = Math.floor((s % 3600) / 60);
                        waitEl.textContent = t('queue_wait_hours', { hours: String(hours), minutes: String(minutes) });
                    }
                    serversEl.textContent = `${data.available_workers}/${data.total_workers}`;
                    
                    // Color coding
                    if (data.total_pending > 5) {
                        pendingEl.classList.add('warning');
                    } else {
                        pendingEl.classList.remove('warning');
                    }
                    
                    if (data.estimated_wait_seconds < 60) {
                        waitEl.classList.add('success');
                    } else if (data.estimated_wait_seconds > 1800) {
                        waitEl.classList.add('warning');
                    }
                } catch (error) {
                    console.error('Queue status error:', error);
                }
            }
        };
        
        document.addEventListener('DOMContentLoaded', () => TaskPage.init());
    </script>

    <!-- Three.js Viewer (ES Modules) -->
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js",
            "three/examples/jsm/postprocessing/OutputPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutputPass.js"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { TransformControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/TransformControls.js';
        import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
        import { EXRLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/EXRLoader.js';
        
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

        import { RigEditor, ViewerControls, RigType, CameraMode, MaterialChannel } from '/static/js/rig-editor.js?v=45';

        // Make THREE available globally for rig-editor module
        window.THREE = THREE;

        const params = new URLSearchParams(window.location.search);
        const rawTaskId = params.get('id') || '';
        const taskId = rawTaskId.split('?')[0];  // Sanitize malformed URLs

        const wrap = document.getElementById('model-viewer-wrap');
        const host = document.getElementById('model-viewer');
        const statusEl = document.getElementById('model-viewer-status');
        let sel = document.getElementById('anim-select');
        let playBtn = document.getElementById('anim-play-btn');
        let pauseBtn = document.getElementById('anim-pause-btn');

        if (!taskId || !wrap || !host || !statusEl) {
            // nothing to do
        } else {
            // ============================================================
            // LIGHTING & RENDERER CONFIG (edit values here)
            // ============================================================
            const LIGHTING_CONFIG = {
                // HDR Environment (IBL reflections)
                hdrPath: '/static/ibl/DefaultHDRISky.exr',
                envIntensity: 1.0,          // scene.environmentIntensity (Three.js r152+)

                // Tone mapping
                toneMapping: THREE.ACESFilmicToneMapping,
                toneMappingExposure: 1.0,   // overall brightness

                // Directional "sun" light
                sunColor: 0xffffff,
                sunIntensity: 0.8,
                sunPosition: [3, 5, 2],     // x, y, z

                // Ambient fill
                ambientColor: 0xffffff,
                ambientIntensity: 0.3,

                // Hemisphere light (sky/ground)
                hemiSkyColor: 0xffffff,
                hemiGroundColor: 0x222233,
                hemiIntensity: 0.25,

                // Background
                bgColor: 0x1a1a2e,           // scene background color
            };
            // ============================================================

            let mixer = null;
            let animations = [];
            let currentAction = null;
            const clock = new THREE.Clock();

            function setStatus(s) { statusEl.textContent = s; }

            function play(name) {
                if (!mixer || !animations.length) return;
                const clip = animations.find(c => c.name === name) || animations[0];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.reset().fadeIn(0.2).play();
                if (currentAction && currentAction !== next) currentAction.fadeOut(0.2);
                currentAction = next;
                mixer.timeScale = 1;
            }

            async function loadEnvironment(scene) {
                const url = LIGHTING_CONFIG.hdrPath;
                setStatus('Loading IBL...');

                // Use EXRLoader for .exr (RGBELoader is still imported/available as required stack).
                const tryEXR = () => new Promise((resolve) => {
                    const exr = new EXRLoader();
                    exr.load(url, (t) => {
                        t.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = t;
                        // Set envIntensity if supported (Three.js r152+)
                        if ('environmentIntensity' in scene) {
                            scene.environmentIntensity = LIGHTING_CONFIG.envIntensity;
                        }
                        console.log('[Viewer] EXR environment loaded');
                        resolve(true);
                    }, undefined, (err) => {
                        console.warn('[Viewer] EXR load failed:', err);
                        resolve(false);
                    });
                });

                const tryRGBE = () => new Promise((resolve) => {
                    const rgbe = new RGBELoader();
                    rgbe.load(url.replace('.exr', '.hdr'), (t) => {
                        t.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = t;
                        if ('environmentIntensity' in scene) {
                            scene.environmentIntensity = LIGHTING_CONFIG.envIntensity;
                        }
                        console.log('[Viewer] HDR environment loaded');
                        resolve(true);
                    }, undefined, () => resolve(false));
                });

                const okExr = await tryEXR();
                if (okExr) return true;
                const okHdr = await tryRGBE();
                return okHdr;
            }

            // Scene state (persistent across model loads)
            let sceneInited = false;
            let scene, renderer, camera, controls, transform;
            let currentModel = null;
            let preparedLoaded = false;
            let finalLoaded = false;

            // Rig Editor and Viewer Controls instances
            let rigEditor = null;
            let viewerControls = null;
            
            // Light references for slider updates
            let sunLight = null;
            let ambientLight = null;
            let hemiLight = null;
            let composer = null;
            let bloomPass = null;

            // Fullscreen state
            let isFullscreen = false;
            let normalCanvasSize = { width: 0, height: 0 };
            let fullscreenCanvasSize = { width: 0, height: 0 };
            
            // Viewer state (can be updated via sliders/selectors)
            let viewerState = {
                mainLightIntensity: 3.0,
                envIntensity: 1.0,
                reflectionIntensity: 3.0,
                modelRotation: 'z180',
                bgColor: '#000000',
                groundColor: '#222222',
                groundSize: 100.0,
                shadowIntensity: 0.5,
                shadowRadius: 1.0,
                sunRotation: 45.0,
                sunInclination: 45.0,
                timeOfDay: 12.0,
                ambientColor: '#ffffff',
                ambientIntensity: 0.3,
                fogColor: '#000000',
                fogDensity: 0.0,
                lightingPreset: 'day',
                camera: { 
                    position: { x: 0, y: 1.6, z: 3.5 },
                    target: { x: 0, y: 1.0, z: 0 }
                },
                syncAdjChannel: false,
                bloom: { strength: 0.0, threshold: 0.8, radius: 0.4 },
                adjustments: {
                    albedo: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    ao: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    normal: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    roughness: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    metalness: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    emissive: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false }
                },
                aoSettings: {
                    samples: 32,
                    radius: 0.15,
                    intensity: 1.5
                }
            };
            window.viewerState = viewerState; // Make global for debugging

            let currentAdjChannel = 'albedo';

            // Mapping for sync mode (eye button)
            const ADJ_CHANNEL_TO_VIEWER = {
                'albedo': 4,    // MaterialChannel.ALBEDO
                'ao': 2,        // MaterialChannel.AO
                'normal': 3,    // MaterialChannel.NORMAL
                'roughness': 6, // MaterialChannel.ROUGHNESS
                'metalness': 5, // MaterialChannel.METALNESS
                'emissive': 7   // MaterialChannel.EMISSIVE
            };

            // Translation helper (use window.t from i18n.js)
            const t = (key) => window.t ? window.t(key) : key;

            // Admin detection (cached)
            let viewerIsAdmin = false;
            let _viewerAdminPromise = null;
            async function ensureViewerAdmin() {
                if (_viewerAdminPromise) return _viewerAdminPromise;
                _viewerAdminPromise = (async () => {
                    try {
                        const authResp = await fetch('/auth/me');
                        if (authResp.ok) {
                            const authData = await authResp.json();
                            viewerIsAdmin = !!authData?.user?.is_admin;
                        }
                    } catch (e) {
                        // ignore
                    }
                    return viewerIsAdmin;
                })();
                return _viewerAdminPromise;
            }

            async function saveDefaultViewerSettings(source = 'unknown') {
                const isAdmin = await ensureViewerAdmin();
                console.log('[Viewer] Save default settings requested:', { source, isAdmin });
                if (!isAdmin) {
                    alert('Admin only');
                    return;
                }
                try {
                    const resp = await fetch('/api/admin/viewer-default-settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(viewerState)
                    });
                    if (!resp.ok) {
                        const data = await resp.json().catch(() => ({}));
                        console.warn('[Viewer] Failed to save default settings:', data);
                        alert(data.detail || 'Failed to save defaults');
                        return;
                    }
                    console.log('[Viewer] Default viewer settings saved');
                    alert('Default viewer settings saved');
                } catch (e) {
                    console.error('[Viewer] Failed to save default settings:', e);
                    alert('Failed to save defaults');
                }
            }
            
            // Load viewer settings from server
            async function loadViewerSettings() {
                try {
                    const resp = await fetch(`/api/task/${taskId}/viewer-settings`);
                    if (resp.ok) {
                        const settings = await resp.json();
                        viewerState.mainLightIntensity = settings.mainLightIntensity !== undefined ? settings.mainLightIntensity : 3.0;
                        viewerState.envIntensity = settings.envIntensity !== undefined ? settings.envIntensity : 1.0;
                        viewerState.reflectionIntensity = settings.reflectionIntensity !== undefined ? settings.reflectionIntensity : 3.0;
                        viewerState.modelRotation = settings.modelRotation || 'z180';
                        viewerState.bgColor = settings.bgColor || '#000000';
                        viewerState.groundColor = settings.groundColor || '#222222';
                        viewerState.groundSize = settings.groundSize !== undefined ? settings.groundSize : 100.0;
                        viewerState.shadowIntensity = settings.shadowIntensity !== undefined ? settings.shadowIntensity : 0.5;
                        viewerState.shadowRadius = settings.shadowRadius !== undefined ? settings.shadowRadius : 1.0;
                        viewerState.sunRotation = settings.sunRotation !== undefined ? settings.sunRotation : 45.0;
                        viewerState.sunInclination = settings.sunInclination !== undefined ? settings.sunInclination : 45.0;
                        viewerState.timeOfDay = settings.timeOfDay !== undefined ? settings.timeOfDay : 12.0;
                        viewerState.ambientColor = settings.ambientColor || '#ffffff';
                        viewerState.ambientIntensity = settings.ambientIntensity !== undefined ? settings.ambientIntensity : 0.3;
                        viewerState.fogColor = settings.fogColor || '#000000';
                        viewerState.fogDensity = settings.fogDensity !== undefined ? settings.fogDensity : 0.0;
                        viewerState.lightingPreset = settings.lightingPreset || 'day';
                        viewerState.syncAdjChannel = settings.syncAdjChannel || false;
                        if (settings.bloom) {
                            viewerState.bloom = { ...viewerState.bloom, ...settings.bloom };
                        }
                        // Save camera position separately - will be applied after model loads
                        if (settings.camera && settings.camera.position && settings.camera.target) {
                            savedCameraPosition = { ...settings.camera.position };
                            savedCameraTarget = { ...settings.camera.target };
                            console.log('[Viewer] Saved camera position for later:', savedCameraPosition);
                        }
                        
                        if (settings.adjustments) {
                            // Merge saved adjustments with defaults
                            for (const chan in settings.adjustments) {
                                if (viewerState.adjustments[chan]) {
                                    viewerState.adjustments[chan] = {
                                        ...viewerState.adjustments[chan],
                                        ...settings.adjustments[chan]
                                    };
                                }
                            }
                        }
                        
                        // Load AO bake settings
                        if (settings.aoSettings) {
                            viewerState.aoSettings = {
                                ...viewerState.aoSettings,
                                ...settings.aoSettings
                            };
                        }
                        
                        applyViewerState(); // Apply everything EXCEPT camera
                        updateViewerUI();
                        lastSyncedState = JSON.stringify(viewerState);
                        console.log('[Viewer] Loaded settings (camera will be applied after model loads)');
                    } else {
                        console.log('[Viewer] No settings on server, using defaults');
                    }
                } catch (e) {
                    console.warn('[Viewer] Failed to load settings:', e);
                }
                // Start sync loop after first load (or fail)
                startPeriodicSync();
            }
            
            // Periodic sync logic
            let lastSyncedState = JSON.stringify(viewerState);
            let isDefaultComparisonOn = false;
            let stateBeforeDefault = null;
            let cameraInitialized = false; // Flag to prevent camera sync until loaded from server
            let savedCameraPosition = null; // Store camera position from server until model loads
            let savedCameraTarget = null;
            
            // Restore camera from saved position (called ONCE after model loads)
            function restoreSavedCamera() {
                if (savedCameraPosition && savedCameraTarget && camera && controls) {
                    console.log('[Viewer] Restoring saved camera position:', savedCameraPosition);
                    camera.position.set(savedCameraPosition.x, savedCameraPosition.y, savedCameraPosition.z);
                    controls.target.set(savedCameraTarget.x, savedCameraTarget.y, savedCameraTarget.z);
                    controls.update();
                    
                    // Update viewerState with restored values
                    viewerState.camera.position = { ...savedCameraPosition };
                    viewerState.camera.target = { ...savedCameraTarget };
                    
                    // Tell ViewerControls to skip next focus (will be called by setRigType)
                    if (viewerControls) {
                        viewerControls.skipNextFocusOnModel();
                    }
                    
                    console.log('[Viewer] Camera restored successfully');
                } else {
                    console.log('[Viewer] No saved camera position, using current/default');
                }
                // Now allow camera sync in render loop
                cameraInitialized = true;
            }
            
            // Hide loading overlay with fade effect
            function hideLoadingOverlay() {
                const overlay = document.getElementById('viewer-loading-overlay');
                if (overlay && !overlay.classList.contains('hidden')) {
                    console.log('[Viewer] Hiding loading overlay');
                    overlay.classList.add('hidden');
                    // Remove from DOM after animation completes
                    setTimeout(() => {
                        overlay.classList.add('removed');
                    }, 500);
                }
            }

            function startPeriodicSync() {
                setInterval(async () => {
                    if (isDefaultComparisonOn) return; // Don't sync defaults
                    const currentState = JSON.stringify(viewerState);
                    if (currentState !== lastSyncedState) {
                        try {
                            const resp = await fetch(`/api/task/${taskId}/viewer-settings`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: currentState
                            });
                            if (resp.ok) {
                                lastSyncedState = currentState;
                                console.log('[Viewer] Settings synced (camera:', 
                                    viewerState.camera?.position ? 
                                    `pos=${viewerState.camera.position.x.toFixed(2)},${viewerState.camera.position.y.toFixed(2)},${viewerState.camera.position.z.toFixed(2)}` : 
                                    'none', ')');
                            }
                        } catch (e) {
                            console.warn('[Viewer] Periodic sync failed:', e);
                        }
                    }
                }, 5000);
            }
            
            // Apply viewer state to scene/model
            function applyViewerState() {
                if (!sceneInited) return;
                
                // 1. Lighting
                let mainFactor = viewerState.mainLightIntensity;
                
                // Day/Night Cycle Logic
                const hour = viewerState.timeOfDay;
                // If between 19:00 (7 PM) and 06:00 (6 AM), fade sun to zero
                if (hour >= 19.0 || hour < 6.0) {
                    // Quick fade (emulated as 0 if in range)
                    mainFactor = 0.0;
                }

                if (sunLight) {
                    sunLight.intensity = LIGHTING_CONFIG.sunIntensity * mainFactor;
                    
                    // Calculate sun position from angles
                    const phi = (90 - viewerState.sunInclination) * (Math.PI / 180);
                    const theta = (viewerState.sunRotation) * (Math.PI / 180);
                    
                    const r = 10;
                    sunLight.position.set(
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi),
                        r * Math.sin(phi) * Math.cos(theta)
                    );
                }

                if (ambientLight) {
                    ambientLight.color.set(viewerState.ambientColor);
                    ambientLight.intensity = viewerState.ambientIntensity;
                }
                
                if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * (mainFactor > 0 ? mainFactor : 0.2);
                
                // Environment intensity (Scene-level)
                const envVal = LIGHTING_CONFIG.envIntensity * viewerState.envIntensity;
                if (scene && 'environmentIntensity' in scene) {
                    scene.environmentIntensity = envVal;
                }
                
                // Background color
                if (scene) {
                    scene.background = new THREE.Color(viewerState.bgColor);
                    const preview = document.getElementById('bg-color-preview');
                    if (preview) preview.style.backgroundColor = viewerState.bgColor;
                    const picker = document.getElementById('bg-color-picker');
                    if (picker) picker.value = viewerState.bgColor;
                }

                // Fog
                if (scene) {
                    if (viewerState.fogDensity > 0) {
                        scene.fog = new THREE.FogExp2(viewerState.fogColor, viewerState.fogDensity);
                    } else {
                        scene.fog = null;
                    }
                }

                // 1.5 Bloom
                if (viewerControls) {
                    // Clamp strength to 1.0 max as requested
                    if (viewerState.bloom.strength > 1.0) {
                        viewerState.bloom.strength = 1.0;
                    }
                    viewerControls.setBloomSettings(viewerState.bloom);
                }

                // 1.6 Ground Plane
                if (viewerControls) {
                    viewerControls.setGroundParams({
                        color: viewerState.groundColor,
                        size: viewerState.groundSize
                    });
                }

                // 1.7 Shadows
                if (sunLight && sunLight.shadow) {
                    sunLight.shadow.intensity = viewerState.shadowIntensity; // Wait, shadow doesn't have intensity property in standard Three.js
                    // For shadow intensity, we usually adjust the shadow darknees via bias or just the light intensity.
                    // But in Three.js, you usually use a separate "shadow only" light or post-processing.
                    // Actually, the easiest way to control shadow "strength" is via shadow.radius (blur) and shadow.bias.
                    // Another way: use THREE.ShadowMaterial on a ground, but we have a PBR ground.
                    // Let's use shadow.radius for softness.
                    sunLight.shadow.radius = viewerState.shadowRadius;
                }
                
                // 2. Post-processing & Model Props
                if (currentModel) {
                    // Update shadow properties for all meshes
                    currentModel.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                }
                if (viewerControls) {
                    viewerControls.setModelRotation(viewerState.modelRotation);
                    // Pass all adjustments to ViewerControls
                    for (const chan in viewerState.adjustments) {
                        viewerControls.setChannelAdjustments(chan, viewerState.adjustments[chan]);
                    }

                    // Apply sync channel if active
                    if (viewerState.syncAdjChannel) {
                        const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                        if (materialChan) {
                            viewerControls.setMaterialChannel(materialChan);
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = materialChan;
                        }
                    }
                }

                if (currentModel) {
                    // Reflection intensity (env map)
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.material && child.material.envMapIntensity !== undefined) {
                            child.material.envMapIntensity = viewerState.reflectionIntensity;
                        }
                    });
                }

                // NOTE: Camera is NOT restored here - it's applied once after model loads
                // See restoreSavedCamera() function
                
                // Sync UI elements to match state
                updateViewerUI();
            }
            
            // Update UI from state
            function updateViewerUI() {
                const mainSlider = document.getElementById('light-main-slider');
                const envSlider = document.getElementById('light-env-slider');
                const reflectSlider = document.getElementById('light-reflect-slider');
                const mainVal = document.getElementById('light-main-val');
                const envVal = document.getElementById('light-env-val');
                const reflectVal = document.getElementById('light-reflect-val');
                const rotSelect = document.getElementById('viewer-rotation-select');
                const picker = document.getElementById('bg-color-picker');
                const adjChanSelect = document.getElementById('adj-target-channel');
                
                // Adjustments
                const adjBrightSlider = document.getElementById('adj-bright-slider');
                const adjContrastSlider = document.getElementById('adj-contrast-slider');
                const adjSaturSlider = document.getElementById('adj-satur-slider');
                const adjBrightVal = document.getElementById('adj-bright-val');
                const adjContrastVal = document.getElementById('adj-contrast-val');
                const adjSaturVal = document.getElementById('adj-satur-val');
                
                const adjModeSelect = document.getElementById('adj-mode-select');
                const adjMaskGroup = document.getElementById('adj-mask-group');
                const adjMaskColor = document.getElementById('adj-mask-color');
                const adjSoftSlider = document.getElementById('adj-soft-slider');
                const adjEmMultSlider = document.getElementById('adj-em-mult-slider');
                const adjInvertMask = document.getElementById('adj-invert-mask');
                const adjBlendColor = document.getElementById('adj-blend-color');
                const adjSoftVal = document.getElementById('adj-soft-val');
                const adjEmMultVal = document.getElementById('adj-em-mult-val');
                
                if (mainSlider) mainSlider.value = viewerState.mainLightIntensity;
                if (envSlider) envSlider.value = viewerState.envIntensity;
                if (reflectSlider) reflectSlider.value = viewerState.reflectionIntensity;
                if (rotSelect) rotSelect.value = viewerState.modelRotation;
                if (picker) picker.value = viewerState.bgColor;
                if (adjChanSelect) adjChanSelect.value = currentAdjChannel;

                const adjSyncBtn = document.getElementById('adj-sync-view-btn');

                const bloomStrSlider = document.getElementById('bloom-strength-slider');
                const bloomThrSlider = document.getElementById('bloom-threshold-slider');
                const bloomRadSlider = document.getElementById('bloom-radius-slider');
                const bloomStrVal = document.getElementById('bloom-strength-val');
                const bloomThrVal = document.getElementById('bloom-threshold-val');
                const bloomRadVal = document.getElementById('bloom-radius-val');

                if (bloomStrSlider) bloomStrSlider.value = viewerState.bloom.strength;
                if (bloomThrSlider) bloomThrSlider.value = viewerState.bloom.threshold;
                if (bloomRadSlider) bloomRadSlider.value = viewerState.bloom.radius;
                if (bloomStrVal) bloomStrVal.textContent = Number(viewerState.bloom.strength).toFixed(3);
                if (bloomThrVal) bloomThrVal.textContent = Number(viewerState.bloom.threshold).toFixed(3);
                if (bloomRadVal) bloomRadVal.textContent = Number(viewerState.bloom.radius).toFixed(3);

                if (adjSyncBtn) {
                    if (viewerState.syncAdjChannel) {
                        adjSyncBtn.style.background = 'var(--accent)';
                        adjSyncBtn.style.borderColor = 'var(--accent)';
                        adjSyncBtn.style.color = '#fff';
                        adjSyncBtn.style.opacity = '1';
                    } else {
                        adjSyncBtn.style.background = 'rgba(255,255,255,0.1)';
                        adjSyncBtn.style.borderColor = 'rgba(255,255,255,0.2)';
                        adjSyncBtn.style.color = '#fff';
                        adjSyncBtn.style.opacity = '0.5';
                    }
                }
                
                if (mainVal) mainVal.textContent = Number(viewerState.mainLightIntensity).toFixed(3);
                if (envVal) envVal.textContent = Number(viewerState.envIntensity).toFixed(3);
                if (reflectVal) reflectVal.textContent = Number(viewerState.reflectionIntensity).toFixed(3);

                // Update ground controls
                const groundPicker = document.getElementById('ground-color-picker');
                const groundSizeSlider = document.getElementById('ground-size-slider');
                const groundSizeVal = document.getElementById('ground-size-val');
                const shadowRadiusSlider = document.getElementById('shadow-radius-slider');
                const shadowRadiusVal = document.getElementById('shadow-radius-val');

                if (groundPicker) groundPicker.value = viewerState.groundColor;
                if (groundSizeSlider) groundSizeSlider.value = viewerState.groundSize;
                if (groundSizeVal) groundSizeVal.textContent = Number(viewerState.groundSize).toFixed(3);
                
                if (shadowRadiusSlider) shadowRadiusSlider.value = viewerState.shadowRadius;
                if (shadowRadiusVal) shadowRadiusVal.textContent = Number(viewerState.shadowRadius).toFixed(3);

                // Update Day/Night UI
                const timeSlider = document.getElementById('lighting-time-slider');
                const presetSelect = document.getElementById('lighting-preset-select');
                const sunRotSlider = document.getElementById('sun-rotation-slider');
                const sunIncSlider = document.getElementById('sun-inclination-slider');
                const ambPicker = document.getElementById('ambient-color-picker');
                const ambSlider = document.getElementById('ambient-intensity-slider');

                if (timeSlider) timeSlider.value = viewerState.timeOfDay;
                if (presetSelect) presetSelect.value = viewerState.lightingPreset;
                if (sunRotSlider) sunRotSlider.value = viewerState.sunRotation;
                if (sunIncSlider) sunIncSlider.value = viewerState.sunInclination;
                if (ambPicker) ambPicker.value = viewerState.ambientColor;
                if (ambSlider) ambSlider.value = viewerState.ambientIntensity;

                // Update Fog UI
                const fogPicker = document.getElementById('fog-color-picker');
                const fogDensitySlider = document.getElementById('fog-density-slider');
                const fogDensityVal = document.getElementById('fog-density-val');

                if (fogPicker) fogPicker.value = viewerState.fogColor;
                if (fogDensitySlider) fogDensitySlider.value = viewerState.fogDensity;
                if (fogDensityVal) fogDensityVal.textContent = Number(viewerState.fogDensity).toFixed(2);
                
                // Update AO Bake UI
                const aoSamplesSlider = document.getElementById('ao-samples-slider');
                const aoRadiusSlider = document.getElementById('ao-radius-slider');
                const aoIntensitySlider = document.getElementById('ao-intensity-slider');
                const aoSamplesVal = document.getElementById('ao-samples-val');
                const aoRadiusVal = document.getElementById('ao-radius-val');
                const aoIntensityVal = document.getElementById('ao-intensity-val');
                
                if (aoSamplesSlider) aoSamplesSlider.value = viewerState.aoSettings.samples;
                if (aoRadiusSlider) aoRadiusSlider.value = viewerState.aoSettings.radius;
                if (aoIntensitySlider) aoIntensitySlider.value = viewerState.aoSettings.intensity;
                if (aoSamplesVal) aoSamplesVal.textContent = viewerState.aoSettings.samples;
                if (aoRadiusVal) aoRadiusVal.textContent = Number(viewerState.aoSettings.radius).toFixed(2);
                if (aoIntensityVal) aoIntensityVal.textContent = Number(viewerState.aoSettings.intensity).toFixed(1);

                const currentAdj = viewerState.adjustments[currentAdjChannel];
                if (adjBrightSlider) adjBrightSlider.value = currentAdj.brightness;
                if (adjContrastSlider) adjContrastSlider.value = currentAdj.contrast;
                if (adjSaturSlider) adjSaturSlider.value = currentAdj.saturation;
                
                if (adjBrightVal) adjBrightVal.textContent = Number(currentAdj.brightness).toFixed(3);
                if (adjContrastVal) adjContrastVal.textContent = Number(currentAdj.contrast).toFixed(3);
                if (adjSaturVal) adjSaturVal.textContent = Number(currentAdj.saturation).toFixed(3);

                // Update new adjustment controls
                if (adjModeSelect) adjModeSelect.value = currentAdj.mode || 0;
                if (adjMaskGroup) {
                    if (parseInt(currentAdj.mode) === 1) {
                        adjMaskGroup.classList.remove('hidden');
                    } else {
                        adjMaskGroup.classList.add('hidden');
                    }
                }
                if (adjMaskColor) adjMaskColor.value = currentAdj.maskColor || '#ffffff';
                if (adjSoftSlider) adjSoftSlider.value = currentAdj.softness || 0.5;
                if (adjEmMultSlider) adjEmMultSlider.value = currentAdj.emissiveMult || 2.0;
                if (adjInvertMask) adjInvertMask.checked = currentAdj.invert || false;
                if (adjBlendColor) adjBlendColor.value = currentAdj.blendColor || '#ffffff';
                if (adjSoftVal) adjSoftVal.textContent = Number(currentAdj.softness || 0.5).toFixed(3);
                if (adjEmMultVal) adjEmMultVal.textContent = Number(currentAdj.emissiveMult || 2.0).toFixed(3);
            }

            // Fullscreen functionality
            function toggleFullscreen() {
                console.log('[Viewer] toggleFullscreen called, current state:', isFullscreen);

                if (!isFullscreen) {
                    enterFullscreen();
                } else {
                    exitFullscreen();
                }
            }

            function enterFullscreen() {
                console.log('[Viewer] enterFullscreen called');
                if (!renderer) {
                    console.error('[Viewer] Renderer not available');
                    return;
                }

                // Save current canvas size
                normalCanvasSize.width = host.clientWidth;
                normalCanvasSize.height = host.clientHeight;
                console.log('[Viewer] Saved normal size:', normalCanvasSize);

                // Calculate fullscreen size with higher resolution
                const devicePixelRatio = window.devicePixelRatio || 1;
                fullscreenCanvasSize.width = window.innerWidth * devicePixelRatio * 1.5; // 1.5x supersampling
                fullscreenCanvasSize.height = window.innerHeight * devicePixelRatio * 1.5;
                console.log('[Viewer] Calculated fullscreen size:', fullscreenCanvasSize);

                // Set renderer size
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(devicePixelRatio * 1.5);
                console.log('[Viewer] Set renderer size:', window.innerWidth, window.innerHeight, 'pixelRatio:', devicePixelRatio * 1.5);

                // Update camera aspect ratio
                if (camera) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    console.log('[Viewer] Updated camera aspect ratio');
                }

                // Enter fullscreen
                let fullscreenPromise;
                const targetElement = document.documentElement;
                if (targetElement.requestFullscreen) {
                    fullscreenPromise = targetElement.requestFullscreen();
                    console.log('[Viewer] Called documentElement.requestFullscreen()');
                } else if (targetElement.webkitRequestFullscreen) {
                    fullscreenPromise = targetElement.webkitRequestFullscreen();
                    console.log('[Viewer] Called documentElement.webkitRequestFullscreen()');
                } else if (targetElement.msRequestFullscreen) {
                    fullscreenPromise = targetElement.msRequestFullscreen();
                    console.log('[Viewer] Called documentElement.msRequestFullscreen()');
                } else {
                    console.error('[Viewer] No fullscreen API available');
                    return;
                }

                // Handle fullscreen promise if available
                if (fullscreenPromise) {
                    fullscreenPromise.then(() => {
                        console.log('[Viewer] Fullscreen request successful');
                        isFullscreen = true;
                        updateFullscreenButton();
                        // Add ESC key handler
                        document.addEventListener('keydown', handleFullscreenKeydown);
                    }).catch((error) => {
                        console.error('[Viewer] Fullscreen request failed:', error);
                    });
                } else {
                    // Fallback for browsers that don't return a promise
                    setTimeout(() => {
                        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                            console.log('[Viewer] Fullscreen entered (fallback check)');
                            isFullscreen = true;
                            updateFullscreenButton();
                            document.addEventListener('keydown', handleFullscreenKeydown);
                        } else {
                            console.error('[Viewer] Fullscreen request failed (fallback check)');
                        }
                    }, 100);
                }
            }

            function exitFullscreen() {
                console.log('[Viewer] exitFullscreen called');
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    console.log('[Viewer] Called document.exitFullscreen()');
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                    console.log('[Viewer] Called document.webkitExitFullscreen()');
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                    console.log('[Viewer] Called document.msExitFullscreen()');
                } else {
                    console.log('[Viewer] No exit fullscreen API available');
                }
            }

            function handleFullscreenExit() {
                console.log('[Viewer] handleFullscreenExit called, current isFullscreen:', isFullscreen);
                if (!isFullscreen) return;

                // Restore normal size
                renderer.setSize(normalCanvasSize.width, normalCanvasSize.height);
                renderer.setPixelRatio(window.devicePixelRatio || 1);

                // Update camera aspect ratio
                if (camera) {
                    camera.aspect = normalCanvasSize.width / normalCanvasSize.height;
                    camera.updateProjectionMatrix();
                }

                isFullscreen = false;
                updateFullscreenButton();

                // Remove ESC key handler
                document.removeEventListener('keydown', handleFullscreenKeydown);

                console.log('[Viewer] Exited fullscreen mode');
            }

            function handleFullscreenKeydown(e) {
                if (e.key === 'Escape' && isFullscreen) {
                    exitFullscreen();
                }
                if (e.key === ' ' && !e.repeat) {
                    e.preventDefault();
                    toggleFullscreen();
                }
            }

            function updateFullscreenButton() {
                const btn = document.getElementById('viewer-fullscreen-btn');
                if (!btn) return;

                const icon = btn.querySelector('span:first-child');
                const text = btn.querySelector('span:last-child');

                if (isFullscreen) {
                    if (icon) icon.textContent = '‚õ∂';
                    if (text) text.textContent = 'Exit FS';
                    btn.title = 'Exit Fullscreen (ESC)';
                } else {
                    if (icon) icon.textContent = '‚õ∂';
                    if (text) text.textContent = 'Fullscreen';
                    btn.title = 'Fullscreen (Space)';
                }
            }

            // Listen for fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenExit);
            document.addEventListener('webkitfullscreenchange', handleFullscreenExit);
            document.addEventListener('msfullscreenchange', handleFullscreenExit);

            // Setup viewer control event listeners
            function setupViewerControls() {
                // EyeDropper implementation
                async function activateEyeDropper(targetId) {
                    if (!window.EyeDropper) {
                        console.warn('EyeDropper API not supported');
                        return;
                    }
                    const eyeDropper = new EyeDropper();
                    try {
                        const result = await eyeDropper.open();
                        const color = result.sRGBHex;
                        const input = document.getElementById(targetId);
                        if (input) {
                            input.value = color;
                            // Trigger input event manually
                            input.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    } catch (e) {
                        console.log('EyeDropper cancelled or failed:', e);
                    }
                }

                document.querySelectorAll('.eye-dropper-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        activateEyeDropper(btn.dataset.target);
                    });
                });

                const mainSlider = document.getElementById('light-main-slider');
                const envSlider = document.getElementById('light-env-slider');
                const reflectSlider = document.getElementById('light-reflect-slider');
                const rotSelect = document.getElementById('viewer-rotation-select');
                const picker = document.getElementById('bg-color-picker');
                const adjChanSelect = document.getElementById('adj-target-channel');
                
                // Adjustments
                const adjBrightSlider = document.getElementById('adj-bright-slider');
                const adjContrastSlider = document.getElementById('adj-contrast-slider');
                const adjSaturSlider = document.getElementById('adj-satur-slider');
                
                mainSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.mainLightIntensity = val;
                    if (sunLight) sunLight.intensity = LIGHTING_CONFIG.sunIntensity * val;
                    if (ambientLight) ambientLight.intensity = LIGHTING_CONFIG.ambientIntensity * val;
                    if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * val;
                    document.getElementById('light-main-val').textContent = val.toFixed(3);
                });
                
                envSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.envIntensity = val;
                    if (scene && 'environmentIntensity' in scene) {
                        scene.environmentIntensity = LIGHTING_CONFIG.envIntensity * val;
                    }
                    document.getElementById('light-env-val').textContent = val.toFixed(3);
                });
                
                reflectSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.reflectionIntensity = val;
                    if (currentModel) {
                        currentModel.traverse(child => {
                            if (child.isMesh && child.material && child.material.envMapIntensity !== undefined) {
                                child.material.envMapIntensity = val;
                            }
                        });
                    }
                    document.getElementById('light-reflect-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-strength-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.strength = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-strength-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-threshold-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.threshold = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-threshold-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.radius = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-radius-val').textContent = val.toFixed(3);
                });

                rotSelect?.addEventListener('change', (e) => {
                    viewerState.modelRotation = e.target.value;
                    applyViewerState();
                });

                picker?.addEventListener('input', (e) => {
                    viewerState.bgColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('ground-color-picker')?.addEventListener('input', (e) => {
                    viewerState.groundColor = e.target.value;
                    if (viewerControls) viewerControls.setGroundParams({ color: e.target.value });
                });

                document.getElementById('ground-size-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.groundSize = val;
                    if (viewerControls) viewerControls.setGroundParams({ size: val });
                    document.getElementById('ground-size-val').textContent = val.toFixed(3);
                });

                document.getElementById('shadow-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.shadowRadius = val;
                    if (sunLight && sunLight.shadow) {
                        sunLight.shadow.radius = val;
                    }
                    document.getElementById('shadow-radius-val').textContent = val.toFixed(3);
                });

                document.getElementById('lighting-time-slider')?.addEventListener('input', (e) => {
                    viewerState.timeOfDay = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('lighting-preset-select')?.addEventListener('change', (e) => {
                    const p = e.target.value;
                    viewerState.lightingPreset = p;
                    if (p === 'day') { viewerState.timeOfDay = 12.0; viewerState.sunRotation = 45; viewerState.sunInclination = 45; }
                    else if (p === 'night') { viewerState.timeOfDay = 0.0; viewerState.sunRotation = 180; viewerState.sunInclination = 10; }
                    else if (p === 'sunset') { viewerState.timeOfDay = 18.5; viewerState.sunRotation = 260; viewerState.sunInclination = 5; }
                    applyViewerState();
                    updateViewerUI();
                });

                document.getElementById('sun-rotation-slider')?.addEventListener('input', (e) => {
                    viewerState.sunRotation = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('sun-inclination-slider')?.addEventListener('input', (e) => {
                    viewerState.sunInclination = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('ambient-color-picker')?.addEventListener('input', (e) => {
                    viewerState.ambientColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('ambient-intensity-slider')?.addEventListener('input', (e) => {
                    viewerState.ambientIntensity = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('fog-color-picker')?.addEventListener('input', (e) => {
                    viewerState.fogColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('fog-density-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.fogDensity = val;
                    document.getElementById('fog-density-val').textContent = val.toFixed(2);
                    applyViewerState();
                });
                
                // AO Bake Settings listeners
                let aoRebakeTimeout = null;
                
                function scheduleAORebake() {
                    // Debounce rebake - wait 300ms after last change
                    if (aoRebakeTimeout) clearTimeout(aoRebakeTimeout);
                    aoRebakeTimeout = setTimeout(() => {
                        if (viewerControls) {
                            console.log('[Viewer] Auto-rebaking AO with settings:', viewerState.aoSettings);
                            viewerControls.setAOSettings(viewerState.aoSettings);
                            viewerControls.rebakeAO();
                        }
                    }, 300);
                }
                
                document.getElementById('ao-samples-slider')?.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    viewerState.aoSettings.samples = val;
                    document.getElementById('ao-samples-val').textContent = val;
                });
                document.getElementById('ao-samples-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.aoSettings.radius = val;
                    document.getElementById('ao-radius-val').textContent = val.toFixed(2);
                });
                document.getElementById('ao-radius-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-intensity-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.aoSettings.intensity = val;
                    document.getElementById('ao-intensity-val').textContent = val.toFixed(1);
                });
                document.getElementById('ao-intensity-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-rebake-btn')?.addEventListener('click', () => {
                    if (viewerControls) {
                        console.log('[Viewer] Manual AO rebake with settings:', viewerState.aoSettings);
                        viewerControls.setAOSettings(viewerState.aoSettings);
                        viewerControls.rebakeAO();
                    }
                });

                adjChanSelect?.addEventListener('change', (e) => {
                    currentAdjChannel = e.target.value;
                    if (viewerState.syncAdjChannel && viewerControls) {
                        const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                        if (materialChan) {
                            viewerControls.setMaterialChannel(materialChan);
                            // Update the main channel selector UI if it exists
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = materialChan;
                        }
                    }
                    updateViewerUI();
                });

                const adjSyncBtn = document.getElementById('adj-sync-view-btn');
                adjSyncBtn?.addEventListener('click', () => {
                    viewerState.syncAdjChannel = !viewerState.syncAdjChannel;
                    if (viewerControls) {
                        if (viewerState.syncAdjChannel) {
                            const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                            if (materialChan) {
                                viewerControls.setMaterialChannel(materialChan);
                                const mainChanSelect = document.getElementById('viewer-channel-select');
                                if (mainChanSelect) mainChanSelect.value = materialChan;
                            }
                        } else {
                            // Revert to PBR
                            viewerControls.setMaterialChannel(1); // MaterialChannel.PBR
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = 1;
                        }
                    }
                    updateViewerUI();
                });

                adjBrightSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].brightness = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-bright-val').textContent = val.toFixed(3);
                });

                adjContrastSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].contrast = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-contrast-val').textContent = val.toFixed(3);
                });

                adjSaturSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].saturation = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-satur-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-mode-select')?.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value);
                    viewerState.adjustments[currentAdjChannel].mode = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    updateViewerUI();
                });

                document.getElementById('adj-mask-color')?.addEventListener('input', (e) => {
                    viewerState.adjustments[currentAdjChannel].maskColor = e.target.value;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                document.getElementById('adj-soft-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].softness = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-soft-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-em-mult-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].emissiveMult = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-em-mult-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-invert-mask')?.addEventListener('change', (e) => {
                    viewerState.adjustments[currentAdjChannel].invert = e.target.checked;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                document.getElementById('adj-blend-color')?.addEventListener('input', (e) => {
                    viewerState.adjustments[currentAdjChannel].blendColor = e.target.value;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                // Global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Space key for fullscreen toggle
                    if (e.key === ' ' && !e.repeat && !e.target.matches('input, textarea, select')) {
                        e.preventDefault();
                        toggleFullscreen();
                    }
                });
            }

            async function initScene() {
                if (sceneInited) return;
                sceneInited = true;

                const videoContainer = document.getElementById('video-container');
                if (videoContainer) videoContainer.classList.remove('hidden');
                
                wrap.classList.remove('hidden');
                setStatus('Initializing...');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(LIGHTING_CONFIG.bgColor);

                // Renderer (PBR critical settings from config)
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = LIGHTING_CONFIG.toneMapping;
                renderer.toneMappingExposure = LIGHTING_CONFIG.toneMappingExposure;
                renderer.physicallyCorrectLights = true;

                host.innerHTML = '';
                host.appendChild(renderer.domElement);

                camera = new THREE.PerspectiveCamera(45, 1, 0.01, 1000);
                camera.position.set(0, 1.5, 3);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.target.set(0, 1.0, 0);
                
                // Auto-rotate: ~10 sec per full rotation (360¬∞ / 10s = 36¬∞/s)
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.2;
                
                // Stop auto-rotate on user interaction
                const stopAutoRotate = () => { controls.autoRotate = false; };
                renderer.domElement.addEventListener('pointerdown', stopAutoRotate, { once: true });
                renderer.domElement.addEventListener('wheel', stopAutoRotate, { once: true });
                
                controls.update();

                // Required stack: TransformControls (initialized, viewer-only for now)
                transform = new TransformControls(camera, renderer.domElement);
                transform.enabled = false;
                scene.add(transform);

                // Lighting setup (from LIGHTING_CONFIG)
                sunLight = new THREE.DirectionalLight(LIGHTING_CONFIG.sunColor, LIGHTING_CONFIG.sunIntensity);
                sunLight.position.set(...LIGHTING_CONFIG.sunPosition);
                sunLight.castShadow = true;
                
                // Optimized shadow settings
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.near = 0.1;
                sunLight.shadow.camera.far = 100;
                
                // Fit frustum to model area
                const s = 5; 
                sunLight.shadow.camera.left = -s;
                sunLight.shadow.camera.right = s;
                sunLight.shadow.camera.top = s;
                sunLight.shadow.camera.bottom = -s;
                
                // Bias to prevent self-shadowing artifacts
                sunLight.shadow.bias = -0.0001; 
                sunLight.shadow.normalBias = 0.02; // Critical for PBR materials
                
                scene.add(sunLight);
                
                // Add shadow target to ensure it points to center
                scene.add(sunLight.target);
                sunLight.target.position.set(0, 0, 0);

                ambientLight = new THREE.AmbientLight(LIGHTING_CONFIG.ambientColor, LIGHTING_CONFIG.ambientIntensity);
                scene.add(ambientLight);

                hemiLight = new THREE.HemisphereLight(
                    LIGHTING_CONFIG.hemiSkyColor,
                    LIGHTING_CONFIG.hemiGroundColor,
                    LIGHTING_CONFIG.hemiIntensity
                );
                scene.add(hemiLight);

                // Composer & Bloom setup
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(host.clientWidth, host.clientHeight),
                    viewerState.bloom.strength,
                    viewerState.bloom.radius,
                    viewerState.bloom.threshold
                );
                composer.addPass(bloomPass);

                const outputPass = new OutputPass();
                composer.addPass(outputPass);

                // Ground Plane
                const groundGeo = new THREE.PlaneGeometry(10, 10); // Much larger to handle gradient fade
                const groundMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.8,
                    metalness: 0.1,
                    transparent: true
                });

                groundMat.onBeforeCompile = (shader) => {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <common>',
                        `
                        #include <common>
                        varying vec2 vWorldUv;
                        `
                    );
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <common>',
                        `
                        #include <common>
                        varying vec2 vWorldUv;
                        `
                    );
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        #include <begin_vertex>
                        vWorldUv = uv;
                        `
                    );
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <output_fragment>',
                        `
                        // Radial alpha gradient
                        // vWorldUv is 0..1 over the 10x10 plane. 
                        // Center is 0.5, 0.5. 
                        // 1.5m radius in 10m plane is 1.5/10 = 0.15 normalized units.
                        float dist = distance(vWorldUv, vec2(0.5));
                        float radius = 0.45; // Normalized radius for fade (starts at 1.5m, fades to 4.5m)
                        
                        // Long entry: stay opaque for 1.5m, then fade out slowly
                        // 1.5m is 0.15 dist. Let's fade from 0.15 to 0.45.
                        float alpha = 1.0 - smoothstep(0.15, 0.48, dist);
                        
                        // Apply to output
                        gl_FragColor.a *= alpha;
                        #include <output_fragment>
                        `
                    );
                };

                const groundPlane = new THREE.Mesh(groundGeo, groundMat);
                groundPlane.rotation.x = -Math.PI / 2;
                groundPlane.position.set(0, 0, 0);
                groundPlane.receiveShadow = true;
                scene.add(groundPlane);
                
                // Setup viewer controls and load saved settings
                setupViewerControls();
                loadViewerSettings();

                function resize() {
                    const w = host.clientWidth || 640;
                    const h = host.clientHeight || 420;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h, false);
                    if (composer) composer.setSize(w, h);
                    if (bloomPass) bloomPass.resolution.set(w, h);
                }
                window.addEventListener('resize', resize);
                resize();

                await loadEnvironment(scene);

                // Initialize ViewerControls
                viewerControls = new ViewerControls({
                    scene,
                    camera,
                    renderer,
                    controls,
                    transform,
                    groundPlane, // Pass the ground plane mesh
                    bloomPass, // Pass the bloom pass
                    t,
                    onSaveDefaultSettings: () => saveDefaultViewerSettings('hotkey'),
                    onCameraModeChange: (mode) => {
                        const label = document.getElementById('viewer-camera-label');
                        const modeLabels = {
                            'static': 'Static',
                            'orbit': 'Orbit',
                            'fly': 'Fly'
                        };
                        if (label) label.textContent = modeLabels[mode] || mode;
                        console.log('[Viewer] Camera mode changed to:', mode);
                    },
                    onChannelChange: (channel) => {
                        const select = document.getElementById('viewer-channel-select');
                        if (select) select.value = String(channel);
                        console.log('[Viewer] Channel changed to:', channel);
                    },
                    onRigTypeChange: (rigType) => {
                        const select = document.getElementById('viewer-rigtype-select');
                        if (select) select.value = rigType;
                        console.log('[Viewer] Rig type changed to:', rigType);
                    }
                });
                window.viewerControls = viewerControls; // Make global for debugging

                // Apply settings again now that viewerControls is ready
                applyViewerState();

                // Initialize RigEditor
                rigEditor = new RigEditor({
                    taskId,
                    taskStatus: 'created',
                    rigType: RigType.CHAR,
                    t,
                    onRestart: async (rigType) => {
                        console.log('[RigEditor] Restarting with rig type:', rigType);
                        // Call the restart API
                        const resp = await fetch(`/api/task/${taskId}/restart`, { method: 'POST' });
                        if (!resp.ok) {
                            const data = await resp.json().catch(() => ({}));
                            throw new Error(data.detail || 'Restart failed');
                        }
                        // Reload the page to see updated status
                        window.location.reload();
                    },
                    onRigTypeChange: (rigType) => {
                        console.log('[RigEditor] Rig type changed to:', rigType);
                        if (viewerControls) {
                            viewerControls.setRigType(rigType);
                        }
                    }
                });

                // Wire up UI elements
                setupViewerUI();

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't capture if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
                    if (viewerControls && viewerControls.handleKeyDown(e.key)) {
                        e.preventDefault();
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (viewerControls) viewerControls.handleKeyUp(e.key);
                });

                // Mouse move for fly camera (handled by ViewerControls via right-drag)
                // No pointer lock needed - fly mode uses right-drag for mouse look

                let frameCount = 0;
                let lastTime = performance.now();
                const fpsLabel = document.getElementById('viewer-fps');

                // Render loop
                function loop() {
                    requestAnimationFrame(loop);

                    // FPS calculation
                    frameCount++;
                    const time = performance.now();
                    if (time >= lastTime + 1000) {
                        if (fpsLabel) {
                            fpsLabel.textContent = `${frameCount} FPS`;
                            if (frameCount >= 55) fpsLabel.style.color = 'rgba(0, 255, 0, 0.4)';
                            else if (frameCount >= 30) fpsLabel.style.color = 'rgba(255, 255, 0, 0.4)';
                            else fpsLabel.style.color = 'rgba(255, 0, 0, 0.4)';
                        }
                        frameCount = 0;
                        lastTime = time;
                    }

                    const dt = clock.getDelta();
                    if (mixer) mixer.update(dt);
                    if (viewerControls) viewerControls.updateFlyCamera(dt);
                    controls.update();
                    
                    // Camera sync (only if not in comparison mode AND camera is initialized)
                    if (!isDefaultComparisonOn && cameraInitialized && camera && controls) {
                        // Update camera position in state
                        viewerState.camera.position.x = camera.position.x;
                        viewerState.camera.position.y = camera.position.y;
                        viewerState.camera.position.z = camera.position.z;
                        viewerState.camera.target.x = controls.target.x;
                        viewerState.camera.target.y = controls.target.y;
                        viewerState.camera.target.z = controls.target.z;
                    }
                    
                    if (composer) {
                        composer.render();
                    } else {
                        renderer.render(scene, camera);
                    }
                }
                loop();
            }

            function setupViewerUI() {
                // Restart task button (simplified from modal)
                const changeRigBtn = document.getElementById('change-rig-btn');
                if (changeRigBtn) {
                    changeRigBtn.addEventListener('click', async () => {
                        const status = window.TaskPage?.task?.status || 'created';
                        const isRunning = status === 'processing' || status === 'created';
                        
                        const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                        const isRu = lang.startsWith('ru');
                        
                        let confirmMsg = isRu 
                            ? '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞–¥–∞—á—É —Ä–∏–≥–≥–∏–Ω–≥–∞?'
                            : 'Restart rigging task?';
                        
                        if (isRunning) {
                            confirmMsg = isRu
                                ? '–¢–µ–∫—É—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ü—Ä–µ—Ä–≤–∞—Ç—å –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å?'
                                : 'Current operation is not complete. Interrupt and restart?';
                        }
                        
                        if (!confirm(confirmMsg)) return;
                        
                        changeRigBtn.disabled = true;
                        changeRigBtn.querySelector('span:last-child').textContent = '...';
                        
                        try {
                            const resp = await fetch(`/api/task/${taskId}/restart`, { method: 'POST' });
                            if (!resp.ok) {
                                const data = await resp.json().catch(() => ({}));
                                alert(data.detail || 'Restart failed');
                                return;
                            }
                            window.location.reload();
                        } catch (e) {
                            console.error('[Viewer] Restart error:', e);
                            alert('Restart failed');
                        } finally {
                            changeRigBtn.disabled = false;
                            changeRigBtn.querySelector('span:last-child').textContent = t('btn_restart_task');
                        }
                    });
                }

                // Camera mode button - cycle through modes
                const cameraModeBtn = document.getElementById('viewer-camera-btn');
                if (cameraModeBtn && viewerControls) {
                    cameraModeBtn.addEventListener('click', () => {
                        const modes = [CameraMode.ORBIT, CameraMode.STATIC, CameraMode.FLY];
                        const currentIdx = modes.indexOf(viewerControls.cameraMode);
                        const nextIdx = (currentIdx + 1) % modes.length;
                        viewerControls.setCameraMode(modes[nextIdx]);
                    });
                    console.log('[Viewer] Camera mode button wired');
                }

                // Gizmos visibility button
                const gizmosBtn = document.getElementById('viewer-gizmos-btn');
                if (gizmosBtn && viewerControls) {
                    gizmosBtn.addEventListener('click', () => {
                        const visible = !viewerControls.gizmosVisible;
                        viewerControls.setGizmosVisibility(visible);
                        gizmosBtn.style.opacity = visible ? '1' : '0.4';
                        gizmosBtn.style.background = visible ? 'rgba(0,0,0,0.75)' : 'rgba(0,0,0,0.4)';
                    });
                    console.log('[Viewer] Gizmos toggle button wired');
                }

                // Fullscreen button
                const fullscreenBtn = document.getElementById('viewer-fullscreen-btn');
                if (fullscreenBtn && renderer) {
                    fullscreenBtn.addEventListener('click', () => {
                        toggleFullscreen();
                    });
                    updateFullscreenButton(); // Initialize button state
                    console.log('[Viewer] Fullscreen button wired');
                }

                // Default/Saved comparison toggle
                const defaultToggleBtn = document.getElementById('viewer-default-toggle');
                if (defaultToggleBtn && viewerControls) {
                    defaultToggleBtn.addEventListener('click', () => {
                        isDefaultComparisonOn = !isDefaultComparisonOn;
                        
                        if (isDefaultComparisonOn) {
                            // Apply neutral defaults
                            const defaults = {
                                mainLightIntensity: 3.0,
                                envIntensity: 1.0,
                                reflectionIntensity: 3.0,
                                bgColor: '#000000',
                                bloom: { strength: 0.0, threshold: 0.8, radius: 0.4 },
                                groundColor: '#222222',
                                groundSize: 100.0,
                                fogColor: '#000000',
                                fogDensity: 0.0,
                                adjustments: {}
                            };
                            const channels = ['albedo', 'ao', 'normal', 'roughness', 'metalness', 'emissive'];
                            channels.forEach(c => {
                                defaults.adjustments[c] = { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false };
                            });

                            // Temporarily override visual state
                            // 1. Lighting
                            if (sunLight) sunLight.intensity = LIGHTING_CONFIG.sunIntensity * defaults.mainLightIntensity;
                            if (ambientLight) ambientLight.intensity = LIGHTING_CONFIG.ambientIntensity * defaults.mainLightIntensity;
                            if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * defaults.mainLightIntensity;
                            if (scene && 'environmentIntensity' in scene) scene.environmentIntensity = defaults.envIntensity;
                            if (scene) scene.background = new THREE.Color(defaults.bgColor);
                            
                            // 2. Props
                            viewerControls.setBloomSettings(defaults.bloom);
                            viewerControls.setGroundParams({ color: defaults.groundColor, size: defaults.groundSize });

                            // Fog
                            if (scene) {
                                if (defaults.fogDensity > 0) {
                                    scene.fog = new THREE.FogExp2(defaults.fogColor, defaults.fogDensity);
                                } else {
                                    scene.fog = null;
                                }
                            }
                            
                            // 3. Adjustments
                            for (const chan in defaults.adjustments) {
                                viewerControls.setChannelAdjustments(chan, defaults.adjustments[chan]);
                            }

                            defaultToggleBtn.style.background = 'var(--accent)';
                            defaultToggleBtn.style.opacity = '1';
                        } else {
                            // Restore actual state
                            applyViewerState();
                            defaultToggleBtn.style.background = 'rgba(0,0,0,0.75)';
                            defaultToggleBtn.style.opacity = '0.5';
                        }
                    });
                    console.log('[Viewer] Default toggle button wired');
                }

                // Collapsible Panels
                const setupPanel = (headerId, contentId, arrowId) => {
                    const header = document.getElementById(headerId);
                    const content = document.getElementById(contentId);
                    const arrow = document.getElementById(arrowId);
                    if (!header || !content) return;

                    header.addEventListener('click', () => {
                        const isHidden = content.classList.contains('hidden');
                        if (isHidden) {
                            content.classList.remove('hidden');
                            if (arrow) arrow.style.transform = 'rotate(0deg)';
                        } else {
                            content.classList.add('hidden');
                            if (arrow) arrow.style.transform = 'rotate(-90deg)';
                        }
                    });
                    
                    // Initial state: rotated arrow for hidden content
                    if (content.classList.contains('hidden') && arrow) {
                        arrow.style.transform = 'rotate(-90deg)';
                    }
                };

                setupPanel('lighting-panel-header', 'lighting-panel-content', 'lighting-panel-arrow');
                setupPanel('adjustments-panel-header', 'adjustments-panel-content', 'adjustments-panel-arrow');

                // Rig type selector - direct switching
                const rigTypeSelect = document.getElementById('viewer-rigtype-select');
                if (rigTypeSelect && viewerControls) {
                    rigTypeSelect.addEventListener('change', (e) => {
                        const rigType = e.target.value;
                        console.log('[Viewer] Switching rig type to:', rigType);
                        viewerControls.setRigType(rigType);
                    });
                    console.log('[Viewer] Rig type selector wired');
                }

                // Channel selector
                const channelSelect = document.getElementById('viewer-channel-select');
                if (channelSelect && viewerControls) {
                    channelSelect.addEventListener('change', (e) => {
                        const channel = parseInt(e.target.value, 10);
                        viewerControls.setMaterialChannel(channel);
                    });
                    console.log('[Viewer] Channel selector wired');
                }

                // Admin-only: visible Z button (bottom center)
                ensureViewerAdmin().then((isAdmin) => {
                    if (!isAdmin) return;
                    const overlay = document.getElementById('viewer-overlay');
                    if (!overlay) return;
                    if (document.getElementById('viewer-save-default-btn')) return;

                    const btn = document.createElement('button');
                    btn.id = 'viewer-save-default-btn';
                    btn.className = 'btn btn-primary';
                    btn.textContent = 'Z';
                    btn.title = 'Save default viewer settings (Z)';
                    btn.style.position = 'absolute';
                    btn.style.left = '50%';
                    btn.style.bottom = '12px';
                    btn.style.transform = 'translateX(-50%)';
                    btn.style.zIndex = '20';
                    btn.style.width = '56px';
                    btn.style.height = '44px';
                    btn.style.borderRadius = '14px';
                    btn.style.padding = '0';
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                    btn.style.pointerEvents = 'auto';

                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        saveDefaultViewerSettings('button');
                    });

                    overlay.appendChild(btn);
                    console.log('[Viewer] Admin Z button added');
                });
            }

            // Track if current model is from Free3D (needs rotation fix)
            let isFree3DModel = false;

            async function loadModel(glbUrl, label = 'GLB', retryCount = 0) {
                if (!sceneInited) await initScene();

                setStatus(`Loading ${label}...`);
                const loader = new GLTFLoader();
                let gltf;
                try {
                    gltf = await new Promise((resolve, reject) => {
                        loader.load(glbUrl, resolve, undefined, (err) => {
                            // If it's a network error/protocol error and we haven't retried yet
                            if (retryCount < 1) {
                                console.warn(`[Viewer] Load failed for ${label}, retrying...`, err);
                                resolve(null); // Signal retry
                            } else {
                                reject(err);
                            }
                        });
                    });
                    
                    if (gltf === null) {
                        // Wait a bit before retry
                        await new Promise(r => setTimeout(r, 1000));
                        return await loadModel(glbUrl, label, retryCount + 1);
                    }
                } catch (e) {
                    setStatus(`${label} not found`);
                    console.warn(`[Viewer] Failed to load ${label}:`, e);
                    return false;
                }

                // Remove previous model
                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel = null;
                }

                const model = gltf.scene;
                scene.add(model);
                currentModel = model;

                // Update ViewerControls with new model (applies rotation & alignment)
                if (viewerControls) {
                    // Apply AO settings before baking
                    viewerControls.setAOSettings(viewerState.aoSettings);
                    viewerControls.setModel(model);
                }

                // Restore camera from saved state (or use defaults if no saved state)
                if (savedCameraPosition && savedCameraTarget) {
                    restoreSavedCamera();
                } else {
                    // No saved camera - calculate initial position based on model size
                    console.log('[Viewer] No saved camera, calculating initial position');
                    try {
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3()).length();
                        const camZ = Math.max(3.5, size * 1.2);
                        
                        controls.target.set(0, 1.0, 0);
                        controls.update();
                        camera.position.set(0, 1.6, camZ);
                        
                        // Save this initial position to state
                        viewerState.camera = {
                            position: { x: 0, y: 1.6, z: camZ },
                            target: { x: 0, y: 1.0, z: 0 }
                        };
                        console.log('[Viewer] Initial camera set:', viewerState.camera);
                    } catch (err) {
                        console.error('[Viewer] Alignment error:', err);
                    }
                    cameraInitialized = true; // Allow sync
                }
                
                // Hide loading overlay now that camera is set
                hideLoadingOverlay();

                animations = gltf.animations || [];
                console.log(`[Viewer] ${label} loaded. Animations found:`, animations.length);
                if (animations.length) {
                    console.log('[Viewer] Animation names:', animations.map(a => a.name));
                }
                
                mixer = animations.length ? new THREE.AnimationMixer(model) : null;

                // UI for animations
                if (sel && playBtn && pauseBtn && animations.length) {
                    console.log('[Viewer] Setting up animation UI controls...');
                    sel.innerHTML = animations.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
                    sel.classList.remove('hidden');
                    playBtn.classList.remove('hidden');
                    pauseBtn.classList.remove('hidden');
                    
                    // Remove old listeners and add new ones
                    const newSel = sel.cloneNode(true);
                    sel.parentNode.replaceChild(newSel, sel);
                    sel = newSel;
                    
                    const newPlayBtn = playBtn.cloneNode(true);
                    playBtn.parentNode.replaceChild(newPlayBtn, playBtn);
                    playBtn = newPlayBtn;
                    
                    const newPauseBtn = pauseBtn.cloneNode(true);
                    pauseBtn.parentNode.replaceChild(newPauseBtn, pauseBtn);
                    pauseBtn = newPauseBtn;
                    
                    sel.addEventListener('change', () => {
                        console.log('[Viewer] Animation changed to:', sel.value);
                        play(sel.value);
                    });
                    playBtn.addEventListener('click', () => {
                        console.log('[Viewer] Play clicked, animation:', sel.value);
                        play(sel.value);
                    });
                    pauseBtn.addEventListener('click', () => {
                        console.log('[Viewer] Pause clicked');
                        if (mixer) mixer.timeScale = 0;
                    });
                    
                    try {
                        console.log('[Viewer] Auto-playing first animation:', sel.value);
                        play(sel.value);
                    } catch (e) {
                        console.warn('[Viewer] Auto-play failed:', e);
                    }
                } else {
                    console.log('[Viewer] No animations or UI elements missing');
                    sel?.classList.add('hidden');
                    playBtn?.classList.add('hidden');
                    pauseBtn?.classList.add('hidden');
                }

                const statusText = animations.length ? `Ready (${animations.length} animations)` : 'Ready (no animations)';
                setStatus(statusText);
                console.log('[Viewer] Status:', statusText);
                return true;
            }

            // Load FBX model with animations
            async function loadFBX(fbxUrl, label = 'FBX', retryCount = 0) {
                if (!sceneInited) await initScene();

                setStatus(`Loading ${label}...`);
                const loader = new FBXLoader();
                let model;
                try {
                    model = await new Promise((resolve, reject) => {
                        loader.load(fbxUrl, resolve, undefined, (err) => {
                            if (retryCount < 1) {
                                console.warn(`[Viewer] Load failed for ${label}, retrying...`, err);
                                resolve(null);
                            } else {
                                reject(err);
                            }
                        });
                    });

                    if (model === null) {
                        await new Promise(r => setTimeout(r, 1000));
                        return await loadFBX(fbxUrl, label, retryCount + 1);
                    }
                } catch (e) {
                    setStatus(`${label} not found`);
                    console.warn(`[Viewer] Failed to load ${label}:`, e);
                    return false;
                }

                // Remove previous model
                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel = null;
                }

                scene.add(model);
                currentModel = model;

                // Update ViewerControls with new model (applies rotation & alignment)
                if (viewerControls) {
                    // Apply AO settings before baking
                    viewerControls.setAOSettings(viewerState.aoSettings);
                    viewerControls.setModel(model);
                }

                // Restore camera from saved state (or use defaults if no saved state)
                if (savedCameraPosition && savedCameraTarget) {
                    restoreSavedCamera();
                } else {
                    // No saved camera - calculate initial position based on model size
                    console.log('[Viewer] No saved camera, calculating initial position');
                    try {
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3()).length();
                        const camZ = Math.max(3.5, size * 1.2);
                        
                        controls.target.set(0, 1.0, 0);
                        controls.update();
                        camera.position.set(0, 1.6, camZ);
                        
                        // Save this initial position to state
                        viewerState.camera = {
                            position: { x: 0, y: 1.6, z: camZ },
                            target: { x: 0, y: 1.0, z: 0 }
                        };
                        console.log('[Viewer] Initial camera set:', viewerState.camera);
                    } catch (err) {
                        console.error('[Viewer] FBX alignment error:', err);
                    }
                    cameraInitialized = true; // Allow sync
                }
                
                // Hide loading overlay now that camera is set
                hideLoadingOverlay();

                // FBX animations are stored on the model object directly
                animations = model.animations || [];
                console.log(`[Viewer] ${label} loaded. Animations found:`, animations.length);
                if (animations.length) {
                    console.log('[Viewer] Animation names:', animations.map(a => a.name));
                }
                
                mixer = animations.length ? new THREE.AnimationMixer(model) : null;

                // UI for animations
                if (sel && playBtn && pauseBtn && animations.length) {
                    console.log('[Viewer] Setting up animation UI controls...');
                    sel.innerHTML = animations.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
                    sel.classList.remove('hidden');
                    playBtn.classList.remove('hidden');
                    pauseBtn.classList.remove('hidden');
                    
                    // Remove old listeners and add new ones
                    const newSel = sel.cloneNode(true);
                    sel.parentNode.replaceChild(newSel, sel);
                    sel = newSel;
                    
                    const newPlayBtn = playBtn.cloneNode(true);
                    playBtn.parentNode.replaceChild(newPlayBtn, playBtn);
                    playBtn = newPlayBtn;
                    
                    const newPauseBtn = pauseBtn.cloneNode(true);
                    pauseBtn.parentNode.replaceChild(newPauseBtn, pauseBtn);
                    pauseBtn = newPauseBtn;
                    
                    sel.addEventListener('change', () => {
                        console.log('[Viewer] Animation changed to:', sel.value);
                        play(sel.value);
                    });
                    playBtn.addEventListener('click', () => {
                        console.log('[Viewer] Play clicked, animation:', sel.value);
                        play(sel.value);
                    });
                    pauseBtn.addEventListener('click', () => {
                        console.log('[Viewer] Pause clicked');
                        if (mixer) mixer.timeScale = 0;
                    });
                    
                    try {
                        console.log('[Viewer] Auto-playing first animation:', sel.value);
                        play(sel.value);
                    } catch (e) {
                        console.warn('[Viewer] Auto-play failed:', e);
                    }
                } else {
                    console.log('[Viewer] No animations or UI elements missing');
                    sel?.classList.add('hidden');
                    playBtn?.classList.add('hidden');
                    pauseBtn?.classList.add('hidden');
                }

                const statusText = animations.length ? `Ready (${animations.length} animations)` : 'Ready (no animations)';
                setStatus(statusText);
                console.log('[Viewer] Status:', statusText);
                return true;
            }

            // Track which models are loaded
            let animationsLoaded = false;
            let free3dModelLoaded = false;

            // Init viewer: Free3D loads immediately, others wait for prepared/done
            async function waitAndInitViewer() {
                try {
                    console.log('[Viewer] Polling task status...');
                    const r = await fetch(`/api/task/${taskId}`);
                    const t = await r.json();
                    console.log('[Viewer] Task status:', t.status, 'prepared_glb_ready:', t.prepared_glb_ready);

                    const isFree3DTask = t && t.input_url && t.input_url.includes('free3d.online');

                    // 1. FREE3D: Load immediately from free3d.online (no waiting for worker)
                    if (isFree3DTask && !free3dModelLoaded) {
                        console.log('[Viewer] Free3D task detected - loading directly from free3d.online...');
                        
                        // Default to X -90 fix for Free3D models
                        if (viewerState.modelRotation === 'none' || viewerState.modelRotation === 'z180') {
                            console.log('[Viewer] Defaulting Free3D to X -90 rotation');
                            viewerState.modelRotation = 'x90_neg';
                            updateViewerUI();
                        }

                        const urlMatch = t.input_url.match(/\/data\/([a-f0-9-]+)\//i);
                        if (urlMatch) {
                            const guid = urlMatch[1];
                            const proxyUrl = `/api/free3d/glb/${guid}/${guid}.glb`;
                            const ok = await loadModel(proxyUrl, 'Free3D Model');
                            if (ok) {
                                free3dModelLoaded = true;
                                preparedLoaded = true;
                                console.log('[Viewer] ‚úì Free3D model loaded immediately');
                            }
                        }
                    }

                    // 2. If task is done, load final model (with animations if available)
                    if (t && t.status === 'done' && !finalLoaded) {
                        console.log('[Viewer] Task is done! Loading final animations/model...');
                        let ok = false;
                        
                        // Try animations.glb first
                        ok = await loadModel(`/api/task/${taskId}/animations.glb`, 'Animations GLB');
                        
                        // Try animations.fbx fallback
                        if (!ok) {
                            ok = await loadFBX(`/api/task/${taskId}/animations.fbx`, 'Animations FBX');
                        }
                        
                        // Try locally cached prepared.glb (might be faster/more reliable)
                        if (!ok && t.prepared_glb_ready) {
                            ok = await loadModel(`/api/task/${taskId}/prepared.glb`, 'Prepared GLB (Fallback)');
                        }

                        // Last resort: model.glb
                        if (!ok) {
                            ok = await loadModel(`/api/task/${taskId}/model.glb`, 'Final Model');
                        }
                        
                        if (ok) {
                            animationsLoaded = true;
                            finalLoaded = true;
                            console.log('[Viewer] ‚úì Final model loaded');
                            if (animations.length > 0 && viewerControls) {
                                viewerControls.setRigType(RigType.ANIMATIONS);
                                const rigTypeSelect = document.getElementById('viewer-rigtype-select');
                                if (rigTypeSelect) rigTypeSelect.value = 'animations';
                            }
                            return; // Success, stop polling
                        } else {
                            console.warn('[Viewer] Failed to load any final model, will retry in 5s...');
                            setTimeout(waitAndInitViewer, 5000);
                            return;
                        }
                    }

                    // 3. For non-Free3D tasks: load prepared model as early preview ONLY if task is not done yet
                    // (If task is already done, we should have loaded animations above)
                    if (!isFree3DTask && t && t.status !== 'done' && t.prepared_glb_ready && !preparedLoaded) {
                        console.log('[Viewer] Task still processing, loading prepared model as preview...');
                        const ok = await loadModel(`/api/task/${taskId}/prepared.glb`, 'Prepared Model');
                        if (ok) preparedLoaded = true;
                    }

                    // Update RigEditor status
                    if (rigEditor && t) rigEditor.setTaskStatus(t.status);
                } catch (e) {
                    console.warn('[Viewer] Poll error:', e);
                }
                // Keep polling until task is done
                setTimeout(waitAndInitViewer, 3000);
            }

            console.log('[Viewer] Starting viewer initialization...');
            waitAndInitViewer();
        }
    </script>

    <!-- Telegram WebApp Integration -->
    <script>
        window.TelegramApp = {
            shareTask(taskId) {
                const webappUrl = `${window.location.origin}/task?id=${taskId}&mode=webapp`;
                
                if (window.Telegram?.WebApp) {
                    // Inside Telegram - use switchInlineQuery to share
                    window.Telegram.WebApp.switchInlineQuery(webappUrl, ['users', 'groups', 'channels']);
                } else {
                    // Outside Telegram - open Telegram share URL
                    const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(webappUrl)}&text=${encodeURIComponent('Check out this 3D model!')}`;
                    window.open(shareUrl, '_blank');
                }
            },
            hapticFeedback(type) {
                if (window.Telegram?.WebApp?.HapticFeedback) {
                    if (type === 'success') window.Telegram.WebApp.HapticFeedback.notificationOccurred('success');
                    else if (type === 'error') window.Telegram.WebApp.HapticFeedback.notificationOccurred('error');
                }
            }
        };
        
        // Log if running as Telegram WebApp
        if (window.Telegram?.WebApp?.initData) {
            console.log('[Telegram] Running as Telegram WebApp');
        }
    </script>
</body>
</html>

