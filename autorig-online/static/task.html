<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Task Progress | AutoRig.online</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/static/css/styles.css">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T4E781EHE4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T4E781EHE4');
    </script>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-inner">
                <a href="/" class="logo">
                    <img src="/static/images/logo/logo.svg" alt="AutoRig" class="logo-icon" width="40" height="40">
                    <span>AutoRig</span>
                </a>
                
                <div class="header-actions">
                    <!-- Language Selector -->
                    <div class="lang-selector">
                        <button class="lang-btn">
                            <span>EN</span>
                        </button>
                        <div class="lang-dropdown">
                            <button class="lang-option" data-lang="en">English</button>
                            <button class="lang-option" data-lang="ru">–†—É—Å—Å–∫–∏–π</button>
                        </div>
                    </div>
                    
                    <!-- Theme Toggle -->
                    <button class="theme-toggle" id="theme-toggle" title="Toggle theme">üåô</button>
                    
                    <a href="/" class="btn btn-secondary">‚Üê Back</a>
                </div>
            </div>
        </div>
    </header>
    
    <main class="container-sm" style="padding-top: 2rem;">
        <!-- Task Card -->
        <div class="card">
            <h2 data-i18n="task_title">Conversion Progress</h2>
            
            <!-- Status Badge -->
            <div class="mt-2" id="status-container">
                <span class="alert alert-info" id="status-badge" style="display: inline-block;">
                    <span id="status-text">Processing...</span>
                </span>
            </div>
            
            <!-- Queue Status (compact) -->
            <div class="queue-status-compact mt-3" id="queue-status-compact">
                <img src="/static/images/icons/queue.svg" alt="Queue" class="queue-status-icon" width="20" height="20" style="display: none;">
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-active">-</span>
                    <span class="queue-stat-label" data-i18n="queue_active">Active</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-pending">-</span>
                    <span class="queue-stat-label" data-i18n="queue_pending">In Queue</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-wait">-</span>
                    <span class="queue-stat-label" data-i18n="queue_wait">Est. Wait</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-servers">-</span>
                    <span class="queue-stat-label" data-i18n="queue_servers">Servers</span>
                </div>
            </div>
            
            <!-- Progress -->
            <div class="progress-container" id="progress-container">
                <div class="progress-percent" id="progress-percent">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-text">
                    <span><span id="ready-count">0</span> / <span id="total-count">0</span> <span data-i18n="task_files_ready">files ready</span></span>
                    <span id="eta"></span>
                </div>
            </div>
            
            <!-- Error Message -->
            <div class="alert alert-error hidden mt-3" id="error-container">
                <span id="error-message"></span>
            </div>

            <!-- FBX -> GLB Pre-conversion -->
            <div class="mt-3 hidden" id="fbx-glb-step">
                <h3 class="mb-2" data-i18n="task_fbx_glb_title">FBX ‚Üí GLB</h3>
                <div class="alert alert-info" id="fbx-glb-badge" style="display: inline-block;">
                    <span id="fbx-glb-text" data-i18n="task_fbx_glb_pending">Converting FBX to GLB...</span>
                </div>
                <div class="mt-2" id="fbx-glb-link-container">
                    <a id="fbx-glb-link" href="#" target="_blank" class="btn btn-ghost"
                       style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"
                       data-i18n="task_fbx_glb_download">Download GLB</a>
                </div>
            </div>
            
            <!-- Video Preview -->
            <div class="video-preview hidden" id="video-container">
                <h3 class="mb-2" data-i18n="task_video_ready">Video Preview</h3>
                <video id="video-player" controls autoplay muted loop playsinline 
                       style="width: 100%; max-height: 500px; border-radius: 12px; background: #000;"></video>
            </div>
            
            <div class="alert alert-info hidden mt-3" id="video-pending">
                <span data-i18n="task_video_pending">Video is being generated...</span>
            </div>
            
            <!-- Actions -->
            <div class="flex gap-2 mt-3" id="actions-container">
                <button class="btn btn-primary" id="copy-all-btn" disabled>
                    <img src="/static/images/icons/copy.svg" alt="Copy" width="18" height="18" style="vertical-align: middle;">
                    <span data-i18n="btn_copy_all">Copy All Links</span>
                </button>
                <button class="btn btn-secondary" id="download-all-btn" disabled>
                    <img src="/static/images/icons/download.svg" alt="Download" width="18" height="18" style="vertical-align: middle;">
                    <span data-i18n="btn_download_all">Download All</span>
                </button>
                <button class="btn btn-secondary hidden" id="restart-task-btn">
                    <span data-i18n="btn_restart_task">Restart task</span>
                </button>
            </div>
        </div>
        
        <!-- Files List -->
        <div class="card mt-3">
            <div class="card-header">
                <h3 class="card-title">Files (<span id="files-count">0</span>)</h3>
            </div>
            <ul class="file-list" id="file-list">
                <!-- Skeleton loading -->
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 200px;"></div>
                </li>
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 180px;"></div>
                </li>
            </ul>
        </div>
    </main>
    
    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p data-i18n="footer_text">AutoRig Online ¬© 2025</p>
        </div>
    </footer>
    
    <!-- Scripts -->
    <script src="/static/js/i18n.js"></script>
    <script>
        const TaskPage = {
            taskId: null,
            pollInterval: null,
            task: null,
            
            async init() {
                // Init i18n
                await I18n.init();
                
                // Setup theme
                this.setupTheme();
                
                // Get task ID from URL
                const params = new URLSearchParams(window.location.search);
                this.taskId = params.get('id');
                
                if (!this.taskId) {
                    this.showError('No task ID provided');
                    return;
                }
                
                // Start polling
                await this.fetchTask();
                this.pollInterval = setInterval(() => this.fetchTask(), 2000);
                
                // Load queue status
                this.loadQueueStatus();
                setInterval(() => this.loadQueueStatus(), 10000);
                
                // Setup buttons
                this.setupButtons();
            },
            
            setupTheme() {
                const toggle = document.getElementById('theme-toggle');
                const savedTheme = localStorage.getItem('autorig_theme') || 'dark';
                document.documentElement.setAttribute('data-theme', savedTheme);
                toggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                
                toggle.addEventListener('click', () => {
                    const current = document.documentElement.getAttribute('data-theme');
                    const newTheme = current === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', newTheme);
                    localStorage.setItem('autorig_theme', newTheme);
                    toggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                });
            },
            
            async fetchTask() {
                try {
                    const response = await fetch(`/api/task/${this.taskId}`);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            this.showError('Task not found');
                            this.stopPolling();
                        }
                        return;
                    }
                    
                    this.task = await response.json();
                    this.updateUI();
                    
                    // Stop polling when done or error
                    if (this.task.status === 'done' || this.task.status === 'error') {
                        this.stopPolling();
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                }
            },
            
            updateUI() {
                const task = this.task;
                
                // Status
                const statusBadge = document.getElementById('status-badge');
                const statusText = document.getElementById('status-text');
                
                statusBadge.className = 'alert';
                if (task.status === 'done') {
                    statusBadge.classList.add('alert-success');
                    statusText.textContent = t('task_status_done');
                } else if (task.status === 'error') {
                    statusBadge.classList.add('alert-error');
                    statusText.textContent = t('task_status_error');
                } else if (task.status === 'processing') {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_processing');
                } else {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_created');
                }
                
                // Progress
                document.getElementById('progress-percent').textContent = task.progress + '%';
                document.getElementById('progress-fill').style.width = task.progress + '%';
                document.getElementById('ready-count').textContent = task.ready_count;
                document.getElementById('total-count').textContent = task.total_count;
                
                // Error
                if (task.error_message) {
                    document.getElementById('error-container').classList.remove('hidden');
                    document.getElementById('error-message').textContent = task.error_message;
                }

                // FBX -> GLB step UI
                const fbxStep = document.getElementById('fbx-glb-step');
                const fbxBadge = document.getElementById('fbx-glb-badge');
                const fbxText = document.getElementById('fbx-glb-text');
                const fbxLink = document.getElementById('fbx-glb-link');
                const fbxLinkContainer = document.getElementById('fbx-glb-link-container');

                const hasFbxStep = !!(task.fbx_glb_output_url || task.fbx_glb_model_name || task.fbx_glb_error || task.fbx_glb_ready === true);
                if (hasFbxStep) {
                    fbxStep.classList.remove('hidden');

                    // Link (show as soon as we have it, even if not ready yet)
                    if (task.fbx_glb_output_url) {
                        fbxLink.href = task.fbx_glb_output_url;
                        fbxLinkContainer.classList.remove('hidden');
                    } else {
                        fbxLinkContainer.classList.add('hidden');
                    }

                    fbxBadge.className = 'alert';
                    if (task.fbx_glb_error) {
                        fbxBadge.classList.add('alert-error');
                        fbxText.textContent = t('task_fbx_glb_error');
                    } else if (task.fbx_glb_ready) {
                        fbxBadge.classList.add('alert-success');
                        fbxText.textContent = t('task_fbx_glb_ready');
                    } else {
                        fbxBadge.classList.add('alert-info');
                        fbxText.textContent = t('task_fbx_glb_pending');
                    }
                } else {
                    fbxStep.classList.add('hidden');
                }

                // Restart button after 3 hours (always, even if done)
                const restartBtn = document.getElementById('restart-task-btn');
                if (task.created_at) {
                    const createdAt = new Date(task.created_at).getTime();
                    const ageMs = Date.now() - createdAt;
                    const threeHoursMs = 3 * 60 * 60 * 1000;
                    const oneMinuteMs = 60 * 1000;
                    const threshold = task.status === 'error' ? oneMinuteMs : threeHoursMs;
                    if (ageMs >= threshold) {
                        restartBtn.classList.remove('hidden');
                    } else {
                        restartBtn.classList.add('hidden');
                    }
                }
                
                // Video - use proxy to avoid Mixed Content
                if (task.video_ready) {
                    document.getElementById('video-container').classList.remove('hidden');
                    document.getElementById('video-pending').classList.add('hidden');
                    const video = document.getElementById('video-player');
                    const proxyUrl = `/api/video/${this.taskId}`;
                    if (!video.src.includes(this.taskId)) {
                        video.src = proxyUrl;
                        video.load();
                        video.play().catch(() => {}); // Auto-play may be blocked
                    }
                } else if (task.status === 'processing' || task.status === 'done') {
                    document.getElementById('video-pending').classList.remove('hidden');
                }
                
                // Files list
                this.updateFileList(task.ready_urls);
                
                // Buttons
                const copyBtn = document.getElementById('copy-all-btn');
                const downloadBtn = document.getElementById('download-all-btn');
                
                if (task.ready_urls && task.ready_urls.length > 0) {
                    copyBtn.disabled = false;
                    downloadBtn.disabled = false;
                }
            },
            
            updateFileList(urls) {
                const list = document.getElementById('file-list');
                const count = document.getElementById('files-count');
                
                if (!urls || urls.length === 0) {
                    list.innerHTML = `<li class="file-item" style="color: var(--text-muted)">Waiting for files...</li>`;
                    count.textContent = '0';
                    return;
                }
                
                count.textContent = urls.length;
                
                list.innerHTML = urls.map(url => {
                    const filename = url.split('/').pop();
                    return `
                        <li class="file-item">
                            <span class="file-item-name">${filename}</span>
                            <div class="file-item-status ready">
                                <a href="${url}" target="_blank" class="btn btn-ghost" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">Download</a>
                            </div>
                        </li>
                    `;
                }).join('');
            },
            
            setupButtons() {
                document.getElementById('copy-all-btn').addEventListener('click', () => {
                    if (this.task && this.task.ready_urls) {
                        const text = this.task.ready_urls.join('\n');
                        navigator.clipboard.writeText(text).then(() => {
                            alert('Links copied to clipboard!');
                        });
                    }
                });
                
                document.getElementById('download-all-btn').addEventListener('click', () => {
                    if (this.task && this.task.ready_urls) {
                        // Download each file
                        this.task.ready_urls.forEach((url, i) => {
                            setTimeout(() => {
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = url.split('/').pop();
                                a.click();
                            }, i * 500); // Stagger downloads
                        });
                    }
                });

                document.getElementById('restart-task-btn').addEventListener('click', async () => {
                    const btn = document.getElementById('restart-task-btn');
                    const statusBadge = document.getElementById('status-badge');
                    const statusText = document.getElementById('status-text');
                    const prevText = btn.textContent;
                    btn.disabled = true;
                    btn.textContent = t('btn_restart_task_working');
                    statusBadge.className = 'alert alert-info';
                    statusText.textContent = t('task_status_restarting');
                    try {
                        const resp = await fetch(`/api/task/${this.taskId}/restart`, { method: 'POST' });
                        const raw = await resp.text();
                        let data = {};
                        try { data = raw ? JSON.parse(raw) : {}; } catch (_) { data = {}; }
                        if (!resp.ok) {
                            alert(data.detail || raw || t('error_generic'));
                            return;
                        }

                        // Ensure polling is running again
                        if (!this.pollInterval) {
                            this.pollInterval = setInterval(() => this.fetchTask(), 2000);
                        }
                        await this.fetchTask();
                    } catch (e) {
                        console.error('Restart error:', e);
                        alert(t('error_generic'));
                    } finally {
                        btn.disabled = false;
                        btn.textContent = prevText;
                    }
                });
            },
            
            showError(message) {
                document.getElementById('error-container').classList.remove('hidden');
                document.getElementById('error-message').textContent = message;
                document.getElementById('progress-container').classList.add('hidden');
            },
            
            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            },
            
            async loadQueueStatus() {
                const activeEl = document.getElementById('queue-active');
                const pendingEl = document.getElementById('queue-pending');
                const waitEl = document.getElementById('queue-wait');
                const serversEl = document.getElementById('queue-servers');
                
                if (!activeEl) return;
                
                try {
                    const response = await fetch('/api/queue/status');
                    const data = await response.json();
                    
                    activeEl.textContent = data.total_active;
                    pendingEl.textContent = data.total_pending;
                    const s = Number(data.estimated_wait_seconds || 0);
                    if (s < 60) {
                        waitEl.textContent = t('queue_wait_lt1min');
                    } else if (s < 3600) {
                        const minutes = Math.ceil(s / 60);
                        waitEl.textContent = t('queue_wait_minutes', { minutes: String(minutes) });
                    } else {
                        const hours = Math.floor(s / 3600);
                        const minutes = Math.floor((s % 3600) / 60);
                        waitEl.textContent = t('queue_wait_hours', { hours: String(hours), minutes: String(minutes) });
                    }
                    serversEl.textContent = `${data.available_workers}/${data.total_workers}`;
                    
                    // Color coding
                    if (data.total_pending > 5) {
                        pendingEl.classList.add('warning');
                    } else {
                        pendingEl.classList.remove('warning');
                    }
                    
                    if (data.estimated_wait_seconds < 60) {
                        waitEl.classList.add('success');
                    } else if (data.estimated_wait_seconds > 1800) {
                        waitEl.classList.add('warning');
                    }
                } catch (error) {
                    console.error('Queue status error:', error);
                }
            }
        };
        
        document.addEventListener('DOMContentLoaded', () => TaskPage.init());
    </script>
</body>
</html>

