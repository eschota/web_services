<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Task Progress | AutoRig.online</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/static/css/styles.css?v=tc-4">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-T4E781EHE4"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T4E781EHE4');
    </script>
    
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Loading Overlay Styles -->
    <style>
        /* WebApp Mode - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π UI –¥–ª—è Telegram (—Ç–æ–ª—å–∫–æ viewer) */
        body.webapp-mode .header { display: none !important; }
        body.webapp-mode .queue-status-compact { display: none !important; }
        body.webapp-mode #progress-log { display: none !important; }
        body.webapp-mode #admin-input-url-row { display: none !important; }
        body.webapp-mode #owner-tasks-btn { display: none !important; }
        body.webapp-mode #restart-task-btn { display: none !important; }
        body.webapp-mode #change-rig-btn { display: none !important; }
        body.webapp-mode #task-run-state { display: none !important; }
        body.webapp-mode footer { display: none !important; }
        body.webapp-mode main { padding-top: 0.5rem !important; }
        body.webapp-mode .card:first-child h2 { display: none !important; }
        body.webapp-mode #progress-container { margin-bottom: 0.5rem; }
        body.webapp-mode #telegram-share-btn { display: inline-flex !important; }
        /* Hide downloads and video player in webapp mode - only 3D viewer */
        body.webapp-mode #downloads-card { display: none !important; }
        body.webapp-mode #video-player { display: none !important; }
        body.webapp-mode #video-preview-title { display: none !important; }
        body.webapp-mode #hdrp-renders { display: none !important; }
        body.webapp-mode #video-pending { display: none !important; }
        
        .viewer-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            border-radius: 12px;
        }
        
        .viewer-loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .viewer-loading-overlay.removed {
            display: none;
        }
        
        .viewer-loading-content {
            text-align: center;
            color: #fff;
        }
        
        .viewer-loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #4f46e5;
            border-radius: 50%;
            animation: viewer-spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes viewer-spin {
            to { transform: rotate(360deg); }
        }
        
        .viewer-loading-text {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        /* Texture Gallery */
        .texture-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
        .texture-tile {
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            background: rgba(var(--bg-secondary-rgb, 30, 30, 35), 0.5);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .texture-tile:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .texture-tile img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background: #111;
        }
        .texture-tile .label {
            padding: 0.5rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .texture-tile .download-btn {
            display: block;
            padding: 0.4rem;
            text-align: center;
            font-size: 0.75rem;
            background: var(--accent);
            color: #fff;
            text-decoration: none;
            transition: background 0.2s;
        }
        .texture-tile .download-btn:hover {
            background: var(--accent-hover);
        }
        /* Model Parameters Block */
        #model-params {
            background: rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 0.75rem;
        }
        #model-params .section-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .param-tile {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            padding: 0.6rem 0.5rem;
            text-align: center;
            transition: background 0.2s, border-color 0.2s;
        }
        .param-tile:hover {
            background: rgba(255,255,255,0.07);
            border-color: rgba(255,255,255,0.12);
        }
        .param-tile-label {
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            color: var(--text-secondary);
            margin-bottom: 0.35rem;
        }
        .param-tile-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .param-tile-value.status-processing {
            color: var(--accent);
        }
        .param-tile-value.status-done {
            color: #06d6a0;
        }
        .param-tile-value .limb-ok { color: #06d6a0; }
        .param-tile-value .limb-no { color: #ef476f; }
        .param-tile-value.val-green { color: #06d6a0; }
        .param-tile-value.val-yellow { color: #ffd166; }
        .param-tile-value.val-red { color: #ef476f; }
        
        /* QWER Transform Toolbar */
        .qwer-toolbar {
            display: flex;
            gap: 0.25rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.3rem;
            backdrop-filter: blur(12px);
        }
        .qwer-toolbar button {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1px;
            transition: background 0.15s, border-color 0.15s;
        }
        .qwer-toolbar button:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
        }
        .qwer-toolbar button.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        .qwer-toolbar button .icon { font-size: 1rem; }
        .qwer-toolbar button .key { font-size: 0.6rem; opacity: 0.7; }
        
        /* Rotation Buttons (XYZ) - 2x larger */
        .rotation-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .rotation-btn {
            width: 48px;
            height: 36px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            backdrop-filter: blur(12px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .rotation-btn.large {
            width: 96px;
            height: 72px;
            font-size: 1.2rem;
            border-radius: 12px;
            gap: 4px;
        }
        .rotation-btn.large .axis {
            font-size: 1.6rem;
        }
        .rotation-btn:hover {
            background: rgba(99, 102, 241, 0.3);
            border-color: var(--accent);
            transform: translateX(4px);
        }
        .rotation-btn:active {
            transform: scale(0.95);
        }
        .rotation-btn .axis {
            font-weight: 700;
            font-size: 0.9rem;
        }
        .rotation-btn.x .axis { color: #ef4444; }
        .rotation-btn.y .axis { color: #22c55e; }
        .rotation-btn.z .axis { color: #3b82f6; }
        
        /* SAVE RIG T-POSE Button - site accent style */
        .save-rig-btn {
            padding: 14px 32px;
            background: linear-gradient(135deg, var(--accent) 0%, #7c3aed 100%);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 20px var(--accent-glow);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        .save-rig-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.5);
        }
        .save-rig-btn:active {
            transform: scale(0.97);
        }
        .save-rig-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Hierarchy Navigator */
        .hierarchy-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            backdrop-filter: blur(12px);
            font-size: 0.75rem;
            color: #fff;
        }
        .hierarchy-nav button {
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.05);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }
        .hierarchy-nav button:hover {
            background: rgba(255,255,255,0.15);
        }
        .hierarchy-nav button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .hierarchy-nav .current-level {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
        }
        
        /* T-Pose Toggle */
        .tpose-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            backdrop-filter: blur(12px);
        }
        .tpose-toggle button {
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.05);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.15s, border-color 0.15s;
        }
        .tpose-toggle button:hover { background: rgba(255,255,255,0.15); }
        .tpose-toggle button.active {
            background: rgba(79, 70, 229, 0.5);
            border-color: var(--accent);
        }
        .tpose-toggle .label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        /* Snap Settings Panel */
        .snap-settings {
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.6rem;
            backdrop-filter: blur(12px);
            min-width: 140px;
        }
        .snap-settings .title {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .snap-settings .snap-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-bottom: 0.4rem;
        }
        .snap-settings .snap-row:last-child { margin-bottom: 0; }
        .snap-settings label {
            font-size: 0.7rem;
            color: #fff;
        }
        .snap-settings input[type="number"] {
            width: 60px;
            padding: 0.2rem 0.3rem;
            font-size: 0.7rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: #fff;
        }
        .snap-settings input[type="checkbox"] {
            accent-color: var(--accent);
        }
        
        /* View Mode Selector (T-Pose / RIG / Animation) - Vertical */
        .view-mode-selector {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.25rem;
            backdrop-filter: blur(12px);
        }
        .view-mode-selector button {
            padding: 0.4rem 0.5rem;
            font-size: 0.65rem;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.7);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            text-align: center;
            min-width: 50px;
        }
        .view-mode-selector button:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        .view-mode-selector button.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .view-mode-selector button.ready-pulse {
            border-color: #51cf66;
            box-shadow: 0 0 8px rgba(81, 207, 102, 0.5);
        }
        @keyframes pulse-ready {
            0%, 100% { box-shadow: 0 0 8px rgba(81, 207, 102, 0.3); }
            50% { box-shadow: 0 0 16px rgba(81, 207, 102, 0.8); }
        }
        
        /* Settings Toggle Button */
        .settings-toggle-btn {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.4rem 0.6rem;
            backdrop-filter: blur(12px);
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .settings-toggle-btn:hover {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.8);
        }
        .settings-toggle-btn.active {
            background: rgba(79, 70, 229, 0.3);
            border-color: var(--accent);
            color: #fff;
        }
        .settings-toggle-btn .strike {
            text-decoration: line-through;
            opacity: 0.5;
        }
        .settings-toggle-btn.active .strike {
            text-decoration: none;
            opacity: 1;
        }
        
        /* Loading Overlay */
        .viewer-loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1.2rem 1.5rem;
            min-width: 280px;
            max-width: 360px;
            backdrop-filter: blur(16px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .viewer-loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .viewer-loading-overlay .loading-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.6rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .viewer-loading-overlay .loading-title .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .viewer-loading-overlay .loading-status {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.8rem;
            min-height: 1.2em;
        }
        .viewer-loading-overlay .loading-progress-wrap {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .viewer-loading-overlay .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #818cf8);
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s ease-out;
        }
        .viewer-loading-overlay .loading-percent {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: right;
            font-family: 'Roboto Mono', monospace;
        }
        .viewer-loading-overlay .loading-queue {
            margin-top: 0.8rem;
            padding-top: 0.6rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.4);
        }
        .viewer-loading-overlay .loading-queue-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.25rem;
        }
        .viewer-loading-overlay .loading-queue-item.done {
            color: #51cf66;
        }
        .viewer-loading-overlay .loading-queue-item.active {
            color: var(--accent);
        }
        .viewer-loading-overlay .loading-queue-item .icon {
            width: 12px;
            text-align: center;
        }

        /* Context Panel for QWER modes */
        .transform-context-panel {
            position: relative;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 0.5rem;
            backdrop-filter: blur(12px);
            width: 200px;
        }
        .transform-context-panel .panel-title {
            font-size: 0.85rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .transform-context-panel .panel-title .title-icon {
            font-size: 1rem;
        }
        .transform-context-panel .panel-title.position-title {
            color: #51cf66;
        }
        .transform-context-panel .panel-title.rotation-title {
            color: #ff6b6b;
        }
        .transform-context-panel .panel-title.scale-title {
            color: #339af0;
        }
        .transform-context-panel .panel-title.selection-title {
            color: #ffd43b;
        }
        .transform-context-panel .info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
        }
        .transform-context-panel .info-row label {
            color: rgba(255,255,255,0.6);
            min-width: 50px;
        }
        .transform-context-panel .info-row .value {
            color: #fff;
            flex: 1;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .transform-context-panel input[type="number"] {
            -moz-appearance: textfield;
            -webkit-appearance: none;
            appearance: none;
            width: 38px;
            padding: 0.25rem 0.2rem;
            font-size: 0.7rem;
            font-family: 'Roboto Mono', monospace;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 3px 0 0 3px;
            color: #fff;
            text-align: center;
            transition: all 0.15s;
        }
        .transform-context-panel input[type="number"]:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.35);
        }
        .transform-context-panel input[type="number"]:focus {
            outline: none;
            background: rgba(255,255,255,0.25);
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(79,70,229,0.3);
        }
        /* Hide native spinners */
        .transform-context-panel input[type="number"]::-webkit-inner-spin-button,
        .transform-context-panel input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* Custom spinner wrapper */
        .input-with-spinners {
            display: flex;
            align-items: stretch;
        }
        .input-with-spinners .spinners {
            display: flex;
            flex-direction: column;
            width: 14px;
        }
        .input-with-spinners .spin-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.18);
            border: 1px solid rgba(255,255,255,0.25);
            border-left: none;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            font-size: 0.5rem;
            line-height: 1;
            padding: 0;
            transition: all 0.1s;
            user-select: none;
        }
        .input-with-spinners .spin-btn:first-child {
            border-radius: 0 3px 0 0;
            border-bottom: none;
        }
        .input-with-spinners .spin-btn:last-child {
            border-radius: 0 0 3px 0;
        }
        .input-with-spinners .spin-btn:hover {
            background: rgba(79,70,229,0.6);
            color: #fff;
        }
        .input-with-spinners .spin-btn:active {
            background: var(--accent);
        }
        
        /* Toast notifications */
        .transform-toast {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: rgba(239, 68, 68, 0.9);
            color: #fff;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s, transform 0.2s;
            z-index: 100;
        }
        .transform-toast.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-4px);
        }
        .transform-toast.warning {
            background: rgba(251, 191, 36, 0.9);
            color: #000;
        }
        .transform-toast.info {
            background: rgba(79, 70, 229, 0.9);
        }
        .transform-context-panel .xyz-row {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.4rem;
        }
        .transform-context-panel .xyz-row .axis {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.15rem;
        }
        .transform-context-panel .xyz-row .axis label {
            font-size: 0.65rem;
            font-weight: 700;
            width: 10px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .transform-context-panel .xyz-row .axis.x label { color: #ff6b6b; }
        .transform-context-panel .xyz-row .axis.y label { color: #51cf66; }
        .transform-context-panel .xyz-row .axis.z label { color: #339af0; }
        .transform-context-panel .xyz-row .axis .input-with-spinners {
            flex: 1;
            min-width: 0;
        }
        .transform-context-panel .reset-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.9rem;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .transform-context-panel .reset-btn:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
            color: #ff6b6b;
        }
        .transform-context-panel .row-with-reset {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-top: 0.3rem;
        }
        .transform-context-panel .row-with-reset .xyz-row {
            flex: 1;
            margin-bottom: 0;
        }
        .transform-context-panel .children-list {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            max-height: 60px;
            overflow-y: auto;
        }
        .transform-context-panel .children-list .child-item {
            padding: 0.15rem 0;
            cursor: pointer;
        }
        .transform-context-panel .children-list .child-item:hover {
            color: var(--accent);
        }
        
        /* Viewer focus indicator */
        #model-viewer-wrap.viewer-focused {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        #model-viewer-wrap:not(.viewer-focused)::after {
            content: 'Click to enable keyboard shortcuts';
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #888;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #model-viewer-wrap:hover:not(.viewer-focused)::after {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Site Header (injected by header.js) -->
    <div id="site-header"></div>
    
    <main class="container-sm" style="padding-top: 2rem;">
        <!-- Task Card -->
        <div class="card">
            <!-- Task header title (always fully visible) -->
            <h2 data-i18n="task_title" style="margin: 0 0 0.75rem 0;">
                Conversion Progress
            </h2>
            <div id="task-run-state" style="margin: -0.25rem 0 0.75rem; font-size: 0.9rem; color: var(--text-muted);"></div>

            <!-- Admin-only: Input URL + Worker Progress -->
            <div id="admin-input-url-row" class="hidden"
                 style="margin: -0.25rem 0 0.85rem; padding: 0.65rem 0.85rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.14);">
                <div style="display:flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap;">
                    <div style="min-width: 200px; flex: 1;">
                        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">Input URL (admin)</div>
                        <a id="admin-input-url-link" href="#" target="_blank"
                           style="color: var(--accent); text-decoration: none; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">
                            -
                        </a>
                    </div>
                    <button class="btn btn-secondary" id="admin-input-url-copy"
                            style="padding: 0.35rem 0.6rem; font-size: 0.85rem; white-space: nowrap;">
                        Copy
                    </button>
                </div>
                <!-- Worker Progress Page link -->
                <div id="admin-worker-progress-row" class="hidden" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.08);">
                    <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">üîß Worker Progress Page</div>
                    <a id="admin-worker-progress-link" href="#" target="_blank"
                       style="color: #f59e0b; text-decoration: none; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%; font-size: 0.9rem;">
                        -
                    </a>
                </div>
            </div>

            <!-- Header actions row (one line): buttons + status -->
            <div style="display: flex; justify-content: flex-start; align-items: center; gap: 0.6rem; flex-wrap: wrap;">
                <div class="flex gap-2" style="align-items: center; flex-wrap: wrap;">
                    <button class="btn btn-secondary" id="owner-tasks-btn"
                            style="padding: 0.55rem 0.9rem; border-color: var(--warning); color: var(--warning); background: rgba(245, 158, 11, 0.08); white-space: nowrap;">
                        <span aria-hidden="true" style="font-size: 1.8rem; line-height: 1; display: inline-block;">üìã</span>
                        <span data-i18n="btn_owner_tasks" style="display: inline-block;">All tasks</span>
                    </button>
                    <!-- Restart button removed - using SAVE RIG T-POSE button in viewer -->

                    <!-- Status Badge (in header row) -->
                    <div id="status-container" style="white-space: nowrap; display: inline-flex; align-items: center;">
                        <span class="alert alert-info" id="status-badge" style="display: inline-block; margin: 0;">
                    <span id="status-text">Processing...</span>
                </span>
                    </div>
                </div>
            </div>
            
            <!-- Queue Status (compact) -->
            <div class="queue-status-compact mt-3" id="queue-status-compact">
                <img src="/static/images/icons/queue.svg" alt="Queue" class="queue-status-icon" width="20" height="20" style="display: none;">
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-active">-</span>
                    <span class="queue-stat-label" data-i18n="queue_active">Active</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-pending">-</span>
                    <span class="queue-stat-label" data-i18n="queue_pending">In Queue</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-wait">-</span>
                    <span class="queue-stat-label" data-i18n="queue_wait">Est. Wait</span>
                </div>
                <div class="queue-stat">
                    <span class="queue-stat-value" id="queue-servers">-</span>
                    <span class="queue-stat-label" data-i18n="queue_servers">Servers</span>
                </div>
            </div>
            
            <!-- Progress -->
            <div class="progress-container" id="progress-container">
                <div class="progress-percent" id="progress-percent">0%</div>
                <div id="progress-log" class="hidden"
                     style="margin: 0.5rem 0 0.25rem; padding: 0.75rem 1rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.18); cursor: pointer;">
                    <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.75rem;">
                        <div style="font-size: 0.8rem; color: var(--text-muted); white-space: nowrap;">Log</div>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <button id="progress-log-copy" type="button" 
                                    style="padding: 0.25rem 0.5rem; font-size: 0.7rem; border-radius: 4px; 
                                           background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); 
                                           color: var(--text-muted); cursor: pointer;"
                                    onclick="event.stopPropagation();" data-i18n="log_copy">Copy</button>
                            <div id="progress-log-hint" style="font-size: 0.8rem; color: var(--text-muted); white-space: nowrap;">Click to expand</div>
                        </div>
                    </div>
                    <pre id="progress-log-text"
                         style="margin-top: 0.5rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-size: 0.8rem; line-height: 1.35; color: var(--text-secondary); white-space: pre-wrap; word-break: break-word; overflow: hidden; max-height: 3.2em; transition: max-height 0.25s ease;"></pre>
                </div>
                <div id="progress-failure" class="hidden"
                     style="margin: 0.5rem 0; padding: 0.75rem 1rem; border-radius: 8px; 
                            background: rgba(239, 71, 111, 0.15); border: 1px solid rgba(239, 71, 111, 0.3);
                            color: #ef476f; font-size: 0.85rem; font-weight: 500;">
                    <span style="margin-right: 0.5rem;">‚ö†Ô∏è</span>
                    <span id="progress-failure-text"></span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-text">
                    <span><span id="ready-count">0</span> / <span id="total-count">0</span> <span data-i18n="task_files_ready">files ready</span></span>
                    <span id="eta"></span>
                </div>
            </div>

            <!-- Model Parameters -->
            <div id="model-params" class="hidden">
                <div class="section-title">üìä Model Parameters</div>
                <div id="model-params-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                    <!-- 9 tiles will be injected by JS -->
                </div>
            </div>
            
            <!-- Error Message -->
            <div class="alert alert-error hidden mt-3" id="error-container">
                <span id="error-message"></span>
            </div>

            <!-- Video Preview with Task Card Info -->
            <div class="video-preview hidden" id="video-container">
                <div id="video-preview-title" style="font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem;">üé¨ Video Preview</div>
                
                <!-- Video Player with overlay badges -->
                <div id="video-player-wrap" style="position: relative; width: 100%;">
                    <video id="video-player" controls autoplay muted loop playsinline 
                           style="width: 100%; height: auto; max-height: 70vh; object-fit: contain; border-radius: 12px; background: #000; display: block;"></video>
                    
                    <!-- Author overlay - top left -->
                    <a href="#" id="task-author-link" class="task-card-author-overlay hidden"></a>
                    
                    <!-- Badges - top right -->
                    <div id="task-card-badges" style="position: absolute; top: 12px; right: 12px; display: flex; gap: 6px; z-index: 10;">
                        <button class="tc-like" type="button" id="task-like-btn" title="Like">
                            <span>‚ô•</span>
                            <span class="tc-like-count" id="task-like-count">0</span>
                        </button>
                        <span class="tc-badge hidden" id="task-sales-badge" title="Sales">
                            <span>üí∞</span>
                            <span id="task-sales-count">0</span>
                        </span>
                    </div>
                </div>
                <div id="hdrp-renders" class="hidden"
                     style="display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 0.75rem; margin-bottom: 1rem;">
                    <!-- HDRP renders injected by JS -->
                </div>

                <!-- Model Viewer (GLB) -->
                <div id="model-viewer-wrap" class="hidden" style="margin-bottom: 1rem;">
                    <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.75rem; margin-bottom: 0.5rem;">
                        <div style="font-weight: 600; font-size: 1.1rem;">üéÆ 3D Preview</div>
                        <div id="model-viewer-status" style="font-size: 0.85rem; color: var(--text-muted); white-space: nowrap;">Loading...</div>
                </div>
                    <div style="display:flex; gap: 0.5rem; align-items:center; flex-wrap: wrap; margin-bottom: 0.75rem;">
                        <label style="font-size: 0.85rem; color: var(--text-muted);">Animation:</label>
                        <select id="anim-select" class="hidden" style="padding: 0.5rem 0.75rem; border-radius: 10px; background: var(--bg-input); border: 1px solid var(--border); color: var(--text-primary);">
                        </select>
                        <button id="anim-play-btn" class="btn btn-secondary hidden" style="padding: 0.45rem 0.8rem;">Play</button>
                        <button id="anim-pause-btn" class="btn btn-secondary hidden" style="padding: 0.45rem 0.8rem;">Pause</button>
                </div>
                    <!-- Viewer Container (relative for overlay positioning) -->
                    <div id="model-viewer-container" style="position: relative; width: 100%; aspect-ratio: 9/16; max-height: 70vh;">
                        <!-- Three.js Canvas Target -->
                        <div id="model-viewer" style="width: 100%; height: 100%; border-radius: 12px; background: #000; border: 1px solid rgba(255,255,255,0.08); overflow: hidden;"></div>
                        
                        <!-- Viewer Overlay UI (above canvas) -->
                        <div id="viewer-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; border-radius: 12px;">
                            <!-- Left side: Rotation Buttons XYZ (2x larger) -->
                            <div id="rotation-buttons" class="rotation-buttons" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); pointer-events: auto;">
                                <button id="rotate-x-btn" class="rotation-btn x large" title="Rotate X +90¬∞">
                                    <span class="axis">X</span><span>+90¬∞</span>
                                </button>
                                <button id="rotate-y-btn" class="rotation-btn y large" title="Rotate Y +90¬∞">
                                    <span class="axis">Y</span><span>+90¬∞</span>
                                </button>
                                <button id="rotate-z-btn" class="rotation-btn z large" title="Rotate Z +90¬∞">
                                    <span class="axis">Z</span><span>+90¬∞</span>
                                </button>
                            </div>
                            
                            <!-- Bottom center: SAVE RIG T-POSE button -->
                            <div id="save-rig-wrap" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); pointer-events: auto;">
                                <button id="save-rig-btn" class="save-rig-btn" title="Save orientation and restart rigging">
                                    <span data-i18n="btn_save_rig_tpose">üíæ SAVE RIG T-POSE</span>
                                </button>
                            </div>
                            
                            <!-- HIDDEN: Top-left Channel Selector (kept for compatibility) -->
                            <div id="viewer-channel-wrap" style="position: absolute; top: 0.75rem; left: 0.75rem; pointer-events: auto; display: none; flex-direction: column; gap: 0.5rem;">
                                <select id="viewer-channel-select" class="form-select" style="
                                    padding: 0.35rem 0.5rem;
                                    font-size: 0.75rem;
                                    min-width: 120px;
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.15);
                                    backdrop-filter: blur(12px);
                                    color: #fff;
                                    border-radius: 8px;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                ">
                                    <option value="1" selected>PBR (Default)</option>
                                    <option value="2">Ambient Occlusion</option>
                                    <option value="3">Normal Map</option>
                                    <option value="4">Albedo</option>
                                    <option value="5">Metalness</option>
                                    <option value="6">Roughness</option>
                                    <option value="7">Emissive</option>
                                </select>

            </div>
            
                            <!-- Top-center: Version/FPS + Fullscreen only (camera/gizmos/wireframe/default hidden) -->
                            <div id="viewer-camera-wrap" style="position: absolute; top: 0.75rem; left: 50%; transform: translateX(-50%); pointer-events: auto; display: flex; gap: 0.5rem; align-items: center;">
                                <div id="viewer-version" style="font-size: 0.6rem; color: rgba(79,70,229,0.8); font-family: monospace; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; border: 1px solid rgba(79,70,229,0.3); white-space: nowrap;">v63</div>
                                <div id="viewer-fps" style="font-size: 0.65rem; color: rgba(255,255,255,0.4); font-family: monospace; background: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); white-space: nowrap;">-- FPS</div>
                                <!-- HIDDEN: Camera mode button -->
                                <button id="viewer-camera-btn" class="btn btn-secondary" style="
                                    padding: 0.4rem 0.85rem;
                                    font-size: 0.8rem;
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    display: none;
                                    align-items: center;
                                    gap: 0.5rem;
                                    color: #fff;
                                    cursor: pointer;
                                ">
                                    <span style="font-size: 1.1rem;">üì∑</span>
                                    <span id="viewer-camera-label">Orbit</span>
                                    <span style="font-size: 0.7rem; opacity: 0.6;">‚ñº</span>
                                </button>

                                <button id="viewer-fullscreen-btn" class="btn btn-secondary" style="
                                    padding: 0.4rem 0.85rem;
                                    font-size: 0.8rem;
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    display: flex;
                                    align-items: center;
                                    gap: 0.5rem;
                                    color: #fff;
                                    cursor: pointer;
                                " title="Fullscreen (Space)">
                                    <span style="font-size: 1.1rem;">‚õ∂</span>
                                    <span>Fullscreen</span>
                                </button>

                                <!-- HIDDEN: Gizmos button -->
                                <button id="viewer-gizmos-btn" class="btn btn-secondary" title="Toggle Gizmos" style="
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    color: #fff;
                                    padding: 0.4rem 0.6rem;
                                    font-size: 1.1rem;
                                    display: none;
                                    align-items: center;
                                    justify-content: center;
                                    width: 36px;
                                    height: 36px;
                                    cursor: pointer;
                                ">ü™Ñ</button>

                                <!-- HIDDEN: Wireframe button -->
                                <button id="viewer-wireframe-btn" class="btn btn-secondary" title="Wireframe Overlay" style="
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    color: #fff;
                                    padding: 0.4rem 0.6rem;
                                    font-size: 1.1rem;
                                    display: none;
                                    align-items: center;
                                    justify-content: center;
                                    width: 36px;
                                    height: 36px;
                                    cursor: pointer;
                                ">üî≤</button>

                                <!-- HIDDEN: Default toggle -->
                                <button id="viewer-default-toggle" class="btn btn-secondary" title="Default/Saved Comparison" style="
                                    background: rgba(0,0,0,0.75);
                                    border: 1px solid rgba(255,255,255,0.2);
                                    backdrop-filter: blur(8px);
                                    color: #fff;
                                    padding: 0.4rem 0.6rem;
                                    font-size: 1.1rem;
                                    display: none;
                                    align-items: center;
                                    justify-content: center;
                                    width: 36px;
                                    height: 36px;
                                    cursor: pointer;
                                ">üè†</button>
            </div>
            
                            <!-- Right side: View Mode Selector + Zoom (moved lower) -->
                            <div id="viewer-rigtype-wrap" style="position: absolute; top: 50%; right: 0.75rem; transform: translateY(-50%); pointer-events: auto; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end;">
                                <!-- View Mode Buttons: T-Pose / RIG / Animation -->
                                <div class="view-mode-selector" id="view-mode-selector">
                                    <button id="view-mode-tpose" class="active" title="T-Pose Mode">T-Pose</button>
                                    <button id="view-mode-rig" title="RIG Mode (show spheres)">RIG</button>
                                    <button id="view-mode-anim" title="Animation Mode">Anim</button>
                                </div>
                                <!-- Hidden rig type select (moved to settings) -->
                                <select id="viewer-rigtype-select" class="form-select hidden" style="
                                    padding: 0.35rem 0.5rem;
                                    font-size: 0.75rem;
                                    min-width: 130px;
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.15);
                                    backdrop-filter: blur(12px);
                                    color: #fff;
                                    border-radius: 8px;
                                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                                ">
                                    <option value="char" selected>Mode: Character</option>
                                    <option value="rigidbodies">Mode: Rigid Bodies</option>
                                    <option value="solid">Mode: Solid Object</option>
                                    <option value="animations">Mode: Animations</option>
                                </select>
                                <!-- HIDDEN: Zoom buttons -->
                                <div style="display: none; gap: 0.3rem;">
                                    <button id="viewer-zoom-in-btn" title="Zoom In" style="
                                        background: rgba(0,0,0,0.5);
                                        border: 1px solid rgba(255,255,255,0.15);
                                        backdrop-filter: blur(8px);
                                        color: #fff;
                                        width: 32px;
                                        height: 32px;
                                        border-radius: 6px;
                                        cursor: pointer;
                                        font-size: 1rem;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                    ">+</button>
                                    <button id="viewer-zoom-out-btn" title="Zoom Out" style="
                                        background: rgba(0,0,0,0.5);
                                        border: 1px solid rgba(255,255,255,0.15);
                                        backdrop-filter: blur(8px);
                                        color: #fff;
                                        width: 32px;
                                        height: 32px;
                                        border-radius: 6px;
                                        cursor: pointer;
                                        font-size: 1rem;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                    ">‚àí</button>
                                </div>
                            </div>
            
                            <!-- Bottom-left: Settings Toggle + Lighting Sliders -->
                            <div id="viewer-settings-area" style="position: absolute; bottom: 0.75rem; left: 0.75rem; pointer-events: auto; display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;">
                                <!-- Settings Toggle Button -->
                                <button id="settings-toggle-btn" class="settings-toggle-btn" title="Toggle Settings (‚öôÔ∏è‚òÄÔ∏è)">
                                    <span class="strike">‚öôÔ∏è</span>
                                    <span class="strike">‚òÄÔ∏è</span>
                                </button>
                                
                            <!-- Lighting Panel (hidden by default) -->
                            <div id="viewer-lighting-wrap" class="hidden" style="pointer-events: auto;">
                                <div style="
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.1);
                                    backdrop-filter: blur(12px);
                                    border-radius: 10px;
                                    min-width: 180px;
                                    overflow: hidden;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                ">
                                    <!-- Header (Collapsible trigger) -->
                                    <div id="lighting-panel-header" style="
                                        padding: 0.65rem 0.8rem;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        justify-content: space-between;
                                        user-select: none;
                                        background: rgba(255,255,255,0.03);
                                    ">
                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.4rem;">
                                            <span>üîÜ Lighting</span>
                                            <span id="lighting-panel-arrow" style="font-size: 0.6rem; opacity: 0.5; transition: transform 0.2s;">‚ñº</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.4rem;">
                                            <button id="ao-rebake-btn" title="Rebake AO" style="
                                                background: rgba(79, 70, 229, 0.3);
                                                border: 1px solid rgba(79, 70, 229, 0.5);
                                                border-radius: 4px;
                                                color: #fff;
                                                cursor: pointer;
                                                padding: 2px 6px;
                                                font-size: 0.6rem;
                                                pointer-events: auto;
                                            " onclick="event.stopPropagation()">AO</button>
                                            <div style="position: relative; width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3); overflow: hidden; cursor: pointer; pointer-events: auto;" id="bg-color-preview" onclick="event.stopPropagation()">
                                                <input type="color" id="bg-color-picker" style="position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; cursor: pointer; border: none; padding: 0; background: none;">
                                            </div>
                                            <button class="eye-dropper-btn" data-target="bg-color-picker" title="Pick color from screen" style="
                                                background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 0; font-size: 0.8rem; pointer-events: auto;
                                            " onclick="event.stopPropagation()">üß™</button>
                                        </div>
                                    </div>

                                    <!-- Panel Content -->
                                    <div id="lighting-panel-content" class="hidden" style="padding: 0 0.8rem 0.65rem 0.8rem;">
                                        <!-- Main Light -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Light</label>
                                        <input type="range" id="light-main-slider" min="0" max="10" step="0.01" value="3" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #ffd700);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-main-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">3.0</span>
                                    </div>
                                    <!-- Environment -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Env</label>
                                        <input type="range" id="light-env-slider" min="0" max="10" step="0.01" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #87ceeb);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-env-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.0</span>
                                    </div>
                                    <!-- Reflection -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Reflect</label>
                                        <input type="range" id="light-reflect-slider" min="0" max="10" step="0.01" value="3" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #333, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="light-reflect-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">3.0</span>
                                    </div>

                                    <!-- Bloom Strength -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Bloom</label>
                                        <input type="range" id="bloom-strength-slider" min="0" max="1" step="0.01" value="0" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-strength-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.0</span>
                                    </div>
                                    <!-- Bloom Threshold -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Threshold</label>
                                        <input type="range" id="bloom-threshold-slider" min="0" max="1" step="0.05" value="0.8" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-threshold-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.8</span>
                                    </div>
                                    <!-- Bloom Radius -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Radius</label>
                                        <input type="range" id="bloom-radius-slider" min="0" max="1" step="0.05" value="0.4" style="
                                            flex: 1; height: 4px; border-radius: 2px; background: linear-gradient(to right, #333, #fff); cursor: pointer; accent-color: var(--accent);
                                        ">
                                        <span id="bloom-radius-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.4</span>
                                    </div>

                                    <!-- Ground Settings -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Ground</label>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="ground-color-picker" value="#222222" style="
                                                    padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="ground-color-picker" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                            <input type="range" id="ground-size-slider" min="0.1" max="100" step="0.01" value="100" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="ground-size-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 20px; text-align: right;">100.000</span>
                                        </div>
                                    </div>

                                    <!-- Shadow Settings -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Shadow Soft</label>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                                            <input type="range" id="shadow-radius-slider" min="0" max="10" step="0.01" value="1" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="shadow-radius-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 20px; text-align: right;">1.000</span>
                                        </div>
                                    </div>

                                    <!-- Day/Night & Sun -->
                                    <div style="margin-top: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Time/Preset</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="range" id="lighting-time-slider" min="0" max="24" step="0.01" value="12" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <select id="lighting-preset-select" style="background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff; font-size: 0.65rem; padding: 1px 2px; outline: none;">
                                                    <option value="day" style="background: #222;">Day</option>
                                                    <option value="night" style="background: #222;">Night</option>
                                                    <option value="sunset" style="background: #222;">Sunset</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Sun Rot/Inc</label>
                                            <div style="display: flex; gap: 0.3rem; flex: 1;">
                                                <input type="range" id="sun-rotation-slider" min="0" max="360" step="0.1" value="45" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Rotation Y">
                                                <input type="range" id="sun-inclination-slider" min="0" max="90" step="0.1" value="45" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Inclination">
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Ambient</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="color" id="ambient-color-picker" value="#ffffff" style="padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;">
                                                <input type="range" id="ambient-intensity-slider" min="0" max="2" step="0.01" value="0.3" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Fog</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem; flex: 1;">
                                                <input type="color" id="fog-color-picker" value="#000000" style="padding: 0; border: none; width: 20px; height: 18px; background: none; cursor: pointer;">
                                                <input type="range" id="fog-density-slider" min="0" max="1" step="0.01" value="0" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);" title="Fog Density">
                                                <span id="fog-density-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 35px; text-align: right;">0.00</span>
                                            </div>
                                        </div>
                                        
                                        <!-- AO Bake Settings -->
                                        <div style="margin-top: 0.6rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                            <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.4rem; text-transform: uppercase; letter-spacing: 0.05em;">AO Bake</div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Samples</label>
                                                <input type="range" id="ao-samples-slider" min="8" max="64" step="8" value="32" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-samples-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 20px; text-align: right;">32</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Radius</label>
                                                <input type="range" id="ao-radius-slider" min="0.05" max="0.5" step="0.01" value="0.15" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-radius-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 30px; text-align: right;">0.15</span>
                                            </div>
                                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                <label style="font-size: 0.65rem; color: rgba(255,255,255,0.5); min-width: 50px;">Intensity</label>
                                                <input type="range" id="ao-intensity-slider" min="0.5" max="3.0" step="0.1" value="1.5" style="flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);">
                                                <span id="ao-intensity-val" style="font-size: 0.65rem; color: rgba(255,255,255,0.6); min-width: 25px; text-align: right;">1.5</span>
                                            </div>
                                        </div>
                                    </div>
                                    </div>
                                </div>
                            </div>
                            </div> <!-- End viewer-settings-area -->

                            <!-- Bottom-right: Texture Adjustments (hidden by default, controlled by settings toggle) -->
                            <div id="viewer-adjustments-wrap" class="hidden" style="position: absolute; bottom: 0.75rem; right: 0.75rem; pointer-events: auto;">
                                <div style="
                                    background: rgba(0,0,0,0.4);
                                    border: 1px solid rgba(255,255,255,0.1);
                                    backdrop-filter: blur(12px);
                                    border-radius: 10px;
                                    min-width: 180px;
                                    overflow: hidden;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                ">
                                    <!-- Header (Collapsible trigger) -->
                                    <div id="adjustments-panel-header" style="
                                        padding: 0.65rem 0.8rem;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        justify-content: space-between;
                                        user-select: none;
                                        background: rgba(255,255,255,0.03);
                                    ">
                                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 0.4rem;">
                                            <span>üé® Adjustments</span>
                                            <span id="adjustments-panel-arrow" style="font-size: 0.6rem; opacity: 0.5; transition: transform 0.2s;">‚ñº</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.35rem;" onclick="event.stopPropagation()">
                                            <button id="adj-sync-view-btn" title="Sync view with channel" style="
                                                background: rgba(255,255,255,0.1);
                                                border: 1px solid rgba(255,255,255,0.2);
                                                border-radius: 4px;
                                                color: #fff;
                                                font-size: 0.75rem;
                                                padding: 0px 4px;
                                                cursor: pointer;
                                                outline: none;
                                                height: 18px;
                                                display: flex;
                                                align-items: center;
                                                transition: all 0.2s;
                                            ">üëÅÔ∏è</button>
                                            <select id="adj-target-channel" style="
                                                background: rgba(0,0,0,0.5);
                                                border: 1px solid rgba(255,255,255,0.2);
                                                border-radius: 4px;
                                                color: #fff;
                                                font-size: 0.65rem;
                                                padding: 1px 4px;
                                                cursor: pointer;
                                                outline: none;
                                            ">
                                                <option value="albedo" style="background: #222;">Albedo</option>
                                                <option value="ao" style="background: #222;">AO</option>
                                                <option value="normal" style="background: #222;">Normal</option>
                                                <option value="roughness" style="background: #222;">Roughness</option>
                                                <option value="metalness" style="background: #222;">Metalness</option>
                                                <option value="emissive" style="background: #222;">Emissive</option>
                                            </select>
                                        </div>
                                    </div>

                                    <!-- Panel Content -->
                                    <div id="adjustments-panel-content" class="hidden" style="padding: 0 0.8rem 0.65rem 0.8rem;">
                                        <!-- Brightness -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Bright</label>
                                        <input type="range" id="adj-bright-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #000, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-bright-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.00</span>
                                    </div>
                                    <!-- Contrast -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Contrast</label>
                                        <input type="range" id="adj-contrast-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #444, #fff);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-contrast-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.00</span>
                                    </div>
                                    <!-- Saturation -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem;">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Satur</label>
                                        <input type="range" id="adj-satur-slider" min="0" max="5" step="0.001" value="1" style="
                                            flex: 1;
                                            height: 4px;
                                            border-radius: 2px;
                                            background: linear-gradient(to right, #888, #f00, #ff0, #0f0, #0ff, #00f, #f0f);
                                            cursor: pointer;
                                            accent-color: var(--accent);
                                        ">
                                        <span id="adj-satur-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">1.0</span>
                                    </div>

                                    <!-- Mode -->
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.6rem; padding-top: 0.4rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Mode</label>
                                        <select id="adj-mode-select" style="
                                            flex: 1;
                                            background: rgba(0,0,0,0.5);
                                            border: 1px solid rgba(255,255,255,0.2);
                                            border-radius: 4px;
                                            color: #fff;
                                            font-size: 0.65rem;
                                            padding: 2px 4px;
                                            cursor: pointer;
                                            outline: none;
                                        ">
                                            <option value="0" style="background: #222;">Default</option>
                                            <option value="1" style="background: #222;">Emissive Mask</option>
                                        </select>
                                    </div>

                                    <!-- Mask Group -->
                                    <div id="adj-mask-group" class="hidden">
                                        <!-- Mask Color -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Mask Col</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="adj-mask-color" value="#ffffff" style="
                                                    padding: 0;
                                                    border: none;
                                                    width: 30px;
                                                    height: 18px;
                                                    background: none;
                                                    cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="adj-mask-color" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                        </div>
                                        <!-- Softness -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Softness</label>
                                                <input type="range" id="adj-soft-slider" min="0" max="1" step="0.001" value="0.5" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="adj-soft-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">0.50</span>
                                        </div>
                                        <!-- Emissive Mult -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Emis Mult</label>
                                            <input type="range" id="adj-em-mult-slider" min="0" max="50" step="0.001" value="2" style="
                                                flex: 1; height: 4px; cursor: pointer; accent-color: var(--accent);
                                            ">
                                            <span id="adj-em-mult-val" style="font-size: 0.7rem; color: rgba(255,255,255,0.7); min-width: 28px; text-align: right;">2.0</span>
                                        </div>

                                        <!-- Invert Mask -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Invert</label>
                                            <input type="checkbox" id="adj-invert-mask" style="cursor: pointer;">
                                        </div>

                                        <!-- Blend Color -->
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label style="font-size: 0.7rem; color: rgba(255,255,255,0.6); min-width: 55px;">Blend Col</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="color" id="adj-blend-color" value="#ffffff" style="
                                                    padding: 0;
                                                    border: none;
                                                    width: 30px;
                                                    height: 18px;
                                                    background: none;
                                                    cursor: pointer;
                                                ">
                                                <button class="eye-dropper-btn" data-target="adj-blend-color" title="Pick color from screen" style="
                                                    background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 2px; font-size: 0.8rem;
                                                ">üß™</button>
                                            </div>
                                        </div>
                                    </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- HIDDEN: QWER Transform Toolbar (Bottom center) -->
                            <div id="viewer-transform-wrap" style="position: absolute; bottom: 0.75rem; left: 50%; transform: translateX(-50%); pointer-events: auto; display: none; gap: 0.5rem; align-items: flex-end;">
                                <!-- QWER Mode Buttons -->
                                <div class="qwer-toolbar" id="qwer-toolbar">
                                    <button id="transform-reset-btn" title="Reset to Origin (0,0,0)" style="background: rgba(239,71,111,0.2); border-color: rgba(239,71,111,0.3);">
                                        <span class="icon">‚äô</span>
                                        <span class="key">0</span>
                                    </button>
                                    <button id="transform-select-btn" class="active" title="Select Mode (Q)">
                                        <span class="icon">üëÜ</span>
                                        <span class="key">Q</span>
                                    </button>
                                    <button id="transform-move-btn" title="Move Mode (W)">
                                        <span class="icon">‚ú•</span>
                                        <span class="key">W</span>
                                    </button>
                                    <button id="transform-rotate-btn" title="Rotate Mode (E)">
                                        <span class="icon">‚Üª</span>
                                        <span class="key">E</span>
                                    </button>
                                    <button id="transform-scale-btn" title="Scale Mode (R)">
                                        <span class="icon">‚§¢</span>
                                        <span class="key">R</span>
                                    </button>
                                </div>
                                
                                <!-- Context Panel (changes based on QWER mode) -->
                                <div class="transform-context-panel" id="transform-context-panel">
                                    <!-- Q: Select Mode Context -->
                                    <div id="context-select" class="context-content">
                                        <div class="panel-title selection-title"><span class="title-icon">üéØ</span> Selection</div>
                                        <div class="info-row">
                                            <label>Name</label>
                                            <span class="value" id="ctx-select-name">‚Äî</span>
                                        </div>
                                        <div class="info-row">
                                            <label>Parent</label>
                                            <span class="value" id="ctx-select-parent">‚Äî</span>
                                        </div>
                                        <div class="info-row" style="flex-direction: column; align-items: flex-start;">
                                            <label style="margin-bottom: 0.2rem;">Children</label>
                                            <div class="children-list" id="ctx-select-children">‚Äî</div>
                                        </div>
                                        <button class="reset-btn" id="ctx-select-reset" title="Deselect">‚úï</button>
                                    </div>
                                    
                                    <!-- W: Move Mode Context -->
                                    <div id="context-move" class="context-content hidden">
                                        <div class="panel-title position-title"><span class="title-icon">‚Üî</span> Position</div>
                                        <div class="xyz-row">
                                            <div class="axis x">
                                                <label>X</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-pos-x" value="0" step="0.1">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis y">
                                                <label>Y</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-pos-y" value="0" step="0.1">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis z">
                                                <label>Z</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-pos-z" value="0" step="0.1">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="info-row" style="margin-top: 0.3rem;">
                                            <label>Snap</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="checkbox" id="ctx-snap-move" checked>
                                                <input type="number" id="snap-move" value="0.1" min="0.01" step="0.01" style="width: 55px;">
                                            </div>
                                        </div>
                                        <button class="reset-btn" id="ctx-move-reset" title="Reset to 0, 0, 0">‚Ü∫</button>
                                    </div>

                                    <!-- E: Rotate Mode Context -->
                                    <div id="context-rotate" class="context-content hidden">
                                        <div class="panel-title rotation-title"><span class="title-icon">üîÑ</span> Rotation</div>
                                        <div class="xyz-row">
                                            <div class="axis x">
                                                <label>X</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-rot-x" value="0" step="90">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis y">
                                                <label>Y</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-rot-y" value="0" step="90">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis z">
                                                <label>Z</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-rot-z" value="0" step="90">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="info-row" style="margin-top: 0.3rem;">
                                            <label>Snap</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="checkbox" id="ctx-snap-rotate" checked>
                                                <input type="number" id="snap-rotate" value="15" min="1" step="1" style="width: 55px;">¬∞
                                            </div>
                                        </div>
                                        <button class="reset-btn" id="ctx-rotate-reset" title="Reset to 0¬∞, 0¬∞, 0¬∞">‚Ü∫</button>
                                    </div>

                                    <!-- R: Scale Mode Context -->
                                    <div id="context-scale" class="context-content hidden">
                                        <div class="panel-title scale-title"><span class="title-icon">‚á≤</span> Scale</div>
                                        <div class="xyz-row">
                                            <div class="axis x">
                                                <label>X</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-scale-x" value="1" step="0.1" min="0.01">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis y">
                                                <label>Y</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-scale-y" value="1" step="0.1" min="0.01">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="axis z">
                                                <label>Z</label>
                                                <div class="input-with-spinners">
                                                    <input type="number" id="ctx-scale-z" value="1" step="0.1" min="0.01">
                                                    <div class="spinners">
                                                        <button class="spin-btn" data-dir="up">‚ñ≤</button>
                                                        <button class="spin-btn" data-dir="down">‚ñº</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="info-row" style="margin-top: 0.3rem;">
                                            <label>Snap</label>
                                            <div style="display: flex; align-items: center; gap: 0.3rem;">
                                                <input type="checkbox" id="ctx-snap-scale" checked>
                                                <input type="number" id="snap-scale" value="0.1" min="0.01" step="0.01" style="width: 55px;">
                                            </div>
                                        </div>
                                        <button class="reset-btn" id="ctx-scale-reset" title="Reset to 1, 1, 1">‚Ü∫</button>
                                    </div>
                                    
                                    <!-- Toast notification -->
                                    <div class="transform-toast" id="transform-toast"></div>
                                </div>
                            </div>
                            
                            <!-- HIDDEN: Hierarchy Navigator (Left center) -->
                            <div id="viewer-hierarchy-wrap" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); pointer-events: auto; display: none; flex-direction: column; gap: 0.5rem;">
                                <div class="hierarchy-nav" id="hierarchy-nav">
                                    <button id="hierarchy-up-btn" title="Go to parent (Backspace)" disabled>‚Üë</button>
                                    <span class="current-level" id="hierarchy-current">Root</span>
                                    <button id="hierarchy-down-btn" title="Enter children (Space)">‚Üì</button>
                                </div>
                                
                                <!-- T-Pose Toggle with Color/Opacity -->
                                <div class="tpose-toggle" style="flex-direction: column; align-items: stretch; gap: 0.4rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <button id="tpose-toggle-btn" title="Toggle T-Pose Reference (T)">üßç</button>
                                        <span class="label">T-Pose<br><small style="opacity: 0.6;">(T)</small></span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.65rem;">
                                        <label style="color: rgba(255,255,255,0.5); width: 35px;">Color</label>
                                        <input type="color" id="tpose-color" value="#00ffff" 
                                            style="width: 24px; height: 20px; padding: 0; border: 1px solid rgba(255,255,255,0.2); border-radius: 3px; cursor: pointer;">
                                        <label style="color: rgba(255,255,255,0.5); margin-left: 0.3rem;">Œ±</label>
                                        <input type="range" id="tpose-opacity" min="0.1" max="1" step="0.1" value="0.5"
                                            style="width: 50px; height: 4px; cursor: pointer;">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Selection Info (Top info bar) -->
                            <div id="viewer-selection-info" style="position: absolute; top: 50px; left: 50%; transform: translateX(-50%); pointer-events: none; opacity: 0; transition: opacity 0.2s;">
                                <div style="background: rgba(0,0,0,0.8); border: 1px solid rgba(79,70,229,0.5); border-radius: 6px; padding: 0.4rem 0.8rem; font-size: 0.75rem; color: #fff; backdrop-filter: blur(8px);">
                                    <span id="selection-name">No selection</span>
                                    <span id="selection-type" style="opacity: 0.6; margin-left: 0.5rem;"></span>
                                </div>
                            </div>
                            
                            <!-- Loading Overlay -->
                            <div id="viewer-loading-overlay" class="viewer-loading-overlay">
                                <div class="loading-title">
                                    <div class="spinner"></div>
                                    <span id="loading-title-text">Loading Models</span>
                                </div>
                                <div class="loading-status" id="loading-status-text">Preparing...</div>
                                <div class="loading-progress-wrap">
                                    <div class="loading-progress-bar" id="loading-progress-bar"></div>
                                </div>
                                <div class="loading-percent" id="loading-percent">0%</div>
                                <div class="loading-queue" id="loading-queue">
                                    <!-- Queue items will be added dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Viewer Controls Row (removed - using SAVE RIG T-POSE button inside viewer) -->
            </div>
            </div>
            
            <div class="alert alert-info hidden mt-3" id="video-pending">
                <span data-i18n="task_video_pending">Video is being generated...</span>
            </div>
            
            <!-- Actions removed (buttons moved into header) -->
        </div>
        
        <!-- Files List -->
        <div class="card mt-3" id="downloads-card">
            <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                <h3 class="card-title">Downloads (<span id="files-count">0</span>)</h3>
                <button id="telegram-share-btn" class="telegram-share-btn" onclick="TelegramApp.shareTask(TaskUI.taskId)" style="display: none;">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69.01-.03.01-.14-.07-.2-.08-.06-.19-.04-.27-.02-.12.03-1.99 1.27-5.62 3.72-.53.36-1.01.54-1.44.53-.47-.01-1.38-.27-2.06-.49-.83-.27-1.49-.42-1.43-.88.03-.24.37-.49 1.02-.75 4-1.74 6.67-2.89 8.02-3.44 3.82-1.58 4.62-1.86 5.14-1.86.11 0 .37.03.53.17.14.12.18.28.2.45-.01.07.01.23-.01.35z"/></svg>
                    Share
                </button>
            </div>
            <ul class="file-list" id="file-list"
                style="max-height: none; overflow: hidden; display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 0.75rem;">
                <!-- Skeleton loading -->
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 200px;"></div>
                </li>
                <li class="file-item">
                    <div class="skeleton skeleton-text" style="width: 180px;"></div>
                </li>
            </ul>
        </div>
        
        <!-- Additional Content (Textures) -->
        <div class="card mt-3" id="additional-content-section" style="display: none;">
            <div class="card-header">
                <h3 class="card-title">üñºÔ∏è Additional Content</h3>
            </div>
            <div id="texture-gallery" class="texture-gallery"></div>
        </div>
    </main>

    <!-- Owner Tasks Modal -->
    <div id="owner-tasks-modal" class="hidden" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 2rem;">
        <div class="card" style="min-width: 900px; max-width: 1100px; max-height: 90vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div>
                    <h3 id="owner-tasks-title">All tasks</h3>
                    <p style="color: var(--text-muted); margin-top: 0.5rem;" id="owner-tasks-subtitle"></p>
                </div>
                <button class="btn btn-ghost" id="owner-tasks-close" style="padding: 0.5rem;">‚úï</button>
            </div>

            <div style="overflow-x: auto; flex: 1; min-height: 0;">
                <table class="admin-table">
                    <thead>
                        <tr>
                            <th>Preview</th>
                            <th>ID</th>
                            <th>Status</th>
                            <th>Progress</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="owner-tasks-table">
                        <tr><td colspan="6" style="text-align:center; color: var(--text-muted);">Loading...</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="flex justify-between items-center mt-3" id="owner-tasks-pagination">
                <span id="owner-tasks-pagination-info" style="color: var(--text-muted); font-size: 0.875rem;"></span>
                <div class="flex gap-1">
                    <button class="btn btn-secondary" id="owner-tasks-prev" disabled>‚Üê Prev</button>
                    <button class="btn btn-secondary" id="owner-tasks-next" disabled>Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal (HDRP renders) -->
    <div id="image-preview-modal" class="hidden" style="position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; z-index: 1100; padding: 1.5rem;">
        <div style="position: relative; max-width: 95vw; max-height: 95vh;">
            <button class="btn btn-ghost" id="image-preview-close"
                    style="position: absolute; top: -0.25rem; right: -0.25rem; padding: 0.5rem; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.12);">
                ‚úï
            </button>
            <img id="image-preview-img" alt="preview"
                 style="display: block; max-width: 95vw; max-height: 95vh; width: auto; height: auto; border-radius: 12px; background: #000; border: 1px solid rgba(255,255,255,0.08);">
        </div>
    </div>
    
    <!-- Site Footer (injected by footer.js) -->
    <div id="site-footer"></div>

    <!-- Scripts -->
    <script src="/static/js/i18n.js"></script>
    <script src="/static/js/footer.js"></script>
    <script>
        const TaskPage = {
            taskId: null,
            pollInterval: null,
            task: null,
            ownerTasksPage: 1,
            ownerTasksPerPage: 12,
            ownerTasksTotal: 0,
            // Visual progress derived from progress log (does NOT change backend/DB state)
            lastVisualProgress: 0,
            lastLogLineCount: 0,
            // Cache for file list to avoid unnecessary re-renders
            lastFileListHash: null,
            
            async init() {
                // Init i18n
                await I18n.init();
                
                // Setup theme
                this.setupTheme();
                
                // Get task ID from URL (sanitize to handle malformed URLs like ?id=xxx?mode=webapp)
                const params = new URLSearchParams(window.location.search);
                const rawId = params.get('id') || '';
                this.taskId = rawId.split('?')[0];
                
                // Check webapp mode
                this.isWebAppMode = params.get('mode') === 'webapp';
                if (this.isWebAppMode) {
                    document.body.classList.add('webapp-mode');
                    // Init Telegram Web App if available
                    if (window.Telegram?.WebApp) {
                        window.Telegram.WebApp.ready();
                        window.Telegram.WebApp.expand();
                    }
                }
                
                if (!this.taskId) {
                    this.showError('No task ID provided');
                    return;
                }
                
                // Expose for onclick handlers
                window.TaskUI = this;
                
                // Load purchase state
                await this.loadPurchaseState();
                
                // Start polling
                await this.fetchTask();
                this.pollInterval = setInterval(() => this.fetchTask(), 2000);
                
                // Load task card info (likes, sales, author)
                await this.loadCardInfo();
                this.setupLikeButton();
                
                // Load queue status (skip in webapp mode)
                if (!this.isWebAppMode) {
                    this.loadQueueStatus();
                    setInterval(() => this.loadQueueStatus(), 10000);
                }
                
                // Setup buttons
                this.setupButtons();

                // Progress log polling (every 10s while page is open)
                this.startProgressLogPolling();
            },
            
            setupTheme() {
                const toggle = document.getElementById('theme-toggle');
                const savedTheme = localStorage.getItem('autorig_theme') || 'dark';
                document.documentElement.setAttribute('data-theme', savedTheme);
                toggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                
                toggle.addEventListener('click', () => {
                    const current = document.documentElement.getAttribute('data-theme');
                    const newTheme = current === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', newTheme);
                    localStorage.setItem('autorig_theme', newTheme);
                    toggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                });
            },
            
            async fetchTask() {
                try {
                    const response = await fetch(`/api/task/${this.taskId}`);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            this.showError('Task not found');
                            this.stopPolling();
                        }
                        return;
                    }
                    
                    this.task = await response.json();
                    this.updateUI();
                    
                    // Stop polling when done or error
                    if (this.task.status === 'done' || this.task.status === 'error') {
                        this.stopPolling();
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                }
            },
            
            cardInfo: null,
            
            async loadCardInfo() {
                try {
                    const response = await fetch(`/api/task/${this.taskId}/card`);
                    if (!response.ok) return;
                    
                    this.cardInfo = await response.json();
                    this.updateCardUI();
                } catch (error) {
                    console.error('Failed to load card info:', error);
                }
            },
            
            updateCardUI() {
                const info = this.cardInfo;
                if (!info) return;
                
                // Update like count and state
                const likeBtn = document.getElementById('task-like-btn');
                const likeCount = document.getElementById('task-like-count');
                if (likeBtn && likeCount) {
                    likeCount.textContent = String(info.like_count || 0);
                    if (info.liked_by_me) {
                        likeBtn.classList.add('liked');
                    } else {
                        likeBtn.classList.remove('liked');
                    }
                }
                
                // Update sales count (hide if 0)
                const salesBadge = document.getElementById('task-sales-badge');
                const salesCount = document.getElementById('task-sales-count');
                if (salesBadge && salesCount) {
                    const count = info.sales_count || 0;
                    salesCount.textContent = String(count);
                    if (count > 0) {
                        salesBadge.classList.remove('hidden');
                    } else {
                        salesBadge.classList.add('hidden');
                    }
                }
                
                // Update author overlay (top left)
                const authorLink = document.getElementById('task-author-link');
                if (authorLink && info.author_email) {
                    // Show only username part (hide @ and domain)
                    const email = info.author_email;
                    const atIndex = email.indexOf('@');
                    const authorDisplay = info.author_nickname || (atIndex > 0 ? email.substring(0, atIndex) : email);
                    
                    authorLink.textContent = authorDisplay;
                    authorLink.href = `/gallery?author=${encodeURIComponent(info.author_email)}`;
                    authorLink.title = info.author_email;
                    authorLink.classList.remove('hidden');
                }
            },
            
            setupLikeButton() {
                const likeBtn = document.getElementById('task-like-btn');
                if (!likeBtn) return;
                
                likeBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check auth
                    const userInfo = document.getElementById('user-info');
                    const isAuthed = userInfo && !userInfo.classList.contains('hidden');
                    if (!isAuthed) {
                        window.location.href = '/auth/login';
                        return;
                    }
                    
                    try {
                        const r = await fetch(`/api/gallery/${this.taskId}/like`, { method: 'POST' });
                        if (r.status === 401) {
                            window.location.href = '/auth/login';
                            return;
                        }
                        const d = await r.json();
                        likeBtn.classList.toggle('liked', !!d.liked_by_me);
                        const cnt = document.getElementById('task-like-count');
                        if (cnt) cnt.textContent = String(d.like_count ?? 0);
                        
                        // Update local cardInfo
                        if (this.cardInfo) {
                            this.cardInfo.like_count = d.like_count;
                            this.cardInfo.liked_by_me = d.liked_by_me;
                        }
                    } catch (err) {
                        console.error('Like failed:', err);
                    }
                });
            },
            
            updateUI() {
                const task = this.task;
                
                // Status
                const statusBadge = document.getElementById('status-badge');
                const statusText = document.getElementById('status-text');
                
                statusBadge.className = 'alert';
                if (task.status === 'done') {
                    statusBadge.classList.add('alert-success');
                    statusText.textContent = t('task_status_done');
                    // Show Telegram share button when task is done
                    const shareBtn = document.getElementById('telegram-share-btn');
                    if (shareBtn) shareBtn.style.display = 'flex';
                    // Haptic feedback for Telegram Web App
                    if (window.TelegramApp) TelegramApp.hapticFeedback('success');
                } else if (task.status === 'error') {
                    statusBadge.classList.add('alert-error');
                    statusText.textContent = t('task_status_error');
                    if (window.TelegramApp) TelegramApp.hapticFeedback('error');
                } else if (task.status === 'processing') {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_processing');
                } else {
                    statusBadge.classList.add('alert-info');
                    statusText.textContent = t('task_status_created');
                }
                
                // Hide progress blocks when task is done
                if (task.status === 'done') {
                    document.getElementById('queue-status-compact')?.classList.add('hidden');
                    document.getElementById('progress-container')?.classList.add('hidden');
                }
                
                // Title helper: started vs queued
                const runStateEl = document.getElementById('task-run-state');
                if (runStateEl) {
                    const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                    const isRu = lang.startsWith('ru');
                    let stateText = '';
                    // We no longer rely on worker_api/guid for non-admin views (workers must be hidden).
                    if (task.status === 'processing') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–¥–∞—á–∞ –∑–∞–ø—É—â–µ–Ω–∞' : 'Conversion Progress ‚Äî task is running';
                    else if (task.status === 'created') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–¥–∞—á–∞ –≤ –æ—á–µ—Ä–µ–¥–∏' : 'Conversion Progress ‚Äî task is queued';
                    else if (task.status === 'done') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –∑–∞–≤–µ—Ä—à–µ–Ω–æ' : 'Conversion Progress ‚Äî completed';
                    else if (task.status === 'error') stateText = isRu ? '–ü—Ä–æ–≥—Ä–µ—Å—Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ‚Äî –æ—à–∏–±–∫–∞' : 'Conversion Progress ‚Äî error';
                    runStateEl.textContent = stateText;
                }

                // Admin-only: Input URL block (visible only when API returns input_url)
                const adminRow = document.getElementById('admin-input-url-row');
                const adminLink = document.getElementById('admin-input-url-link');
                const adminCopy = document.getElementById('admin-input-url-copy');
                const adminWorkerRow = document.getElementById('admin-worker-progress-row');
                const adminWorkerLink = document.getElementById('admin-worker-progress-link');
                if (adminRow && adminLink && adminCopy) {
                    const inputUrl = task && task.input_url ? String(task.input_url) : '';
                    if (inputUrl) {
                        adminRow.classList.remove('hidden');
                        adminLink.href = inputUrl;
                        adminLink.textContent = inputUrl;
                        adminLink.title = inputUrl;
                        
                        // Worker Progress Page link (admin)
                        const progressPage = task && task.progress_page ? String(task.progress_page) : '';
                        if (progressPage && adminWorkerRow && adminWorkerLink) {
                            adminWorkerRow.classList.remove('hidden');
                            adminWorkerLink.href = progressPage;
                            adminWorkerLink.textContent = progressPage;
                            adminWorkerLink.title = progressPage;
                        } else if (adminWorkerRow) {
                            adminWorkerRow.classList.add('hidden');
                        }
                        
                        if (!adminCopy.__wired) {
                            adminCopy.__wired = true;
                            adminCopy.addEventListener('click', async (e) => {
                                e.preventDefault();
                                const cur = (this.task && this.task.input_url) ? String(this.task.input_url) : '';
                                if (!cur) return;
                                try {
                                    await navigator.clipboard.writeText(cur);
                                    adminCopy.textContent = 'Copied';
                                    setTimeout(() => { adminCopy.textContent = 'Copy'; }, 900);
                                } catch (_) {
                                    // fallback
                                    const ta = document.createElement('textarea');
                                    ta.value = cur;
                                    document.body.appendChild(ta);
                                    ta.select();
                                    document.execCommand('copy');
                                    ta.remove();
                                    adminCopy.textContent = 'Copied';
                                    setTimeout(() => { adminCopy.textContent = 'Copy'; }, 900);
                                }
                            });
                        }
                    } else {
                        adminRow.classList.add('hidden');
                        adminLink.href = '#';
                        adminLink.textContent = '-';
                        adminLink.title = '';
                    }
                }
                
                // Progress (visual, can be driven by progress.txt log)
                this.setProgressUI(this.getDisplayedProgress(task));
                document.getElementById('ready-count').textContent = task.ready_count;
                document.getElementById('total-count').textContent = task.total_count;

                // Tooltip: worker_api + guid on hover for debugging (admin only; hidden for public)
                const pc = document.getElementById('progress-container');
                if (pc) {
                    const guid = task.guid || (() => {
                        const urls = []
                            .concat(task.ready_urls || [])
                            .concat(task.output_urls || [])
                            .concat(task.video_url ? [task.video_url] : []);
                        for (const u of urls) {
                            const fn = String(u || '').split('/').pop() || '';
                            const m = fn.match(/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})_/);
                            if (m) return m[1];
                        }
                        return '';
                    })();
                    if (task.worker_api) {
                        pc.title = `worker_api: ${task.worker_api}\nGUID: ${guid || '-'}`;
                    } else {
                        pc.title = '';
                    }
                }

                // Progress log (processing/done)
                this.updateProgressLog(task);
                
                // Error
                if (task.error_message) {
                    document.getElementById('error-container').classList.remove('hidden');
                    document.getElementById('error-message').textContent = task.error_message;
                    } else {
                    document.getElementById('error-container').classList.add('hidden');
                    document.getElementById('error-message').textContent = '';
                }

                // Restart button removed - restart handled by SAVE RIG T-POSE button in viewer
                
                // Video - use proxy to avoid Mixed Content
                if (task.video_ready) {
                    document.getElementById('video-container').classList.remove('hidden');
                    document.getElementById('video-pending').classList.add('hidden');
                    const video = document.getElementById('video-player');
                    const proxyUrl = `/api/video/${this.taskId}`;
                    // Use HDRP render thumbnail as poster for the video (fast preview while loading).
                    video.poster = `/api/thumb/${this.taskId}`;
                    if (!video.src.includes(this.taskId)) {
                        video.src = proxyUrl;
                        video.load();
                        video.play().catch(() => {}); // Auto-play may be blocked
                    }
                } else if (task.status === 'processing' || task.status === 'done') {
                    document.getElementById('video-pending').classList.remove('hidden');
                }
                
                // HDRP renders row (under video)
                this.updateHdrpRenders(task.ready_urls);
                
                // Files list - always visible, purchase buttons shown for non-owners
                const downloadsCard = document.getElementById('downloads-card');
                if (downloadsCard) {
                    // Show downloads section when task has any progress
                    const hasFiles = task.ready_urls && task.ready_urls.length > 0;
                    const isProcessing = task.status === 'processing' || task.status === 'done';
                    downloadsCard.classList.toggle('hidden', !hasFiles && !isProcessing);
                }
                // Use output_urls for Downloads (all expected files), fallback to ready_urls
                const downloadUrls = (task.output_urls && task.output_urls.length > 0) ? task.output_urls : task.ready_urls;
                this.updateFileList(downloadUrls, task, task.ready_urls || []);

            },

            progressLogLoaded: false,
            progressLogExpanded: false,
            progressLogData: null,
            modelParams: null,
            preparedModelTriggered: false,

            setProgressUI(pct) {
                const p = Math.max(0, Math.min(100, Math.floor(Number(pct) || 0)));
                const percentEl = document.getElementById('progress-percent');
                const fillEl = document.getElementById('progress-fill');
                if (percentEl) percentEl.textContent = `${p}%`;
                if (fillEl) fillEl.style.width = `${p}%`;
            },

            getDisplayedProgress(task) {
                if (!task) return 0;
                if (task.status === 'done') return 100;
                // Keep monotonic: never decrease due to transient log/task data.
                const logP = Math.max(0, Math.min(99, Math.floor(this.lastVisualProgress || 0)));
                const apiP = Math.max(0, Math.min(99, Math.floor(task.progress || 0)));
                return Math.max(apiP, logP);
            },

            computeVisualProgressFromLog(fullText, task) {
                if (!fullText) return null;
                if (task && task.status === 'done') return 100;

                const lines = String(fullText)
                    .split(/\r?\n/)
                    .map(s => s.trim())
                    .filter(Boolean);
                if (!lines.length) return null;

                // Milestones: keyword -> [start,end] percent range.
                // Within a stage, each new log line increments progress by +1 until it reaches stage end.
                const milestones = [
                    { re: /Conversion started\./i, start: 2, end: 10 },
                    { re: /Geometry:/i, start: 10, end: 18 },
                    { re: /Normalization:/i, start: 18, end: 24 },
                    { re: /Model preparation completed\./i, start: 24, end: 30 },
                    { re: /Extracting textures\.\.\./i, start: 30, end: 40 },
                    { re: /Textures prepared\./i, start: 40, end: 48 },
                    { re: /OpenPose analysis:/i, start: 48, end: 60 },
                    { re: /OpenPose analysis completed:/i, start: 60, end: 66 },
                    { re: /Pose preparation:/i, start: 66, end: 74 },
                    { re: /Pose correction completed\./i, start: 74, end: 80 },
                    { re: /Rig created\./i, start: 80, end: 86 },
                    { re: /Animation retargeting completed\./i, start: 86, end: 92 },
                    { re: /Unity package exported\./i, start: 92, end: 96 },
                    { re: /Preview video created\./i, start: 96, end: 99 },
                ];

                let stage = null;
                let stageLineIdx = -1;

                for (const m of milestones) {
                    // Find the last occurrence of each milestone in the full log.
                    for (let i = lines.length - 1; i >= 0; i--) {
                        if (m.re.test(lines[i])) {
                            if (!stage || i > stageLineIdx) {
                                stage = m;
                                stageLineIdx = i;
                            }
                            break;
                        }
                    }
                }

                // Fallback: any log activity should start moving the bar.
                if (!stage) {
                    return Math.min(12, 1 + lines.length);
                }

                const span = Math.max(0, (stage.end - stage.start));
                const linesSince = Math.max(0, lines.length - stageLineIdx - 1);
                const within = Math.min(span, linesSince); // +1% per new line inside the stage (until end)
                const computed = stage.start + within;

                if (task && task.status === 'processing') {
                    return Math.max(1, Math.min(99, computed));
                }
                return Math.max(0, Math.min(99, computed));
            },

            async updateProgressLog(task) {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint) return;

                // Show log for any task that is not error (processing/done), and let refreshProgressLog() fetch it.
                if (task && task.status !== 'error') {
                    if (this.progressLogData) box.classList.remove('hidden');
                }
            },

            async refreshProgressLog() {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint) return;
                if (!this.taskId) return;

                // Only poll while page has a task and it's not error
                if (!this.task || this.task.status === 'error') {
                    box.classList.add('hidden');
                    pre.textContent = '';
                    this.progressLogData = null;
                    return;
                }

                // For visual progress and model params we need full log.
                // Also fetch full log for done tasks if we haven't parsed params yet.
                const needParamsData = !this.modelParams || this.modelParams.vertices === null;
                const wantFull = !!this.progressLogExpanded || (this.task && this.task.status === 'processing') || needParamsData;
                const url = wantFull
                    ? `/api/task/${this.taskId}/progress_log?full=1`
                    : `/api/task/${this.taskId}/progress_log`;

                try {
                    const resp = await fetch(url, { cache: 'no-store' });
                    const data = await resp.json();
                    // Backend always returns 200; but guard anyway.
                    if (!resp.ok || !data) return;

                    // If log isn't available yet, show a friendly message (no errors)
                    if (data.available === false) {
                        const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                        const isRu = lang.startsWith('ru');
                        const msg = data.state === 'queued'
                            ? (isRu ? '–û–∂–∏–¥–∞–µ–º –∑–∞–ø—É—Å–∫ –∑–∞–¥–∞—á–∏ –Ω–∞ –≤–æ—Ä–∫–µ—Ä–µ‚Ä¶' : 'Waiting for worker to start‚Ä¶')
                            : (isRu ? '–õ–æ–≥ –µ—â–µ –Ω–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –≤–æ—Ä–∫–µ—Ä–æ–º‚Ä¶' : 'Log is not published yet‚Ä¶');
                        box.classList.remove('hidden');
                        hint.textContent = isRu ? '–ö–ª–∏–∫ ‚Äî —Ä–∞—Å–∫—Ä—ã—Ç—å' : 'Click to expand';
                        pre.textContent = msg;
                        pre.style.maxHeight = `3.2em`;
                        pre.style.overflow = 'hidden';
                        this.progressLogData = null;
                        return;
                    }

                    this.progressLogData = data;
                    box.classList.remove('hidden');
                    this.renderProgressLog();

                    // Update visual progress from log (does not change backend state)
                    const logText = (data.full_text && String(data.full_text).trim())
                        ? data.full_text
                        : (data.tail_lines || []).join('\n');
                    const computed = this.computeVisualProgressFromLog(logText, this.task);
                    if (computed !== null && computed !== undefined) {
                        const clamped = Math.max(0, Math.min(100, Math.floor(Number(computed) || 0)));
                        if (clamped > (this.lastVisualProgress || 0)) {
                            this.lastVisualProgress = clamped;
                        }
                        this.setProgressUI(this.getDisplayedProgress(this.task));
                    }

                    // Parse and render model parameters (preserve existing data if new parse is empty)
                    const newParams = this.parseModelParams(logText);
                    if (newParams.vertices !== null || newParams.polygons !== null || newParams.markers !== null) {
                        this.modelParams = newParams;
                    } else if (!this.modelParams) {
                        this.modelParams = newParams;
                    }
                    this.renderModelParams();

                    // Trigger early viewer load when prepared model is ready
                    if (logText.includes('Model preparation completed') && !this.preparedModelTriggered) {
                        this.preparedModelTriggered = true;
                        console.log('[TaskPage] Model preparation completed - triggering early viewer load');
                        window.dispatchEvent(new CustomEvent('preparedModelReady'));
                    }
                } catch (_) {
                    // ignore transient errors
                }
            },

            renderProgressLog() {
                const box = document.getElementById('progress-log');
                const pre = document.getElementById('progress-log-text');
                const hint = document.getElementById('progress-log-hint');
                if (!box || !pre || !hint || !this.progressLogData) return;

                const tail = (this.progressLogData.tail_lines || []).join('\n');
                let full = this.progressLogData.full_text || '';
                if (this.progressLogData.truncated) {
                    full = full + '\n‚Ä¶ (truncated)';
                }

                const text = this.progressLogExpanded ? full : tail;
                pre.textContent = text || '';

                hint.textContent = this.progressLogExpanded ? 'Click to collapse' : 'Click to expand';

                // Auto-fit height to content by measuring scrollHeight
                requestAnimationFrame(() => {
                    const target = pre.scrollHeight;
                    if (this.progressLogExpanded) {
                        const maxPx = Math.floor(window.innerHeight * 0.6);
                        pre.style.maxHeight = `${Math.min(target, maxPx)}px`;
                        pre.style.overflow = 'auto';
                        // Keep at bottom for real-time logs
                        pre.scrollTop = pre.scrollHeight;
                    } else {
                        pre.style.maxHeight = `3.2em`;
                        pre.style.overflow = 'hidden';
                    }
                });

                // Show FAILURE message if present in log
                const failureBox = document.getElementById('progress-failure');
                const failureText = document.getElementById('progress-failure-text');
                if (failureBox && failureText) {
                    const fullText = this.progressLogData.full_text || tail;
                    const failureMatch = fullText.match(/FAILURE:\s*(.+)/i);
                    if (failureMatch) {
                        failureText.textContent = failureMatch[1];
                        failureBox.classList.remove('hidden');
                    } else {
                        failureBox.classList.add('hidden');
                    }
                }
            },

            parseModelParams(logText) {
                const params = {
                    vertices: null,
                    polygons: null,
                    textures: null,
                    maxSize: null,
                    markers: null,
                    armsLeft: null, armsRight: null,
                    legsLeft: null, legsRight: null,
                    fingersLeft: null, fingersRight: null,
                    status: 'Processing...'
                };

                if (!logText) return params;

                // Vertices
                const vertMatch = logText.match(/(\d[\d,]*)\s*vertices/i);
                if (vertMatch) params.vertices = parseInt(vertMatch[1].replace(/,/g, ''));

                // Polygons
                const polyMatch = logText.match(/(\d[\d,]*)\s*polygons/i);
                if (polyMatch) params.polygons = parseInt(polyMatch[1].replace(/,/g, ''));

                // Textures
                const texMatch = logText.match(/Found\s+(\d+)\s*textures?/i);
                if (texMatch) params.textures = parseInt(texMatch[1]);

                // Max texture size
                const sizeMatch = logText.match(/up to\s*(\d+x\d+)/i);
                if (sizeMatch) params.maxSize = sizeMatch[1];

                // Markers
                const markersMatch = logText.match(/(\d+)\s*markers/i);
                if (markersMatch) params.markers = parseInt(markersMatch[1]);

                // Arms detection
                const armLeftMatch = logText.match(/Arm\s*\(left\):\s*(yes|no)/i);
                const armRightMatch = logText.match(/Arm\s*\(right\):\s*(yes|no)/i);
                if (armLeftMatch) params.armsLeft = armLeftMatch[1].toLowerCase() === 'yes';
                if (armRightMatch) params.armsRight = armRightMatch[1].toLowerCase() === 'yes';

                // Legs detection
                const legLeftMatch = logText.match(/Leg\s*\(left\):\s*(yes|no)/i);
                const legRightMatch = logText.match(/Leg\s*\(right\):\s*(yes|no)/i);
                if (legLeftMatch) params.legsLeft = legLeftMatch[1].toLowerCase() === 'yes';
                if (legRightMatch) params.legsRight = legRightMatch[1].toLowerCase() === 'yes';

                // Fingers
                const fingersMatch = logText.match(/Fingers.*?left\s*(\d+),?\s*right\s*(\d+)/i);
                if (fingersMatch) {
                    params.fingersLeft = parseInt(fingersMatch[1]);
                    params.fingersRight = parseInt(fingersMatch[2]);
                }

                // Status derivation from milestones
                if (logText.includes('DONE')) {
                    params.status = 'Done ‚úì';
                } else if (logText.includes('Exporting')) {
                    params.status = 'Exporting...';
                } else if (logText.includes('Applying animations')) {
                    params.status = 'Animations...';
                } else if (logText.includes('Skinning')) {
                    params.status = 'Skinning...';
                } else if (logText.includes('Rigging')) {
                    params.status = 'Rigging...';
                } else if (logText.includes('Model preparation completed')) {
                    params.status = 'Rigging...';
                } else if (logText.includes('Preparing model')) {
                    params.status = 'Preparing...';
                } else if (logText.includes('Loading model')) {
                    params.status = 'Loading...';
                }

                return params;
            },

            renderModelParams() {
                const grid = document.getElementById('model-params-grid');
                const container = document.getElementById('model-params');
                if (!grid || !container) return;

                const p = this.modelParams;
                if (!p || (p.vertices === null && p.polygons === null && p.markers === null)) {
                    container.classList.add('hidden');
                    return;
                }

                // Show the block
                container.classList.remove('hidden');

                // Format numbers with commas
                const fmt = (n) => n !== null ? n.toLocaleString() : '‚Äî';
                
                // Get color class based on value
                const getValClass = (n) => {
                    if (n === null) return '';
                    if (n >= 1000) return 'val-green';
                    if (n >= 100) return 'val-yellow';
                    return 'val-red';
                };
                
                // Format arms/legs with colored indicators
                const fmtLimb = (left, right) => {
                    if (left === null && right === null) return '‚Äî';
                    const lSpan = left 
                        ? '<span class="limb-ok">L‚úì</span>' 
                        : '<span class="limb-no">L‚úó</span>';
                    const rSpan = right 
                        ? '<span class="limb-ok">R‚úì</span>' 
                        : '<span class="limb-no">R‚úó</span>';
                    return `${lSpan} ${rSpan}`;
                };

                // Format fingers
                const fmtFingers = (left, right) => {
                    if (left === null && right === null) return '‚Äî';
                    return `${left ?? 0} / ${right ?? 0}`;
                };

                // Status class
                const statusClass = p.status.includes('Done') ? 'status-done' : 'status-processing';

                grid.innerHTML = `
                    <div class="param-tile">
                        <div class="param-tile-label">Vertices</div>
                        <div class="param-tile-value ${getValClass(p.vertices)}">${fmt(p.vertices)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Polygons</div>
                        <div class="param-tile-value ${getValClass(p.polygons)}">${fmt(p.polygons)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Textures</div>
                        <div class="param-tile-value">${p.textures !== null ? p.textures : '‚Äî'}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Max Size</div>
                        <div class="param-tile-value">${p.maxSize || '‚Äî'}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Markers</div>
                        <div class="param-tile-value ${getValClass(p.markers)}">${fmt(p.markers)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Arms</div>
                        <div class="param-tile-value">${fmtLimb(p.armsLeft, p.armsRight)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Legs</div>
                        <div class="param-tile-value">${fmtLimb(p.legsLeft, p.legsRight)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Fingers</div>
                        <div class="param-tile-value">${fmtFingers(p.fingersLeft, p.fingersRight)}</div>
                    </div>
                    <div class="param-tile">
                        <div class="param-tile-label">Status</div>
                        <div class="param-tile-value ${statusClass}">${p.status}</div>
                    </div>
                `;
                
                // Move model-params to bottom when task is done
                if (this.task?.status === 'done') {
                    const card = container.closest('.card');
                    const modelViewer = document.getElementById('model-viewer-wrap');
                    const videoContainer = document.getElementById('video-container');
                    
                    // Insert after model-viewer if visible, otherwise after video-container
                    const insertAfter = modelViewer && !modelViewer.classList.contains('hidden') 
                        ? modelViewer 
                        : videoContainer;
                    
                    if (insertAfter && card && container.parentElement === card) {
                        insertAfter.after(container);
                    }
                }
            },
            
            updateHdrpRenders(urls) {
                const rendersEl = document.getElementById('hdrp-renders');
                const videoContainer = document.getElementById('video-container');
                if (!rendersEl) return;

                // Only show under the video block
                if (!videoContainer || videoContainer.classList.contains('hidden')) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }
                
                if (!urls || urls.length === 0) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }
                
                const matches = [];
                urls.forEach((url, idx) => {
                    const filename = (url || '').split('/').pop() || '';
                    const m = filename.match(/_Unity_HDRP_Render_([1-3])_view\.jpe?g$/i);
                    if (!m) return;
                    const n = Number(m[1]);
                    if (!Number.isFinite(n) || n < 1 || n > 3) return;
                    matches[n - 1] = { idx, filename };
                });

                const items = matches.filter(Boolean);
                if (items.length === 0) {
                    rendersEl.classList.add('hidden');
                    rendersEl.innerHTML = '';
                    return;
                }

                rendersEl.classList.remove('hidden');
                rendersEl.innerHTML = items.map(({ idx, filename }) => {
                    const src = `/api/file/${this.taskId}/${idx}`;
                    return `
                        <img src="${src}"
                             alt="${filename}"
                             loading="lazy"
                             onerror="this.style.display='none'"
                             style="width: 100%; height: 220px; object-fit: cover; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); background: #000;">
                    `;
                }).join('');
            },
            
            // Purchase state
            purchaseState: {
                purchased_all: false,
                purchased_files: [],
                is_owner: false,
                login_required: false,
                user_credits: 0,
                loaded: false
            },

            // Cached files for download (replaces ZIP)
            cachedFilesData: null,
            isDownloadingAll: false,

            async checkCachedFiles() {
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/cached-files`);
                    if (resp.ok) {
                        this.cachedFilesData = await resp.json();
                    }
                } catch (e) {
                    console.warn('Failed to check cached files:', e);
                    this.cachedFilesData = null;
                }
            },

            async downloadAllFiles() {
                const files = this.downloadItems || [];
                if (this.isDownloadingAll || files.length === 0) return;
                
                this.isDownloadingAll = true;
                const downloadBtn = document.getElementById('download-all-btn');
                if (downloadBtn) {
                    downloadBtn.disabled = true;
                    downloadBtn.innerHTML = `<span>Downloading... 0/${files.length}</span>`;
                }
                
                try {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const a = document.createElement('a');
                        a.href = file.url;
                        a.download = file.downloadName || file.name;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                        if (downloadBtn) {
                            downloadBtn.innerHTML = `<span>Downloading... ${i + 1}/${files.length}</span>`;
                        }
                        
                        // Small delay between downloads to not overwhelm browser
                        if (i < files.length - 1) {
                            await new Promise(r => setTimeout(r, 500));
                        }
                    }
                    
                    if (downloadBtn) {
                        downloadBtn.innerHTML = `<img src="/static/images/icons/download.svg" alt="" width="18" height="18" style="filter: brightness(10);"><span style="font-weight: 700;">Download Complete!</span>`;
                        setTimeout(() => {
                            downloadBtn.disabled = false;
                            downloadBtn.innerHTML = `<img src="/static/images/icons/download.svg" alt="" width="18" height="18" style="filter: brightness(10);"><span style="font-weight: 700;">Download ALL (${files.length} files)</span>`;
                        }, 2000);
                    }
                } catch (e) {
                    console.error('Download error:', e);
                    if (downloadBtn) {
                        downloadBtn.disabled = false;
                        downloadBtn.innerHTML = `<img src="/static/images/icons/download.svg" alt="" width="18" height="18" style="filter: brightness(10);"><span style="font-weight: 700;">Download ALL (${files.length} files)</span>`;
                    }
                } finally {
                    this.isDownloadingAll = false;
                }
            },

            async downloadAllOrPurchase() {
                if (this.isDownloadingAll) return;
                if (!this.downloadItems || this.downloadItems.length === 0) {
                    alert(t('error_generic'));
                    return;
                }

                if (!this.purchaseState.purchased_all) {
                    if (this.purchaseState.login_required) {
                        window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname + window.location.search);
                        return;
                    }
                    if (this.purchaseState.user_credits < 1) {
                        try {
                            await fetch(`/api/task/${this.taskId}/purchase-intent`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ source: 'download_all' })
                            });
                        } catch (e) {
                            console.warn('Purchase intent notify failed:', e);
                        }
                        window.location.href = '/buy-credits';
                        return;
                    }
                    if (!confirm(`${t('purchase_confirm_all')} 1 credit?`)) return;

                    try {
                        const resp = await fetch(`/api/task/${this.taskId}/purchases`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ all: true })
                        });
                        const data = await resp.json();
                        if (resp.ok) {
                            this.purchaseState.purchased_all = true;
                            this.purchaseState.user_credits = data.credits_remaining;
                        } else {
                            alert(data.detail || t('error_generic'));
                            return;
                        }
                    } catch (e) {
                        console.error('Purchase error:', e);
                        alert(t('error_generic'));
                        return;
                    }
                }

                await this.downloadAllFiles();
            },

            async loadPurchaseState() {
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchases`);
                    if (resp.ok) {
                        const data = await resp.json();
                        this.purchaseState = { ...data, loaded: true };
                    }
                    // Also get user credits
                    const authResp = await fetch('/auth/me');
                    if (authResp.ok) {
                        const authData = await authResp.json();
                        this.purchaseState.user_credits = authData.credits_remaining || 0;
                        this.purchaseState.login_required = !authData.authenticated;
                    }
                } catch (e) {
                    console.warn('Failed to load purchase state:', e);
                }
            },

            async purchaseFile(fileIndex, displayName) {
                if (this.purchaseState.login_required) {
                    window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname + window.location.search);
                    return;
                }
                if (this.purchaseState.user_credits < 1) {
                    window.location.href = '/buy-credits';
                    return;
                }
                if (!confirm(`${t('purchase_confirm_file')} "${displayName}" for 1 credit?`)) return;
                
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchases`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file_indices: [fileIndex] })
                    });
                    const data = await resp.json();
                    if (resp.ok) {
                        this.purchaseState.purchased_files = data.purchased_files;
                        this.purchaseState.user_credits = data.credits_remaining;
                        this.lastFileListHash = ''; // Force re-render
                        await this.fetchTask(); // Refresh file list
                    } else {
                        alert(data.detail || t('error_generic'));
                    }
                } catch (e) {
                    console.error('Purchase error:', e);
                    alert(t('error_generic'));
                }
            },

            async purchaseAll() {
                if (this.purchaseState.login_required) {
                    window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname + window.location.search);
                    return;
                }
                if (this.purchaseState.user_credits < 1) {
                    window.location.href = '/buy-credits';
                    return;
                }
                if (!confirm(`${t('purchase_confirm_all')} 1 credit?`)) return;
                
                try {
                    const resp = await fetch(`/api/task/${this.taskId}/purchases`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ all: true })
                    });
                    const data = await resp.json();
                    if (resp.ok) {
                        this.purchaseState.purchased_all = true;
                        this.purchaseState.user_credits = data.credits_remaining;
                        this.lastFileListHash = ''; // Force re-render
                        await this.fetchTask(); // Refresh file list
                    } else {
                        alert(data.detail || t('error_generic'));
                    }
                } catch (e) {
                    console.error('Purchase error:', e);
                    alert(t('error_generic'));
                }
            },

            updateFileList(urls, task, readyUrls = []) {
                const list = document.getElementById('file-list');
                const count = document.getElementById('files-count');
                
                // Calculate hash of current data to avoid unnecessary re-renders
                const currentHash = JSON.stringify(urls || []) + JSON.stringify(readyUrls || []) + (task?.status || '');
                if (this.lastFileListHash === currentHash && list.children.length > 0) {
                    return; // Data hasn't changed, skip re-render
                }
                this.lastFileListHash = currentHash;
                
                // Create a set of ready filenames for fast lookup
                const readyFilenames = new Set(
                    readyUrls.map(url => (url || '').trim().split('/').pop())
                );
                
                if (!urls || urls.length === 0) {
                    list.innerHTML = `<li class="file-item" style="color: var(--text-muted)">Waiting for files...</li>`;
                    count.textContent = '0';
                    this.renderTextureGallery([]);
                    return;
                }
                
                const blenderIcon = '/static/images/icons/blender_logo.png';
                const unityIcon = '/static/images/icons/unity-logo.png';
                const glbIcon = '/static/images/formats/glb.svg';
                const fbxIcon = '/static/images/formats/fbx.svg';
                const objIcon = '/static/images/formats/obj.svg';
                
                // Function to remove GUID prefix from filename
                // Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx_filename.ext -> filename.ext
                const cleanFilename = (filename) => {
                    return filename.replace(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}_/i, '');
                };
                
                // Function to get icon based on file extension
                const getIconForFile = (filename) => {
                    const ext = filename.split('.').pop().toLowerCase();
                    if (ext === 'blend') return blenderIcon;
                    if (ext === 'glb' || ext === 'gltf') return glbIcon;
                    if (ext === 'fbx') return fbxIcon;
                    if (ext === 'obj') return objIcon;
                    if (ext === 'unitypackage') return unityIcon;
                    if (ext === 'max' || ext === 'ma' || ext === 'c4d') return null;
                    return null;
                };

                const items = [];
                const textures = []; // Collect textures separately
                
                // Texture patterns to filter into separate gallery
                const texturePatterns = [
                    /_Roughness\.jpe?g$/i,
                    /_Metallic\.jpe?g$/i,
                    /_Normal\.jpe?g$/i,
                    /_texture\.jpe?g$/i,
                    /_AO\.jpe?g$/i,
                    /_BaseColor\.jpe?g$/i,
                    /_Albedo\.jpe?g$/i,
                    /_Diffuse\.jpe?g$/i,
                    /_Specular\.jpe?g$/i,
                    /_Height\.jpe?g$/i,
                    /_Displacement\.jpe?g$/i,
                    /_Emissive\.jpe?g$/i,
                ];
                
                // First, expand any concatenated URLs (bug in data - some URLs got merged)
                const guidPattern = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}_/gi;
                const expandedUrls = [];
                urls.forEach((url, idx) => {
                    const urlClean = (url || '').trim();
                    const rawFilename = urlClean.split('/').pop() || '';
                    // Check if filename contains multiple GUIDs (concatenated URLs)
                    const guidMatches = rawFilename.match(guidPattern);
                    if (guidMatches && guidMatches.length > 1) {
                        // Split on GUID pattern, keeping the GUID with each part
                        const parts = rawFilename.split(guidPattern).filter(Boolean);
                        guidMatches.forEach((guid, i) => {
                            if (parts[i]) {
                                const baseUrl = urlClean.substring(0, urlClean.lastIndexOf('/') + 1);
                                expandedUrls.push({ url: baseUrl + guid + parts[i], idx: idx + '_' + i });
                            }
                        });
                    } else {
                        expandedUrls.push({ url: urlClean, idx });
                    }
                });
                
                expandedUrls.forEach(({ url: urlClean, idx }) => {
                    const rawFilename = urlClean.split('/').pop() || '';
                    const filename = cleanFilename(rawFilename);

                    // Hide video artifacts (video is already shown on page)
                    if (/_video\.(mp4|mov)$/i.test(filename)) return;
                    if (/_video_poster\.jpe?g$/i.test(filename)) return;
                    if (/video\.(mp4|mov)$/i.test(filename)) return;
                    if (/video_poster\.jpe?g$/i.test(filename)) return;

                    // HDRP renders are shown as images under the video (not in file list)
                    if (/_Unity_HDRP_Render_[1-3]_view\.jpe?g$/i.test(filename)) return;
                    if (/Unity_HDRP_Render_[1-3]_view\.jpe?g$/i.test(filename)) return;
                    
                    // Hide _model_prepared.glb - used for viewer, not for download
                    if (/model_prepared\.glb$/i.test(filename)) return;

                    // Collect textures for preview gallery (they also appear in Downloads)
                    if (texturePatterns.some(p => p.test(filename))) {
                        const textureProxyUrl = `/api/file/${this.taskId}/download/${encodeURIComponent(rawFilename)}`;
                        textures.push({ url: textureProxyUrl, filename, idx });
                        // Don't return - textures should also be in Downloads list
                    }

                    // Use cleaned filename as display name and download name
                    const displayName = filename;
                    const icon = getIconForFile(filename);
                    const downloadName = filename;
                    // Use proxy URL to avoid mixed content (HTTPS site, HTTP worker)
                    const proxyUrl = `/api/file/${this.taskId}/download/${encodeURIComponent(rawFilename)}`;

                    items.push({
                        idx,
                        url: proxyUrl,
                        filename,
                        displayName,
                        icon,
                        downloadName,
                        isReady: readyFilenames.has(rawFilename),
                    });
                });
                
                // Render texture gallery
                this.renderTextureGallery(textures);

                count.textContent = String(items.length);
                // Use auto-fill grid for responsive layout
                list.style.gridTemplateColumns = `repeat(auto-fill, minmax(150px, 1fr))`;
                if (items.length === 0) {
                    list.innerHTML = `<li class="file-item" style="color: var(--text-muted)">Waiting for files...</li>`;
                    return;
                }

                const readyItems = items.filter(item => item.isReady);
                this.downloadItems = readyItems;

                const filesHtml = items.map((item) => {
                    const iconHtml = item.icon
                        ? `<img src="${item.icon}" alt="" aria-hidden="true" style="height: 2.5em; width: auto; object-fit: contain; display: block;" onerror="this.style.display='none'">`
                        : '';

                    return `
                        <li class="file-item"
                            style="flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; margin-bottom: 0; text-align: center; min-width: 0;">
                            ${iconHtml}
                            <div style="font-weight: 700; color: var(--accent); font-size: 0.95rem; word-break: break-all; overflow-wrap: anywhere; max-width: 100%; line-height: 1.3;" title="${item.displayName}">
                                ${item.displayName}
                            </div>
                        </li>
                    `;
                }).join('');
                
                // Check cached files availability when task is done
                if (task?.status === 'done' && !this._cachedFilesChecked) {
                    this._cachedFilesChecked = true;
                    this.checkCachedFiles().then(() => {
                        // Re-render if cached files became available
                        if (this.cachedFilesData?.cached && this.cachedFilesData?.files?.length > 0) {
                            this.lastFileListHash = ''; // Force re-render
                            this.updateFileList(urls, task, readyUrls);
                        }
                    });
                }
                
                // Single "Download All" button (purchase if needed)
                let downloadAllHtml = '';
                if (items.length > 0) {
                    const cachedReady = this.cachedFilesData?.cached && this.cachedFilesData?.files?.length > 0;
                    const fileCount = this.downloadItems.length;
                    const totalSize = cachedReady ? this.cachedFilesData.total_size : 0;
                    const sizeStr = cachedReady
                        ? (totalSize > 1024*1024 
                            ? `${(totalSize / (1024*1024)).toFixed(1)} MB` 
                            : `${(totalSize / 1024).toFixed(0)} KB`)
                        : null;
                    const buttonLabel = cachedReady
                        ? `${t('btn_download_all')} (${fileCount} files)`
                        : t('btn_download_all');
                    const buttonDisabled = fileCount === 0;
                    const helperText = cachedReady
                        ? `üì¶ ${t('btn_download_all')} ${fileCount} files${sizeStr ? ` (${sizeStr} total)` : ''}`
                        : 'Preparing downloads...';

                    downloadAllHtml = `
                        <li class="file-item" style="flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem; background: linear-gradient(135deg, rgba(var(--accent-rgb), 0.15), rgba(var(--accent-rgb), 0.05)); border: 2px solid var(--accent); grid-column: 1 / -1;">
                            <div style="font-size: 0.95rem; font-weight: 500; color: var(--text-secondary);">
                                ${helperText}
                            </div>
                            <button id="download-all-btn" onclick="TaskUI.downloadAllOrPurchase()" class="btn btn-primary" 
                               style="width: 100%; max-width: 300px; justify-content: center; padding: 0.75rem 1rem; font-size: 1rem; gap: 0.5rem;"
                               ${buttonDisabled ? 'disabled' : ''}>
                                <img src="/static/images/icons/download.svg" alt="" aria-hidden="true" width="18" height="18" style="filter: brightness(10);">
                                <span style="font-weight: 700;">${buttonLabel}</span>
                            </button>
                        </li>
                    `;
                }
                
                list.innerHTML = downloadAllHtml + filesHtml;
            },
            
            renderTextureGallery(textures) {
                const section = document.getElementById('additional-content-section');
                const gallery = document.getElementById('texture-gallery');
                
                if (!textures || textures.length === 0) {
                    if (section) section.style.display = 'none';
                    if (gallery) gallery.innerHTML = '';
                    return;
                }
                
                // Show the section
                if (section) section.style.display = 'block';
                
                // Render texture tiles (preview only, no download buttons - download is in Downloads section)
                const html = textures.map(tex => {
                    // Extract texture type from filename (e.g., "model_Normal.jpg" -> "Normal")
                    const match = tex.filename.match(/_([A-Za-z]+)\.jpe?g$/i);
                    const textureType = match ? match[1] : 'Texture';
                    
                    // Use direct URL for display
                    const imgUrl = tex.url;
                    
                    return `
                        <div class="texture-tile" onclick="TaskUI.openImagePreview('${imgUrl}')">
                            <img src="${imgUrl}" alt="${textureType}" loading="lazy">
                            <div class="label">${textureType}</div>
                        </div>
                    `;
                }).join('');
                
                if (gallery) gallery.innerHTML = html;
            },

            setupButtons() {
                // Restart button removed - restart now handled by SAVE RIG T-POSE button in viewer

                // Owner tasks modal
                document.getElementById('owner-tasks-btn')?.addEventListener('click', () => this.openOwnerTasksModal());
                document.getElementById('owner-tasks-close')?.addEventListener('click', () => this.closeOwnerTasksModal());
                document.getElementById('owner-tasks-modal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'owner-tasks-modal') this.closeOwnerTasksModal();
                });
                document.getElementById('owner-tasks-prev')?.addEventListener('click', () => {
                    if (this.ownerTasksPage > 1) {
                        this.ownerTasksPage--;
                        this.loadOwnerTasks();
                    }
                });
                document.getElementById('owner-tasks-next')?.addEventListener('click', () => {
                    const totalPages = Math.ceil(this.ownerTasksTotal / this.ownerTasksPerPage);
                    if (this.ownerTasksPage < totalPages) {
                        this.ownerTasksPage++;
                        this.loadOwnerTasks();
                    }
                });

                // Progress log toggle
                document.getElementById('progress-log')?.addEventListener('click', () => {
                    this.progressLogExpanded = !this.progressLogExpanded;
                    this.renderProgressLog();
                    // When expanding, refetch full log immediately
                    this.refreshProgressLog();
                });

                // Progress log copy button
                document.getElementById('progress-log-copy')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const full = this.progressLogData?.full_text || 
                                 (this.progressLogData?.tail_lines || []).join('\n');
                    if (full) {
                        navigator.clipboard.writeText(full).then(() => {
                            const btn = e.target;
                            const original = btn.textContent;
                            btn.textContent = t('log_copied');
                            setTimeout(() => btn.textContent = t('log_copy'), 1500);
                        });
                    }
                });

                // HDRP image preview (click to open lightbox)
                const renders = document.getElementById('hdrp-renders');
                renders?.addEventListener('click', (e) => {
                    const t = e.target;
                    if (!(t instanceof HTMLImageElement)) return;
                    this.openImagePreview(t.src);
                });

                const imgModal = document.getElementById('image-preview-modal');
                document.getElementById('image-preview-close')?.addEventListener('click', () => this.closeImagePreview());
                imgModal?.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'image-preview-modal') this.closeImagePreview();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.closeImagePreview();
                });
            },

            openImagePreview(src) {
                const modal = document.getElementById('image-preview-modal');
                const img = document.getElementById('image-preview-img');
                if (!modal || !img) return;
                img.src = src;
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            },

            closeImagePreview() {
                const modal = document.getElementById('image-preview-modal');
                const img = document.getElementById('image-preview-img');
                if (img) img.src = '';
                if (!modal) return;
                modal.classList.add('hidden');
                modal.style.display = 'none';
            },

            openOwnerTasksModal() {
                this.ownerTasksPage = 1;
                const modal = document.getElementById('owner-tasks-modal');
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                this.loadOwnerTasks();
            },

            closeOwnerTasksModal() {
                const modal = document.getElementById('owner-tasks-modal');
                modal.classList.add('hidden');
                modal.style.display = 'none';
            },

            formatDate(dateStr) {
                if (!dateStr) return '-';
                const d = new Date(dateStr);
                return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            },

            async loadOwnerTasks() {
                const tbody = document.getElementById('owner-tasks-table');
                tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; color: var(--text-muted);">Loading...</td></tr>';
                try {
                    const params = new URLSearchParams({
                        page: this.ownerTasksPage,
                        per_page: this.ownerTasksPerPage
                    });
                    const resp = await fetch(`/api/task/${this.taskId}/owner_tasks?${params}`);
                    if (!resp.ok) throw new Error('Failed to load owner tasks');
                    const data = await resp.json();
                    this.ownerTasksTotal = data.total || 0;

                    const subtitle = document.getElementById('owner-tasks-subtitle');
                    if (subtitle) {
                        // owner_id can be email for user owners; don't show it publicly
                        subtitle.textContent = data.owner_type === 'user' ? 'Owner: user' : 'Owner: anon';
                    }

                    const placeholder = '/static/images/placeholder-thumb.svg';
                    const rows = (data.tasks || []).map(t => {
                        const statusColor = {
                            'created': 'var(--text-muted)',
                            'processing': 'var(--accent)',
                            'done': 'var(--success)',
                            'error': 'var(--error)'
                        }[t.status] || 'var(--text-muted)';

                        const thumb = t.thumbnail_url || placeholder;
                        return `
                            <tr>
                                <td style="width: 140px;">
                                    <img src="${thumb}" onerror="this.onerror=null;this.src='${placeholder}';"
                                         alt="thumb" style="width: 120px; height: 68px; object-fit: cover; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: #000;">
                                </td>
                                <td style="font-family: monospace; font-size: 0.875rem;">${t.task_id.substring(0,8)}...</td>
                                <td><span style="color: ${statusColor}; font-weight: 500; text-transform: capitalize;">${t.status}</span></td>
                                <td>${t.progress || 0}%</td>
                                <td style="font-size: 0.875rem;">${this.formatDate(t.created_at)}</td>
                                <td>
                                    <a href="/task?id=${t.task_id}" target="_blank" class="btn btn-secondary"
                                       style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">Open</a>
                                </td>
                            </tr>
                        `;
                    });

                    tbody.innerHTML = rows.length
                        ? rows.join('')
                        : '<tr><td colspan="6" style="text-align:center; color: var(--text-muted);">No tasks found</td></tr>';

                    const totalPages = Math.ceil((this.ownerTasksTotal || 0) / this.ownerTasksPerPage);
                    const start = (this.ownerTasksPage - 1) * this.ownerTasksPerPage + 1;
                    const end = Math.min(this.ownerTasksPage * this.ownerTasksPerPage, this.ownerTasksTotal || 0);
                    document.getElementById('owner-tasks-pagination-info').textContent =
                        `Showing ${this.ownerTasksTotal ? start : 0}-${this.ownerTasksTotal ? end : 0} of ${this.ownerTasksTotal} tasks`;
                    document.getElementById('owner-tasks-prev').disabled = this.ownerTasksPage <= 1;
                    document.getElementById('owner-tasks-next').disabled = this.ownerTasksPage >= (totalPages || 1);
                } catch (e) {
                    console.error('Owner tasks load error:', e);
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center; color: var(--error);">Failed to load tasks</td></tr>';
                }
            },
            
            showError(message) {
                document.getElementById('error-container').classList.remove('hidden');
                document.getElementById('error-message').textContent = message;
                document.getElementById('progress-container').classList.add('hidden');
            },
            
            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            },

            progressLogInterval: null,
            startProgressLogPolling() {
                if (this.progressLogInterval) return;
                const tick = async () => {
                    try { await this.refreshProgressLog(); } catch (_) {}
                };
                tick();
                this.progressLogInterval = setInterval(tick, 10000);

                // Cleanup on unload
                window.addEventListener('beforeunload', () => {
                    try {
                        if (this.progressLogInterval) clearInterval(this.progressLogInterval);
                        this.progressLogInterval = null;
                    } catch (_) {}
                }, { once: true });
            },
            
            async loadQueueStatus() {
                const activeEl = document.getElementById('queue-active');
                const pendingEl = document.getElementById('queue-pending');
                const waitEl = document.getElementById('queue-wait');
                const serversEl = document.getElementById('queue-servers');
                
                if (!activeEl) return;
                
                try {
                    const response = await fetch('/api/queue/status');
                    const data = await response.json();
                    
                    activeEl.textContent = data.total_active;
                    pendingEl.textContent = data.total_pending;
                    const s = Number(data.estimated_wait_seconds || 0);
                    if (s < 60) {
                        waitEl.textContent = t('queue_wait_lt1min');
                    } else if (s < 3600) {
                        const minutes = Math.ceil(s / 60);
                        waitEl.textContent = t('queue_wait_minutes', { minutes: String(minutes) });
                    } else {
                        const hours = Math.floor(s / 3600);
                        const minutes = Math.floor((s % 3600) / 60);
                        waitEl.textContent = t('queue_wait_hours', { hours: String(hours), minutes: String(minutes) });
                    }
                    serversEl.textContent = `${data.available_workers}/${data.total_workers}`;
                    
                    // Color coding
                    if (data.total_pending > 5) {
                        pendingEl.classList.add('warning');
                    } else {
                        pendingEl.classList.remove('warning');
                    }
                    
                    if (data.estimated_wait_seconds < 60) {
                        waitEl.classList.add('success');
                    } else if (data.estimated_wait_seconds > 1800) {
                        waitEl.classList.add('warning');
                    }
                } catch (error) {
                    console.error('Queue status error:', error);
                }
            }
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            TaskPage.init();
            // Initialize site footer
            const footerContainer = document.getElementById('site-footer');
            if (footerContainer && window.SiteFooter) {
                footerContainer.innerHTML = SiteFooter.render();
            }
        });
    </script>

    <!-- Three.js Viewer (ES Modules) -->
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/examples/jsm/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/UnrealBloomPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js",
            "three/examples/jsm/postprocessing/OutputPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutputPass.js"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { TransformControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/TransformControls.js';
        import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
        import { EXRLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/EXRLoader.js';
        
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

        import { 
            RigEditor, ViewerControls, RigType, CameraMode, MaterialChannel,
            TransformMode, TransformManager, SelectionSystem, GizmoLoader,
            HierarchyNavigator, TPoseReference, SnapSettings, TransformSystemTests
        } from '/static/js/rig-editor.js?v=62';

        // Make THREE available globally for rig-editor module
        window.THREE = THREE;

        const params = new URLSearchParams(window.location.search);
        const rawTaskId = params.get('id') || '';
        const taskId = rawTaskId.split('?')[0];  // Sanitize malformed URLs

        const wrap = document.getElementById('model-viewer-wrap');
        const host = document.getElementById('model-viewer');
        const statusEl = document.getElementById('model-viewer-status');
        let sel = document.getElementById('anim-select');
        let playBtn = document.getElementById('anim-play-btn');
        let pauseBtn = document.getElementById('anim-pause-btn');

        if (!taskId || !wrap || !host || !statusEl) {
            // nothing to do
        } else {
            // ============================================================
            // LIGHTING & RENDERER CONFIG (edit values here)
            // ============================================================
            const LIGHTING_CONFIG = {
                // HDR Environment (IBL reflections)
                hdrPath: '/static/ibl/DefaultHDRISky.exr',
                envIntensity: 1.0,          // scene.environmentIntensity (Three.js r152+)

                // Tone mapping
                toneMapping: THREE.ACESFilmicToneMapping,
                toneMappingExposure: 1.0,   // overall brightness

                // Directional "sun" light
                sunColor: 0xffffff,
                sunIntensity: 0.8,
                sunPosition: [3, 5, 2],     // x, y, z

                // Ambient fill
                ambientColor: 0xffffff,
                ambientIntensity: 0.3,

                // Hemisphere light (sky/ground)
                hemiSkyColor: 0xffffff,
                hemiGroundColor: 0x222233,
                hemiIntensity: 0.25,

                // Background
                bgColor: 0x1a1a2e,           // scene background color
            };
            // ============================================================

            let mixer = null;
            let animations = [];
            let currentAction = null;
            const clock = new THREE.Clock();
            
            // Viewer keyboard focus - only capture keys after user clicks on viewer
            let viewerFocused = false;
            
            // Set up click-to-focus handlers
            function setupViewerFocus() {
                const focusTargets = [wrap, host];
                focusTargets.forEach(el => {
                    if (el) {
                        el.addEventListener('click', () => {
                            viewerFocused = true;
                            wrap.classList.add('viewer-focused');
                        });
                        el.addEventListener('mousedown', () => {
                            viewerFocused = true;
                            wrap.classList.add('viewer-focused');
                        });
                    }
                });
                
                // Lose focus when clicking outside viewer
                document.addEventListener('click', (e) => {
                    if (!wrap.contains(e.target)) {
                        viewerFocused = false;
                        wrap.classList.remove('viewer-focused');
                    }
                });
                
                console.log('[Viewer] Focus handlers set up - click viewer to enable keyboard shortcuts');
            }
            setupViewerFocus();

            function setStatus(s) { statusEl.textContent = s; }

            function play(name) {
                if (!mixer || !animations.length) return;
                const clip = animations.find(c => c.name === name) || animations[0];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.reset().fadeIn(0.2).play();
                if (currentAction && currentAction !== next) currentAction.fadeOut(0.2);
                currentAction = next;
                mixer.timeScale = 1;
            }

            async function loadEnvironment(scene) {
                const url = LIGHTING_CONFIG.hdrPath;
                setStatus('Loading IBL...');

                // Use EXRLoader for .exr (RGBELoader is still imported/available as required stack).
                const tryEXR = () => new Promise((resolve) => {
                    const exr = new EXRLoader();
                    exr.load(url, (t) => {
                        t.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = t;
                        // Set envIntensity if supported (Three.js r152+)
                        if ('environmentIntensity' in scene) {
                            scene.environmentIntensity = LIGHTING_CONFIG.envIntensity;
                        }
                        console.log('[Viewer] EXR environment loaded');
                        resolve(true);
                    }, undefined, (err) => {
                        console.warn('[Viewer] EXR load failed:', err);
                        resolve(false);
                    });
                });

                const tryRGBE = () => new Promise((resolve) => {
                    const rgbe = new RGBELoader();
                    rgbe.load(url.replace('.exr', '.hdr'), (t) => {
                        t.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = t;
                        if ('environmentIntensity' in scene) {
                            scene.environmentIntensity = LIGHTING_CONFIG.envIntensity;
                        }
                        console.log('[Viewer] HDR environment loaded');
                        resolve(true);
                    }, undefined, () => resolve(false));
                });

                const okExr = await tryEXR();
                if (okExr) return true;
                const okHdr = await tryRGBE();
                return okHdr;
            }

            // Scene state (persistent across model loads)
            let sceneInited = false;
            let scene, renderer, camera, controls, transform;
            let zoomState = null;  // Custom zoom with inertia - initialized in initScene
            let currentModel = null;
            let preparedLoaded = false;
            let finalLoaded = false;

            // Rig Editor and Viewer Controls instances
            let rigEditor = null;
            let viewerControls = null;
            
            // Transform System instances
            let transformManager = null;
            let tPoseReference = null;
            let hierarchyNavigator = null;
            let transformTests = null;

            // Light references for slider updates
            let sunLight = null;
            let ambientLight = null;
            let hemiLight = null;
            let composer = null;
            let bloomPass = null;

            // Fullscreen state
            let isFullscreen = false;
            let normalCanvasSize = { width: 0, height: 0 };
            let fullscreenCanvasSize = { width: 0, height: 0 };
            
            // Viewer state (can be updated via sliders/selectors)
            let viewerState = {
                mainLightIntensity: 3.0,
                envIntensity: 1.0,
                reflectionIntensity: 3.0,
                modelRotation: 'z180',
                bgColor: '#000000',
                groundColor: '#222222',
                groundSize: 100.0,
                shadowIntensity: 0.5,
                shadowRadius: 1.0,
                sunRotation: 45.0,
                sunInclination: 45.0,
                timeOfDay: 12.0,
                ambientColor: '#ffffff',
                ambientIntensity: 0.3,
                fogColor: '#000000',
                fogDensity: 0.0,
                lightingPreset: 'day',
                camera: { 
                    position: { x: 0, y: 1.6, z: 3.5 },
                    target: { x: 0, y: 1.0, z: 0 }
                },
                syncAdjChannel: false,
                bloom: { strength: 0.0, threshold: 0.8, radius: 0.4 },
                adjustments: {
                    albedo: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    ao: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    normal: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    roughness: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    metalness: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false },
                    emissive: { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false }
                },
                aoSettings: {
                    samples: 32,
                    radius: 0.15,
                    intensity: 1.5
                },
                // Model transform (saved and loaded)
                modelTransform: {
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },  // radians
                    scale: { x: 1, y: 1, z: 1 }
                }
            };
            window.viewerState = viewerState; // Make global for debugging

            let currentAdjChannel = 'albedo';

            // Mapping for sync mode (eye button)
            const ADJ_CHANNEL_TO_VIEWER = {
                'albedo': 4,    // MaterialChannel.ALBEDO
                'ao': 2,        // MaterialChannel.AO
                'normal': 3,    // MaterialChannel.NORMAL
                'roughness': 6, // MaterialChannel.ROUGHNESS
                'metalness': 5, // MaterialChannel.METALNESS
                'emissive': 7   // MaterialChannel.EMISSIVE
            };

            // Translation helper (use window.t from i18n.js)
            const t = (key) => window.t ? window.t(key) : key;

            // Admin detection (cached)
            let viewerIsAdmin = false;
            let _viewerAdminPromise = null;
            async function ensureViewerAdmin() {
                if (_viewerAdminPromise) return _viewerAdminPromise;
                _viewerAdminPromise = (async () => {
                    try {
                        const authResp = await fetch('/auth/me');
                        if (authResp.ok) {
                            const authData = await authResp.json();
                            viewerIsAdmin = !!authData?.user?.is_admin;
                        }
                    } catch (e) {
                        // ignore
                    }
                    return viewerIsAdmin;
                })();
                return _viewerAdminPromise;
            }

            async function saveDefaultViewerSettings(source = 'unknown') {
                const isAdmin = await ensureViewerAdmin();
                console.log('[Viewer] Save default settings requested:', { source, isAdmin });
                if (!isAdmin) {
                    alert('Admin only');
                    return;
                }
                try {
                    const resp = await fetch('/api/admin/viewer-default-settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(viewerState)
                    });
                    if (!resp.ok) {
                        const data = await resp.json().catch(() => ({}));
                        console.warn('[Viewer] Failed to save default settings:', data);
                        alert(data.detail || 'Failed to save defaults');
                        return;
                    }
                    console.log('[Viewer] Default viewer settings saved');
                    alert('Default viewer settings saved');
                } catch (e) {
                    console.error('[Viewer] Failed to save default settings:', e);
                    alert('Failed to save defaults');
                }
            }
            
            // Load viewer settings from server
            async function loadViewerSettings() {
                try {
                    const resp = await fetch(`/api/task/${taskId}/viewer-settings`);
                    if (resp.ok) {
                        const settings = await resp.json();
                        viewerState.mainLightIntensity = settings.mainLightIntensity !== undefined ? settings.mainLightIntensity : 3.0;
                        viewerState.envIntensity = settings.envIntensity !== undefined ? settings.envIntensity : 1.0;
                        viewerState.reflectionIntensity = settings.reflectionIntensity !== undefined ? settings.reflectionIntensity : 3.0;
                        viewerState.modelRotation = settings.modelRotation || 'z180';
                        viewerState.bgColor = settings.bgColor || '#000000';
                        viewerState.groundColor = settings.groundColor || '#222222';
                        viewerState.groundSize = settings.groundSize !== undefined ? settings.groundSize : 100.0;
                        viewerState.shadowIntensity = settings.shadowIntensity !== undefined ? settings.shadowIntensity : 0.5;
                        viewerState.shadowRadius = settings.shadowRadius !== undefined ? settings.shadowRadius : 1.0;
                        viewerState.sunRotation = settings.sunRotation !== undefined ? settings.sunRotation : 45.0;
                        viewerState.sunInclination = settings.sunInclination !== undefined ? settings.sunInclination : 45.0;
                        viewerState.timeOfDay = settings.timeOfDay !== undefined ? settings.timeOfDay : 12.0;
                        viewerState.ambientColor = settings.ambientColor || '#ffffff';
                        viewerState.ambientIntensity = settings.ambientIntensity !== undefined ? settings.ambientIntensity : 0.3;
                        viewerState.fogColor = settings.fogColor || '#000000';
                        viewerState.fogDensity = settings.fogDensity !== undefined ? settings.fogDensity : 0.0;
                        viewerState.lightingPreset = settings.lightingPreset || 'day';
                        viewerState.syncAdjChannel = settings.syncAdjChannel || false;
                        if (settings.bloom) {
                            viewerState.bloom = { ...viewerState.bloom, ...settings.bloom };
                        }
                        // Save camera position separately - will be applied after model loads
                        if (settings.camera && settings.camera.position && settings.camera.target) {
                            savedCameraPosition = { ...settings.camera.position };
                            savedCameraTarget = { ...settings.camera.target };
                            console.log('[Viewer] Saved camera position for later:', savedCameraPosition);
                        }
                        
                        if (settings.adjustments) {
                            // Merge saved adjustments with defaults
                            for (const chan in settings.adjustments) {
                                if (viewerState.adjustments[chan]) {
                                    viewerState.adjustments[chan] = {
                                        ...viewerState.adjustments[chan],
                                        ...settings.adjustments[chan]
                                    };
                                }
                            }
                        }
                        
                        // Load AO bake settings
                        if (settings.aoSettings) {
                            viewerState.aoSettings = {
                                ...viewerState.aoSettings,
                                ...settings.aoSettings
                            };
                        }
                        
                        // Load model transform
                        if (settings.modelTransform) {
                            viewerState.modelTransform = {
                                position: settings.modelTransform.position || { x: 0, y: 0, z: 0 },
                                rotation: settings.modelTransform.rotation || { x: 0, y: 0, z: 0 },
                                scale: settings.modelTransform.scale || { x: 1, y: 1, z: 1 }
                            };
                            console.log('[Viewer] Loaded model transform:', viewerState.modelTransform);
                        }

                        applyViewerState(); // Apply everything EXCEPT camera
                        updateViewerUI();
                        lastSyncedState = JSON.stringify(viewerState);
                        console.log('[Viewer] Loaded settings (camera will be applied after model loads)');
                    } else {
                        console.log('[Viewer] No settings on server, using defaults');
                    }
                } catch (e) {
                    console.warn('[Viewer] Failed to load settings:', e);
                }
                // Start sync loop after first load (or fail)
                startPeriodicSync();
            }
            
            // Periodic sync logic
            let lastSyncedState = JSON.stringify(viewerState);
            let isDefaultComparisonOn = false;
            let stateBeforeDefault = null;
            let cameraInitialized = false; // Flag to prevent camera sync until loaded from server
            let savedCameraPosition = null; // Store camera position from server until model loads
            let savedCameraTarget = null;
            
            // Restore camera from saved position (called ONCE after model loads)
            function restoreSavedCamera() {
                if (savedCameraPosition && savedCameraTarget && camera && controls) {
                    console.log('[Viewer] Restoring saved camera position:', savedCameraPosition);
                    camera.position.set(savedCameraPosition.x, savedCameraPosition.y, savedCameraPosition.z);
                    controls.target.set(savedCameraTarget.x, savedCameraTarget.y, savedCameraTarget.z);
                    controls.update();
                    
                    // Update viewerState with restored values
                    viewerState.camera.position = { ...savedCameraPosition };
                    viewerState.camera.target = { ...savedCameraTarget };
                    
                    // Tell ViewerControls to skip next focus (will be called by setRigType)
                    if (viewerControls) {
                        viewerControls.skipNextFocusOnModel();
                    }
                    
                    console.log('[Viewer] Camera restored successfully');
                } else {
                    console.log('[Viewer] No saved camera position, using current/default');
                }
                // Now allow camera sync in render loop
                cameraInitialized = true;
            }
            
            // Loading Overlay Manager
            const loadingManager = {
                queue: [],
                currentItem: null,
                isVisible: false,
                
                show(title = 'Loading Models') {
                    const overlay = document.getElementById('viewer-loading-overlay');
                    const titleEl = document.getElementById('loading-title-text');
                    if (overlay) {
                        overlay.classList.add('visible');
                        this.isVisible = true;
                    }
                    if (titleEl) titleEl.textContent = title;
                    this.updateProgress(0, 'Preparing...');
                    
                    // Hide other UI during loading
                    this._setUIHidden(true);
                },
                
                hide() {
                    const overlay = document.getElementById('viewer-loading-overlay');
                    if (overlay) {
                        overlay.classList.remove('visible');
                        this.isVisible = false;
                    }
                    this.queue = [];
                    this.currentItem = null;
                    
                    // Show UI again
                    this._setUIHidden(false);
                },
                
                _setUIHidden(hidden) {
                    const elementsToHide = [
                        'viewer-settings-area',
                        'viewer-adjustments-wrap', 
                        'viewer-hierarchy-wrap',
                        'viewer-transform-wrap',
                        'viewer-rigtype-wrap',
                        'viewer-camera-wrap'
                    ];
                    
                    elementsToHide.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.opacity = hidden ? '0' : '1';
                            el.style.pointerEvents = hidden ? 'none' : 'auto';
                            el.style.transition = 'opacity 0.2s';
                        }
                    });
                },
                
                setQueue(items) {
                    // items = [{name: 'animations.glb', status: 'pending'}, ...]
                    this.queue = items.map(item => ({
                        name: item.name || item,
                        status: item.status || 'pending'
                    }));
                    this.renderQueue();
                },
                
                setItemStatus(name, status) {
                    const item = this.queue.find(i => i.name === name);
                    if (item) {
                        item.status = status;
                        if (status === 'active') this.currentItem = name;
                        this.renderQueue();
                    }
                },
                
                renderQueue() {
                    const queueEl = document.getElementById('loading-queue');
                    if (!queueEl) return;
                    
                    if (this.queue.length === 0) {
                        queueEl.innerHTML = '';
                        return;
                    }
                    
                    queueEl.innerHTML = this.queue.map(item => {
                        let icon = '‚óã';
                        let cls = '';
                        if (item.status === 'done') { icon = '‚úì'; cls = 'done'; }
                        else if (item.status === 'active') { icon = '‚óâ'; cls = 'active'; }
                        else if (item.status === 'error') { icon = '‚úó'; cls = 'error'; }
                        
                        return `<div class="loading-queue-item ${cls}">
                            <span class="icon">${icon}</span>
                            <span>${item.name}</span>
                        </div>`;
                    }).join('');
                },
                
                updateProgress(percent, statusText) {
                    const bar = document.getElementById('loading-progress-bar');
                    const percentEl = document.getElementById('loading-percent');
                    const statusEl = document.getElementById('loading-status-text');
                    
                    if (bar) bar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
                    if (percentEl) percentEl.textContent = `${Math.round(percent)}%`;
                    if (statusText && statusEl) statusEl.textContent = statusText;
                }
            };
            
            // Expose globally
            window.loadingManager = loadingManager;
            
            // Legacy function for compatibility
            function hideLoadingOverlay() {
                loadingManager.hide();
            }
            
            function showLoadingOverlay(title) {
                loadingManager.show(title);
            }

            // Force immediate sync to server
            async function forceSyncToServer() {
                const currentState = JSON.stringify(viewerState);
                try {
                    const resp = await fetch(`/api/task/${taskId}/viewer-settings`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: currentState
                    });
                    if (resp.ok) {
                        lastSyncedState = currentState;
                        const mt = viewerState.modelTransform;
                        console.log('[Viewer] ‚úì FORCE SYNC to server. Transform:',
                            mt ? `pos=(${mt.position.x.toFixed(3)},${mt.position.y.toFixed(3)},${mt.position.z.toFixed(3)}) rot=(${(mt.rotation.x*180/Math.PI).toFixed(1)}¬∞,${(mt.rotation.y*180/Math.PI).toFixed(1)}¬∞,${(mt.rotation.z*180/Math.PI).toFixed(1)}¬∞)` : 'none'
                        );
                        return true;
                    }
                } catch (e) {
                    console.warn('[Viewer] Force sync failed:', e);
                }
                return false;
            }
            window.forceSyncToServer = forceSyncToServer;
            
            function startPeriodicSync() {
                console.log('[Viewer] Starting periodic sync (every 3s)');
                setInterval(async () => {
                    if (isDefaultComparisonOn) return; // Don't sync defaults
                    const currentState = JSON.stringify(viewerState);
                    if (currentState !== lastSyncedState) {
                        console.log('[Viewer] State changed, syncing...');
                        try {
                            const resp = await fetch(`/api/task/${taskId}/viewer-settings`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: currentState
                            });
                            if (resp.ok) {
                                lastSyncedState = currentState;
                                const mt = viewerState.modelTransform;
                                console.log('[Viewer] ‚úì Settings synced to server. Transform:',
                                    mt ? `pos=(${mt.position.x.toFixed(3)},${mt.position.y.toFixed(3)},${mt.position.z.toFixed(3)}) rot=(${(mt.rotation.x*180/Math.PI).toFixed(1)}¬∞,${(mt.rotation.y*180/Math.PI).toFixed(1)}¬∞,${(mt.rotation.z*180/Math.PI).toFixed(1)}¬∞)` : 'none'
                                );
                            } else {
                                console.warn('[Viewer] Sync response not ok:', resp.status);
                            }
                        } catch (e) {
                            console.warn('[Viewer] Periodic sync failed:', e);
                        }
                    }
                }, 3000); // Reduced to 3 seconds
            }
            
            // Apply viewer state to scene/model
            function applyViewerState() {
                if (!sceneInited) return;
                
                // 1. Lighting
                let mainFactor = viewerState.mainLightIntensity;
                
                // Day/Night Cycle Logic
                const hour = viewerState.timeOfDay;
                // If between 19:00 (7 PM) and 06:00 (6 AM), fade sun to zero
                if (hour >= 19.0 || hour < 6.0) {
                    // Quick fade (emulated as 0 if in range)
                    mainFactor = 0.0;
                }

                if (sunLight) {
                    sunLight.intensity = LIGHTING_CONFIG.sunIntensity * mainFactor;
                    
                    // Calculate sun position from angles
                    const phi = (90 - viewerState.sunInclination) * (Math.PI / 180);
                    const theta = (viewerState.sunRotation) * (Math.PI / 180);
                    
                    const r = 10;
                    sunLight.position.set(
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi),
                        r * Math.sin(phi) * Math.cos(theta)
                    );
                }

                if (ambientLight) {
                    ambientLight.color.set(viewerState.ambientColor);
                    ambientLight.intensity = viewerState.ambientIntensity;
                }
                
                if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * (mainFactor > 0 ? mainFactor : 0.2);
                
                // Environment intensity (Scene-level)
                const envVal = LIGHTING_CONFIG.envIntensity * viewerState.envIntensity;
                if (scene && 'environmentIntensity' in scene) {
                    scene.environmentIntensity = envVal;
                }
                
                // Background color
                if (scene) {
                    scene.background = new THREE.Color(viewerState.bgColor);
                    const preview = document.getElementById('bg-color-preview');
                    if (preview) preview.style.backgroundColor = viewerState.bgColor;
                    const picker = document.getElementById('bg-color-picker');
                    if (picker) picker.value = viewerState.bgColor;
                }

                // Fog
                if (scene) {
                    if (viewerState.fogDensity > 0) {
                        scene.fog = new THREE.FogExp2(viewerState.fogColor, viewerState.fogDensity);
                    } else {
                        scene.fog = null;
                    }
                }

                // 1.5 Bloom
                if (viewerControls) {
                    // Clamp strength to 1.0 max as requested
                    if (viewerState.bloom.strength > 1.0) {
                        viewerState.bloom.strength = 1.0;
                    }
                    viewerControls.setBloomSettings(viewerState.bloom);
                }

                // 1.6 Ground Plane
                if (viewerControls) {
                    viewerControls.setGroundParams({
                        color: viewerState.groundColor,
                        size: viewerState.groundSize
                    });
                }

                // 1.7 Shadows
                if (sunLight && sunLight.shadow) {
                    sunLight.shadow.intensity = viewerState.shadowIntensity; // Wait, shadow doesn't have intensity property in standard Three.js
                    // For shadow intensity, we usually adjust the shadow darknees via bias or just the light intensity.
                    // But in Three.js, you usually use a separate "shadow only" light or post-processing.
                    // Actually, the easiest way to control shadow "strength" is via shadow.radius (blur) and shadow.bias.
                    // Another way: use THREE.ShadowMaterial on a ground, but we have a PBR ground.
                    // Let's use shadow.radius for softness.
                    sunLight.shadow.radius = viewerState.shadowRadius;
                }
                
                // 2. Post-processing & Model Props
                if (currentModel) {
                    // Update shadow properties for all meshes
                    currentModel.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                }
                if (viewerControls) {
                    viewerControls.setModelRotation(viewerState.modelRotation);
                    // Pass all adjustments to ViewerControls
                    for (const chan in viewerState.adjustments) {
                        viewerControls.setChannelAdjustments(chan, viewerState.adjustments[chan]);
                    }

                    // Apply sync channel if active
                    if (viewerState.syncAdjChannel) {
                        const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                        if (materialChan) {
                            viewerControls.setMaterialChannel(materialChan);
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = materialChan;
                        }
                    }
                }

                if (currentModel) {
                    // Reflection intensity (env map)
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.material && child.material.envMapIntensity !== undefined) {
                            child.material.envMapIntensity = viewerState.reflectionIntensity;
                        }
                    });
                }

                // NOTE: Camera is NOT restored here - it's applied once after model loads
                // See restoreSavedCamera() function
                
                // Sync UI elements to match state
                updateViewerUI();
            }
            
            // Update UI from state
            function updateViewerUI() {
                const mainSlider = document.getElementById('light-main-slider');
                const envSlider = document.getElementById('light-env-slider');
                const reflectSlider = document.getElementById('light-reflect-slider');
                const mainVal = document.getElementById('light-main-val');
                const envVal = document.getElementById('light-env-val');
                const reflectVal = document.getElementById('light-reflect-val');
                const rotSelect = document.getElementById('viewer-rotation-select');
                const picker = document.getElementById('bg-color-picker');
                const adjChanSelect = document.getElementById('adj-target-channel');
                
                // Adjustments
                const adjBrightSlider = document.getElementById('adj-bright-slider');
                const adjContrastSlider = document.getElementById('adj-contrast-slider');
                const adjSaturSlider = document.getElementById('adj-satur-slider');
                const adjBrightVal = document.getElementById('adj-bright-val');
                const adjContrastVal = document.getElementById('adj-contrast-val');
                const adjSaturVal = document.getElementById('adj-satur-val');
                
                const adjModeSelect = document.getElementById('adj-mode-select');
                const adjMaskGroup = document.getElementById('adj-mask-group');
                const adjMaskColor = document.getElementById('adj-mask-color');
                const adjSoftSlider = document.getElementById('adj-soft-slider');
                const adjEmMultSlider = document.getElementById('adj-em-mult-slider');
                const adjInvertMask = document.getElementById('adj-invert-mask');
                const adjBlendColor = document.getElementById('adj-blend-color');
                const adjSoftVal = document.getElementById('adj-soft-val');
                const adjEmMultVal = document.getElementById('adj-em-mult-val');
                
                if (mainSlider) mainSlider.value = viewerState.mainLightIntensity;
                if (envSlider) envSlider.value = viewerState.envIntensity;
                if (reflectSlider) reflectSlider.value = viewerState.reflectionIntensity;
                if (rotSelect) rotSelect.value = viewerState.modelRotation;
                if (picker) picker.value = viewerState.bgColor;
                if (adjChanSelect) adjChanSelect.value = currentAdjChannel;

                const adjSyncBtn = document.getElementById('adj-sync-view-btn');

                const bloomStrSlider = document.getElementById('bloom-strength-slider');
                const bloomThrSlider = document.getElementById('bloom-threshold-slider');
                const bloomRadSlider = document.getElementById('bloom-radius-slider');
                const bloomStrVal = document.getElementById('bloom-strength-val');
                const bloomThrVal = document.getElementById('bloom-threshold-val');
                const bloomRadVal = document.getElementById('bloom-radius-val');

                if (bloomStrSlider) bloomStrSlider.value = viewerState.bloom.strength;
                if (bloomThrSlider) bloomThrSlider.value = viewerState.bloom.threshold;
                if (bloomRadSlider) bloomRadSlider.value = viewerState.bloom.radius;
                if (bloomStrVal) bloomStrVal.textContent = Number(viewerState.bloom.strength).toFixed(3);
                if (bloomThrVal) bloomThrVal.textContent = Number(viewerState.bloom.threshold).toFixed(3);
                if (bloomRadVal) bloomRadVal.textContent = Number(viewerState.bloom.radius).toFixed(3);

                if (adjSyncBtn) {
                    if (viewerState.syncAdjChannel) {
                        adjSyncBtn.style.background = 'var(--accent)';
                        adjSyncBtn.style.borderColor = 'var(--accent)';
                        adjSyncBtn.style.color = '#fff';
                        adjSyncBtn.style.opacity = '1';
                    } else {
                        adjSyncBtn.style.background = 'rgba(255,255,255,0.1)';
                        adjSyncBtn.style.borderColor = 'rgba(255,255,255,0.2)';
                        adjSyncBtn.style.color = '#fff';
                        adjSyncBtn.style.opacity = '0.5';
                    }
                }
                
                if (mainVal) mainVal.textContent = Number(viewerState.mainLightIntensity).toFixed(3);
                if (envVal) envVal.textContent = Number(viewerState.envIntensity).toFixed(3);
                if (reflectVal) reflectVal.textContent = Number(viewerState.reflectionIntensity).toFixed(3);

                // Update ground controls
                const groundPicker = document.getElementById('ground-color-picker');
                const groundSizeSlider = document.getElementById('ground-size-slider');
                const groundSizeVal = document.getElementById('ground-size-val');
                const shadowRadiusSlider = document.getElementById('shadow-radius-slider');
                const shadowRadiusVal = document.getElementById('shadow-radius-val');

                if (groundPicker) groundPicker.value = viewerState.groundColor;
                if (groundSizeSlider) groundSizeSlider.value = viewerState.groundSize;
                if (groundSizeVal) groundSizeVal.textContent = Number(viewerState.groundSize).toFixed(3);
                
                if (shadowRadiusSlider) shadowRadiusSlider.value = viewerState.shadowRadius;
                if (shadowRadiusVal) shadowRadiusVal.textContent = Number(viewerState.shadowRadius).toFixed(3);

                // Update Day/Night UI
                const timeSlider = document.getElementById('lighting-time-slider');
                const presetSelect = document.getElementById('lighting-preset-select');
                const sunRotSlider = document.getElementById('sun-rotation-slider');
                const sunIncSlider = document.getElementById('sun-inclination-slider');
                const ambPicker = document.getElementById('ambient-color-picker');
                const ambSlider = document.getElementById('ambient-intensity-slider');

                if (timeSlider) timeSlider.value = viewerState.timeOfDay;
                if (presetSelect) presetSelect.value = viewerState.lightingPreset;
                if (sunRotSlider) sunRotSlider.value = viewerState.sunRotation;
                if (sunIncSlider) sunIncSlider.value = viewerState.sunInclination;
                if (ambPicker) ambPicker.value = viewerState.ambientColor;
                if (ambSlider) ambSlider.value = viewerState.ambientIntensity;

                // Update Fog UI
                const fogPicker = document.getElementById('fog-color-picker');
                const fogDensitySlider = document.getElementById('fog-density-slider');
                const fogDensityVal = document.getElementById('fog-density-val');

                if (fogPicker) fogPicker.value = viewerState.fogColor;
                if (fogDensitySlider) fogDensitySlider.value = viewerState.fogDensity;
                if (fogDensityVal) fogDensityVal.textContent = Number(viewerState.fogDensity).toFixed(2);
                
                // Update AO Bake UI
                const aoSamplesSlider = document.getElementById('ao-samples-slider');
                const aoRadiusSlider = document.getElementById('ao-radius-slider');
                const aoIntensitySlider = document.getElementById('ao-intensity-slider');
                const aoSamplesVal = document.getElementById('ao-samples-val');
                const aoRadiusVal = document.getElementById('ao-radius-val');
                const aoIntensityVal = document.getElementById('ao-intensity-val');
                
                if (aoSamplesSlider) aoSamplesSlider.value = viewerState.aoSettings.samples;
                if (aoRadiusSlider) aoRadiusSlider.value = viewerState.aoSettings.radius;
                if (aoIntensitySlider) aoIntensitySlider.value = viewerState.aoSettings.intensity;
                if (aoSamplesVal) aoSamplesVal.textContent = viewerState.aoSettings.samples;
                if (aoRadiusVal) aoRadiusVal.textContent = Number(viewerState.aoSettings.radius).toFixed(2);
                if (aoIntensityVal) aoIntensityVal.textContent = Number(viewerState.aoSettings.intensity).toFixed(1);

                const currentAdj = viewerState.adjustments[currentAdjChannel];
                if (adjBrightSlider) adjBrightSlider.value = currentAdj.brightness;
                if (adjContrastSlider) adjContrastSlider.value = currentAdj.contrast;
                if (adjSaturSlider) adjSaturSlider.value = currentAdj.saturation;
                
                if (adjBrightVal) adjBrightVal.textContent = Number(currentAdj.brightness).toFixed(3);
                if (adjContrastVal) adjContrastVal.textContent = Number(currentAdj.contrast).toFixed(3);
                if (adjSaturVal) adjSaturVal.textContent = Number(currentAdj.saturation).toFixed(3);

                // Update new adjustment controls
                if (adjModeSelect) adjModeSelect.value = currentAdj.mode || 0;
                if (adjMaskGroup) {
                    if (parseInt(currentAdj.mode) === 1) {
                        adjMaskGroup.classList.remove('hidden');
                    } else {
                        adjMaskGroup.classList.add('hidden');
                    }
                }
                if (adjMaskColor) adjMaskColor.value = currentAdj.maskColor || '#ffffff';
                if (adjSoftSlider) adjSoftSlider.value = currentAdj.softness || 0.5;
                if (adjEmMultSlider) adjEmMultSlider.value = currentAdj.emissiveMult || 2.0;
                if (adjInvertMask) adjInvertMask.checked = currentAdj.invert || false;
                if (adjBlendColor) adjBlendColor.value = currentAdj.blendColor || '#ffffff';
                if (adjSoftVal) adjSoftVal.textContent = Number(currentAdj.softness || 0.5).toFixed(3);
                if (adjEmMultVal) adjEmMultVal.textContent = Number(currentAdj.emissiveMult || 2.0).toFixed(3);
            }

            // Fullscreen functionality
            function toggleFullscreen() {
                console.log('[Viewer] toggleFullscreen called, current state:', isFullscreen);

                if (!isFullscreen) {
                    enterFullscreen();
                } else {
                    exitFullscreen();
                }
            }

            function enterFullscreen() {
                console.log('[Viewer] enterFullscreen called');
                if (!renderer || !host) {
                    console.error('[Viewer] Renderer or host not available');
                    return;
                }

                // Save current canvas size
                normalCanvasSize.width = host.clientWidth;
                normalCanvasSize.height = host.clientHeight;
                console.log('[Viewer] Saved normal size:', normalCanvasSize);

                // Enter fullscreen on the viewer host element (not the whole page)
                const targetElement = host;
                let fullscreenPromise;
                
                if (targetElement.requestFullscreen) {
                    fullscreenPromise = targetElement.requestFullscreen();
                    console.log('[Viewer] Called host.requestFullscreen()');
                } else if (targetElement.webkitRequestFullscreen) {
                    fullscreenPromise = targetElement.webkitRequestFullscreen();
                    console.log('[Viewer] Called host.webkitRequestFullscreen()');
                } else if (targetElement.msRequestFullscreen) {
                    fullscreenPromise = targetElement.msRequestFullscreen();
                    console.log('[Viewer] Called host.msRequestFullscreen()');
                } else {
                    console.error('[Viewer] No fullscreen API available');
                    return;
                }

                // Handle fullscreen promise if available
                if (fullscreenPromise) {
                    fullscreenPromise.then(() => {
                        console.log('[Viewer] Fullscreen request successful');
                        isFullscreen = true;
                        
                        // Update renderer size to fill the fullscreen element
                        const devicePixelRatio = window.devicePixelRatio || 1;
                        renderer.setSize(window.screen.width, window.screen.height);
                        renderer.setPixelRatio(devicePixelRatio);
                        
                        // Update camera aspect ratio
                        if (camera) {
                            camera.aspect = window.screen.width / window.screen.height;
                            camera.updateProjectionMatrix();
                        }
                        
                        console.log('[Viewer] Renderer resized to:', window.screen.width, 'x', window.screen.height);
                        
                        updateFullscreenButton();
                        // Add ESC key handler
                        document.addEventListener('keydown', handleFullscreenKeydown);
                    }).catch((error) => {
                        console.error('[Viewer] Fullscreen request failed:', error);
                    });
                } else {
                    // Fallback for browsers that don't return a promise
                    setTimeout(() => {
                        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                            console.log('[Viewer] Fullscreen entered (fallback check)');
                            isFullscreen = true;
                            
                            // Update renderer size
                            const devicePixelRatio = window.devicePixelRatio || 1;
                            renderer.setSize(window.screen.width, window.screen.height);
                            renderer.setPixelRatio(devicePixelRatio);
                            
                            if (camera) {
                                camera.aspect = window.screen.width / window.screen.height;
                                camera.updateProjectionMatrix();
                            }
                            
                            updateFullscreenButton();
                            document.addEventListener('keydown', handleFullscreenKeydown);
                        } else {
                            console.error('[Viewer] Fullscreen request failed (fallback check)');
                        }
                    }, 100);
                }
            }

            function exitFullscreen() {
                console.log('[Viewer] exitFullscreen called');
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    console.log('[Viewer] Called document.exitFullscreen()');
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                    console.log('[Viewer] Called document.webkitExitFullscreen()');
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                    console.log('[Viewer] Called document.msExitFullscreen()');
                } else {
                    console.log('[Viewer] No exit fullscreen API available');
                }
            }

            function handleFullscreenChange() {
                const isNowFullscreen = !!(document.fullscreenElement || 
                                           document.webkitFullscreenElement || 
                                           document.msFullscreenElement);
                
                console.log('[Viewer] Fullscreen changed:', isNowFullscreen, 'was:', isFullscreen);
                
                if (isNowFullscreen && !isFullscreen) {
                    // Just entered fullscreen
                    isFullscreen = true;
                    updateFullscreenButton();
                } else if (!isNowFullscreen && isFullscreen) {
                    // Just exited fullscreen
                    isFullscreen = false;
                    
                    // Restore normal size
                    renderer.setSize(normalCanvasSize.width, normalCanvasSize.height);
                    renderer.setPixelRatio(window.devicePixelRatio || 1);
                    
                    if (camera) {
                        camera.aspect = normalCanvasSize.width / normalCanvasSize.height;
                        camera.updateProjectionMatrix();
                    }
                    
                    // Remove ESC key handler
                    document.removeEventListener('keydown', handleFullscreenKeydown);
                    
                    updateFullscreenButton();
                    console.log('[Viewer] Exited fullscreen mode');
                }
            }

            function handleFullscreenKeydown(e) {
                if (e.key === 'Escape' && isFullscreen) {
                    exitFullscreen();
                }
                if (e.key === ' ' && !e.repeat) {
                    e.preventDefault();
                    toggleFullscreen();
                }
            }

            function updateFullscreenButton() {
                const btn = document.getElementById('viewer-fullscreen-btn');
                if (!btn) return;

                const icon = btn.querySelector('span:first-child');
                const text = btn.querySelector('span:last-child');

                if (isFullscreen) {
                    if (icon) icon.textContent = '‚õ∂';
                    if (text) text.textContent = 'Exit FS';
                    btn.title = 'Exit Fullscreen (ESC)';
                } else {
                    if (icon) icon.textContent = '‚õ∂';
                    if (text) text.textContent = 'Fullscreen';
                    btn.title = 'Fullscreen (Space)';
                }
            }

            // Listen for fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);

            // Check if camera lost model and auto-recenter
            function checkCameraLost() {
                if (!currentModel || !camera || !controls) return;
                
                const box = new THREE.Box3().setFromObject(currentModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Check if camera is too far from model center
                const distanceFromModel = camera.position.distanceTo(center);
                const maxAllowedDistance = Math.max(maxDim * 10, 50);
                
                if (distanceFromModel > maxAllowedDistance) {
                    console.log('[Viewer] Camera lost - auto-centering, distance:', distanceFromModel.toFixed(2));
                    if (viewerControls && viewerControls.focusOnModel) {
                        viewerControls.focusOnModel(true);
                    }
                }
            }

            // Run camera lost check periodically (every 2 seconds)
            setInterval(checkCameraLost, 2000);

            // Setup viewer control event listeners
            function setupViewerControls() {
                // EyeDropper implementation
                async function activateEyeDropper(targetId) {
                    if (!window.EyeDropper) {
                        console.warn('EyeDropper API not supported');
                        return;
                    }
                    const eyeDropper = new EyeDropper();
                    try {
                        const result = await eyeDropper.open();
                        const color = result.sRGBHex;
                        const input = document.getElementById(targetId);
                        if (input) {
                            input.value = color;
                            // Trigger input event manually
                            input.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    } catch (e) {
                        console.log('EyeDropper cancelled or failed:', e);
                    }
                }

                document.querySelectorAll('.eye-dropper-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        activateEyeDropper(btn.dataset.target);
                    });
                });

                const mainSlider = document.getElementById('light-main-slider');
                const envSlider = document.getElementById('light-env-slider');
                const reflectSlider = document.getElementById('light-reflect-slider');
                const rotSelect = document.getElementById('viewer-rotation-select');
                const picker = document.getElementById('bg-color-picker');
                const adjChanSelect = document.getElementById('adj-target-channel');
                
                // Adjustments
                const adjBrightSlider = document.getElementById('adj-bright-slider');
                const adjContrastSlider = document.getElementById('adj-contrast-slider');
                const adjSaturSlider = document.getElementById('adj-satur-slider');
                
                mainSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.mainLightIntensity = val;
                    if (sunLight) sunLight.intensity = LIGHTING_CONFIG.sunIntensity * val;
                    if (ambientLight) ambientLight.intensity = LIGHTING_CONFIG.ambientIntensity * val;
                    if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * val;
                    document.getElementById('light-main-val').textContent = val.toFixed(3);
                });
                
                envSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.envIntensity = val;
                    if (scene && 'environmentIntensity' in scene) {
                        scene.environmentIntensity = LIGHTING_CONFIG.envIntensity * val;
                    }
                    document.getElementById('light-env-val').textContent = val.toFixed(3);
                });
                
                reflectSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.reflectionIntensity = val;
                    if (currentModel) {
                        currentModel.traverse(child => {
                            if (child.isMesh && child.material && child.material.envMapIntensity !== undefined) {
                                child.material.envMapIntensity = val;
                            }
                        });
                    }
                    document.getElementById('light-reflect-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-strength-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.strength = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-strength-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-threshold-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.threshold = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-threshold-val').textContent = val.toFixed(3);
                });

                document.getElementById('bloom-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.bloom.radius = val;
                    if (viewerControls) viewerControls.setBloomSettings(viewerState.bloom);
                    document.getElementById('bloom-radius-val').textContent = val.toFixed(3);
                });

                rotSelect?.addEventListener('change', (e) => {
                    viewerState.modelRotation = e.target.value;
                    applyViewerState();
                });

                picker?.addEventListener('input', (e) => {
                    viewerState.bgColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('ground-color-picker')?.addEventListener('input', (e) => {
                    viewerState.groundColor = e.target.value;
                    if (viewerControls) viewerControls.setGroundParams({ color: e.target.value });
                });

                document.getElementById('ground-size-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.groundSize = val;
                    if (viewerControls) viewerControls.setGroundParams({ size: val });
                    document.getElementById('ground-size-val').textContent = val.toFixed(3);
                });

                document.getElementById('shadow-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.shadowRadius = val;
                    if (sunLight && sunLight.shadow) {
                        sunLight.shadow.radius = val;
                    }
                    document.getElementById('shadow-radius-val').textContent = val.toFixed(3);
                });

                document.getElementById('lighting-time-slider')?.addEventListener('input', (e) => {
                    viewerState.timeOfDay = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('lighting-preset-select')?.addEventListener('change', (e) => {
                    const p = e.target.value;
                    viewerState.lightingPreset = p;
                    if (p === 'day') { viewerState.timeOfDay = 12.0; viewerState.sunRotation = 45; viewerState.sunInclination = 45; }
                    else if (p === 'night') { viewerState.timeOfDay = 0.0; viewerState.sunRotation = 180; viewerState.sunInclination = 10; }
                    else if (p === 'sunset') { viewerState.timeOfDay = 18.5; viewerState.sunRotation = 260; viewerState.sunInclination = 5; }
                    applyViewerState();
                    updateViewerUI();
                });

                document.getElementById('sun-rotation-slider')?.addEventListener('input', (e) => {
                    viewerState.sunRotation = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('sun-inclination-slider')?.addEventListener('input', (e) => {
                    viewerState.sunInclination = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('ambient-color-picker')?.addEventListener('input', (e) => {
                    viewerState.ambientColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('ambient-intensity-slider')?.addEventListener('input', (e) => {
                    viewerState.ambientIntensity = parseFloat(e.target.value);
                    applyViewerState();
                });

                document.getElementById('fog-color-picker')?.addEventListener('input', (e) => {
                    viewerState.fogColor = e.target.value;
                    applyViewerState();
                });

                document.getElementById('fog-density-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.fogDensity = val;
                    document.getElementById('fog-density-val').textContent = val.toFixed(2);
                    applyViewerState();
                });
                
                // AO Bake Settings listeners
                let aoRebakeTimeout = null;
                
                function scheduleAORebake() {
                    // Debounce rebake - wait 300ms after last change
                    if (aoRebakeTimeout) clearTimeout(aoRebakeTimeout);
                    aoRebakeTimeout = setTimeout(() => {
                        if (viewerControls) {
                            console.log('[Viewer] Auto-rebaking AO with settings:', viewerState.aoSettings);
                            viewerControls.setAOSettings(viewerState.aoSettings);
                            viewerControls.rebakeAO();
                        }
                    }, 300);
                }
                
                document.getElementById('ao-samples-slider')?.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    viewerState.aoSettings.samples = val;
                    document.getElementById('ao-samples-val').textContent = val;
                });
                document.getElementById('ao-samples-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-radius-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.aoSettings.radius = val;
                    document.getElementById('ao-radius-val').textContent = val.toFixed(2);
                });
                document.getElementById('ao-radius-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-intensity-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.aoSettings.intensity = val;
                    document.getElementById('ao-intensity-val').textContent = val.toFixed(1);
                });
                document.getElementById('ao-intensity-slider')?.addEventListener('change', scheduleAORebake);
                
                document.getElementById('ao-rebake-btn')?.addEventListener('click', () => {
                    if (viewerControls) {
                        console.log('[Viewer] Manual AO rebake with settings:', viewerState.aoSettings);
                        viewerControls.setAOSettings(viewerState.aoSettings);
                        viewerControls.rebakeAO();
                    }
                });

                adjChanSelect?.addEventListener('change', (e) => {
                    currentAdjChannel = e.target.value;
                    if (viewerState.syncAdjChannel && viewerControls) {
                        const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                        if (materialChan) {
                            viewerControls.setMaterialChannel(materialChan);
                            // Update the main channel selector UI if it exists
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = materialChan;
                        }
                    }
                    updateViewerUI();
                });

                const adjSyncBtn = document.getElementById('adj-sync-view-btn');
                adjSyncBtn?.addEventListener('click', () => {
                    viewerState.syncAdjChannel = !viewerState.syncAdjChannel;
                    if (viewerControls) {
                        if (viewerState.syncAdjChannel) {
                            const materialChan = ADJ_CHANNEL_TO_VIEWER[currentAdjChannel];
                            if (materialChan) {
                                viewerControls.setMaterialChannel(materialChan);
                                const mainChanSelect = document.getElementById('viewer-channel-select');
                                if (mainChanSelect) mainChanSelect.value = materialChan;
                            }
                        } else {
                            // Revert to PBR
                            viewerControls.setMaterialChannel(1); // MaterialChannel.PBR
                            const mainChanSelect = document.getElementById('viewer-channel-select');
                            if (mainChanSelect) mainChanSelect.value = 1;
                        }
                    }
                    updateViewerUI();
                });

                adjBrightSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].brightness = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-bright-val').textContent = val.toFixed(3);
                });

                adjContrastSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].contrast = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-contrast-val').textContent = val.toFixed(3);
                });

                adjSaturSlider?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].saturation = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-satur-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-mode-select')?.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value);
                    viewerState.adjustments[currentAdjChannel].mode = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    updateViewerUI();
                });

                document.getElementById('adj-mask-color')?.addEventListener('input', (e) => {
                    viewerState.adjustments[currentAdjChannel].maskColor = e.target.value;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                document.getElementById('adj-soft-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].softness = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-soft-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-em-mult-slider')?.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    viewerState.adjustments[currentAdjChannel].emissiveMult = val;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                    document.getElementById('adj-em-mult-val').textContent = val.toFixed(3);
                });

                document.getElementById('adj-invert-mask')?.addEventListener('change', (e) => {
                    viewerState.adjustments[currentAdjChannel].invert = e.target.checked;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                document.getElementById('adj-blend-color')?.addEventListener('input', (e) => {
                    viewerState.adjustments[currentAdjChannel].blendColor = e.target.value;
                    if (viewerControls) {
                        viewerControls.setChannelAdjustments(currentAdjChannel, viewerState.adjustments[currentAdjChannel]);
                    }
                });

                // Global keyboard shortcuts (only when viewer is focused)
                document.addEventListener('keydown', (e) => {
                    // Space key for fullscreen toggle - only if viewer focused
                    if (e.key === ' ' && !e.repeat && viewerFocused && !e.target.matches('input, textarea, select')) {
                        e.preventDefault();
                        toggleFullscreen();
                    }
                });
            }

            async function initScene() {
                if (sceneInited) return;
                sceneInited = true;

                const videoContainer = document.getElementById('video-container');
                if (videoContainer) videoContainer.classList.remove('hidden');
                
                wrap.classList.remove('hidden');
                setStatus('Initializing...');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(LIGHTING_CONFIG.bgColor);

                // Renderer (PBR critical settings from config)
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = LIGHTING_CONFIG.toneMapping;
                renderer.toneMappingExposure = LIGHTING_CONFIG.toneMappingExposure;
                renderer.physicallyCorrectLights = true;

                host.innerHTML = '';
                host.appendChild(renderer.domElement);

                camera = new THREE.PerspectiveCamera(45, 1, 0.01, 1000);
                // Static camera: above-side view for T-pose preparation
                // Position: front-right at 45¬∞ angle, looking at model center
                camera.position.set(2.5, 2.0, 2.5);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.target.set(0, 1.0, 0);
                
                // Disable built-in zoom - we use custom inertia zoom
                controls.enableZoom = false;
                controls.minDistance = 1;       // Can't zoom closer than 1 meter
                controls.maxDistance = 10;      // Can't zoom further than 10 meters
                controls.maxPolarAngle = Math.PI * 0.9;  // Prevent going under ground
                
                // Custom zoom with inertia
                zoomState = {
                    velocity: 0,
                    damping: 0.92,      // How fast velocity decays (0.9 = fast, 0.98 = slow)
                    sensitivity: 0.08,  // How much each wheel tick adds to velocity
                    minDist: 1,
                    maxDist: 10
                };
                
                // Wheel handler - accumulate velocity
                renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    // Normalize wheel delta across browsers
                    const delta = e.deltaY > 0 ? 1 : -1;
                    zoomState.velocity += delta * zoomState.sensitivity;
                    // Stop auto-rotate on interaction
                    controls.autoRotate = false;
                }, { passive: false });
                
                // Update zoom with inertia (called in render loop)
                window.updateZoomInertia = function() {
                    if (Math.abs(zoomState.velocity) < 0.0001) {
                        zoomState.velocity = 0;
                        return;
                    }
                    
                    // Get current distance from target
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target);
                    let distance = direction.length();
                    
                    // Apply velocity to distance
                    distance += zoomState.velocity;
                    
                    // Clamp distance
                    distance = Math.max(zoomState.minDist, Math.min(zoomState.maxDist, distance));
                    
                    // Update camera position
                    direction.normalize().multiplyScalar(distance);
                    camera.position.copy(controls.target).add(direction);
                    
                    // Apply damping to velocity
                    zoomState.velocity *= zoomState.damping;
                };
                
                // No auto-rotation (T-pose preparation mode)
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0;
                
                // OrbitControls enabled - user can adjust camera, position saves to settings
                controls.enabled = true;

                controls.update();

                // TransformControls disabled - using custom GLB gizmos instead
                // transform = new TransformControls(camera, renderer.domElement);
                // transform.enabled = false;
                // scene.add(transform);
                transform = null; // Keep variable defined but unused

                // Lighting setup (from LIGHTING_CONFIG)
                sunLight = new THREE.DirectionalLight(LIGHTING_CONFIG.sunColor, LIGHTING_CONFIG.sunIntensity);
                sunLight.position.set(...LIGHTING_CONFIG.sunPosition);
                sunLight.castShadow = true;
                
                // Optimized shadow settings
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.near = 0.1;
                sunLight.shadow.camera.far = 100;
                
                // Fit frustum to model area
                const s = 5; 
                sunLight.shadow.camera.left = -s;
                sunLight.shadow.camera.right = s;
                sunLight.shadow.camera.top = s;
                sunLight.shadow.camera.bottom = -s;
                
                // Bias to prevent self-shadowing artifacts
                sunLight.shadow.bias = -0.0001; 
                sunLight.shadow.normalBias = 0.02; // Critical for PBR materials
                
                scene.add(sunLight);
                
                // Add shadow target to ensure it points to center
                scene.add(sunLight.target);
                sunLight.target.position.set(0, 0, 0);

                ambientLight = new THREE.AmbientLight(LIGHTING_CONFIG.ambientColor, LIGHTING_CONFIG.ambientIntensity);
                scene.add(ambientLight);

                hemiLight = new THREE.HemisphereLight(
                    LIGHTING_CONFIG.hemiSkyColor,
                    LIGHTING_CONFIG.hemiGroundColor,
                    LIGHTING_CONFIG.hemiIntensity
                );
                scene.add(hemiLight);

                // Composer & Bloom setup
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(host.clientWidth, host.clientHeight),
                    viewerState.bloom.strength,
                    viewerState.bloom.radius,
                    viewerState.bloom.threshold
                );
                composer.addPass(bloomPass);

                const outputPass = new OutputPass();
                composer.addPass(outputPass);

                // Ground Plane
                const groundGeo = new THREE.PlaneGeometry(10, 10); // Much larger to handle gradient fade
                const groundMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.8,
                    metalness: 0.1,
                    transparent: true
                });

                groundMat.onBeforeCompile = (shader) => {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <common>',
                        `
                        #include <common>
                        varying vec2 vWorldUv;
                        `
                    );
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <common>',
                        `
                        #include <common>
                        varying vec2 vWorldUv;
                        `
                    );
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        #include <begin_vertex>
                        vWorldUv = uv;
                        `
                    );
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <output_fragment>',
                        `
                        // Radial alpha gradient
                        // vWorldUv is 0..1 over the 10x10 plane. 
                        // Center is 0.5, 0.5. 
                        // 1.5m radius in 10m plane is 1.5/10 = 0.15 normalized units.
                        float dist = distance(vWorldUv, vec2(0.5));
                        float radius = 0.45; // Normalized radius for fade (starts at 1.5m, fades to 4.5m)
                        
                        // Long entry: stay opaque for 1.5m, then fade out slowly
                        // 1.5m is 0.15 dist. Let's fade from 0.15 to 0.45.
                        float alpha = 1.0 - smoothstep(0.15, 0.48, dist);
                        
                        // Apply to output
                        gl_FragColor.a *= alpha;
                        #include <output_fragment>
                        `
                    );
                };

                const groundPlane = new THREE.Mesh(groundGeo, groundMat);
                groundPlane.rotation.x = -Math.PI / 2;
                groundPlane.position.set(0, 0, 0);
                groundPlane.receiveShadow = true;
                scene.add(groundPlane);
                
                // Setup viewer controls and load saved settings
                setupViewerControls();
                loadViewerSettings();

                function resize() {
                    const w = host.clientWidth || 360;
                    const h = host.clientHeight || 640;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h, false);
                    if (composer) composer.setSize(w, h);
                    if (bloomPass) bloomPass.resolution.set(w, h);
                }
                window.addEventListener('resize', resize);
                resize();

                await loadEnvironment(scene);

                // Initialize ViewerControls
                viewerControls = new ViewerControls({
                    scene,
                    camera,
                    renderer,
                    controls,
                    transform,
                    groundPlane, // Pass the ground plane mesh
                    bloomPass, // Pass the bloom pass
                    t,
                    onSaveDefaultSettings: () => saveDefaultViewerSettings('hotkey'),
                    onCameraModeChange: (mode) => {
                        const label = document.getElementById('viewer-camera-label');
                        const modeLabels = {
                            'static': 'Static',
                            'orbit': 'Orbit',
                            'fly': 'Fly'
                        };
                        if (label) label.textContent = modeLabels[mode] || mode;
                        console.log('[Viewer] Camera mode changed to:', mode);
                        
                        // Auto-focus on model when camera mode changes
                        if (viewerControls && currentModel) {
                            viewerControls.focusOnModel(true);  // true = reset angle
                        }
                    },
                    onChannelChange: (channel) => {
                        const select = document.getElementById('viewer-channel-select');
                        if (select) select.value = String(channel);
                        console.log('[Viewer] Channel changed to:', channel);
                    },
                    onRigTypeChange: (rigType) => {
                        const select = document.getElementById('viewer-rigtype-select');
                        if (select) select.value = rigType;
                        console.log('[Viewer] Rig type changed to:', rigType);
                    }
                });
                window.viewerControls = viewerControls; // Make global for debugging
                
                // Initialize TransformManager (QWER modes)
                transformManager = new TransformManager({
                    scene,
                    camera,
                    renderer,
                    controls,
                    onModeChange: (mode, prevMode) => {
                        console.log('[Viewer] Transform mode changed:', prevMode, '->', mode);
                        updateTransformToolbarUI(mode);
                        showSelectionInfo(transformManager?.selectionSystem?.getSelected());
                    },
                    onTransform: (object, mode) => {
                        console.log('[Viewer] Object transformed:', object?.name, 'mode:', mode);
                        // Sync transform values to context panel
                        if (window.updateContextPanelValues) {
                            window.updateContextPanelValues(object);
                        }
                    }
                });
                await transformManager.init();
                window.transformManager = transformManager; // For debugging
                
                // Initialize T-Pose Reference with emissive cyan color
                tPoseReference = new TPoseReference(scene, {
                    color: 0x00ffff,      // Cyan - visible against dark backgrounds
                    opacity: 0.5,          // Semi-transparent
                    emissiveIntensity: 1.0
                });
                await tPoseReference.load();
                window.tPoseReference = tPoseReference; // For debugging
                
                // Expose methods for UI control
                window.setTPoseColor = (color) => tPoseReference?.setColor(color);
                window.setTPoseOpacity = (opacity) => tPoseReference?.setOpacity(opacity);
                
                // Initialize Hierarchy Navigator
                hierarchyNavigator = new HierarchyNavigator({
                    selectionSystem: transformManager.selectionSystem,
                    onNavigate: (level, action) => {
                        console.log('[Viewer] Hierarchy navigation:', action, level?.name || level?.type);
                        window.updateHierarchyUI();
                    }
                });
                window.hierarchyNavigator = hierarchyNavigator; // For debugging
                
                // Initialize auto-tests (available in console)
                transformTests = new TransformSystemTests();
                window.transformTests = transformTests;
                window.runTransformTests = () => transformTests.runAll(transformManager, viewerControls, tPoseReference);
                console.log('[Viewer] Transform system ready. Run window.runTransformTests() to test.');
                
                // Setup QWER toolbar UI
                setupTransformToolbar();
                setupHierarchyNav();
                setupTPoseToggle();
                setupSnapSettings();
                setupSettingsToggle();
                setupViewModeSelector();
                setupContextPanels();

                // Apply settings again now that viewerControls is ready
                applyViewerState();

                // Initialize RigEditor
                rigEditor = new RigEditor({
                    taskId,
                    taskStatus: 'created',
                    rigType: RigType.CHAR,
                    t,
                    onRestart: async (rigType) => {
                        console.log('[RigEditor] Restarting with rig type:', rigType);
                        // Get transform params to send to worker
                        const transformParams = window.getModelTransform ? window.getModelTransform() : null;
                        console.log('[RigEditor] Sending transform:', transformParams);
                        // Call the restart API
                        const resp = await fetch(`/api/task/${taskId}/restart`, {
                            method: 'POST',
                            headers: transformParams ? { 'Content-Type': 'application/json' } : {},
                            body: transformParams ? JSON.stringify(transformParams) : undefined
                        });
                        if (!resp.ok) {
                            const data = await resp.json().catch(() => ({}));
                            throw new Error(data.detail || 'Restart failed');
                        }
                        // Reload the page to see updated status
                        window.location.reload();
                    },
                    onRigTypeChange: (rigType) => {
                        console.log('[RigEditor] Rig type changed to:', rigType);
                        if (viewerControls) {
                            viewerControls.setRigType(rigType);
                        }
                    }
                });

                // Wire up UI elements
                setupViewerUI();

                // Keyboard shortcuts (QWER, T, Space, ESC, F, 1-7, 9)
                // Only active when viewer is focused (user clicked on it)
                document.addEventListener('keydown', (e) => {
                    // Don't capture if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
                    
                    // Don't capture if viewer is not focused
                    if (!viewerFocused) return;
                    
                    const key = e.key.toLowerCase();
                    
                    // QWER - Transform modes
                    if (transformManager && transformManager.handleKeyDown(key)) {
                        e.preventDefault();
                        return;
                    }
                    
                    // T - Toggle T-pose reference
                    if (key === 't' && tPoseReference) {
                        const visible = tPoseReference.toggle();
                        const btn = document.getElementById('tpose-toggle-btn');
                        if (btn) btn.classList.toggle('active', visible);
                        console.log('[Viewer] T-pose toggle:', visible);
                        e.preventDefault();
                        return;
                    }
                    
                    // Space - Enter hierarchy children (override fullscreen when in viewer)
                    if (key === ' ' && hierarchyNavigator && transformManager?.selectionSystem?.getSelected()) {
                        hierarchyNavigator.enterChildren();
                        e.preventDefault();
                        return;
                    }
                    
                    // Backspace - Go to parent in hierarchy
                    if (key === 'backspace' && hierarchyNavigator) {
                        if (hierarchyNavigator.goToParent()) {
                            e.preventDefault();
                            return;
                        }
                    }
                    
                    // ViewerControls keyboard (1-7 channels, 9 camera, F focus, Z save)
                    if (viewerControls && viewerControls.handleKeyDown(e.key)) {
                        e.preventDefault();
                        return;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (!viewerFocused) return;
                    if (viewerControls) viewerControls.handleKeyUp(e.key);
                });

                // Mouse move for fly camera (handled by ViewerControls via right-drag)
                // No pointer lock needed - fly mode uses right-drag for mouse look

                let frameCount = 0;
                let lastTime = performance.now();
                const fpsLabel = document.getElementById('viewer-fps');

                // ============================================================
                // Transform System UI Setup Functions
                // ============================================================
                
                // Setup QWER toolbar button clicks
                function setupTransformToolbar() {
                    const buttons = {
                        'transform-select-btn': TransformMode.SELECT,
                        'transform-move-btn': TransformMode.MOVE,
                        'transform-rotate-btn': TransformMode.ROTATE,
                        'transform-scale-btn': TransformMode.SCALE
                    };

                    Object.entries(buttons).forEach(([id, mode]) => {
                        const btn = document.getElementById(id);
                        if (btn) {
                            btn.addEventListener('click', () => {
                                if (transformManager) {
                                    transformManager.setMode(mode);
                                }
                                // Auto-show gizmos when switching QWER modes
                                if (viewerControls && !viewerControls.gizmosVisible) {
                                    viewerControls.setGizmosVisibility(true);
                                    const gizmosBtn = document.getElementById('viewer-gizmos-btn');
                                    if (gizmosBtn) {
                                        gizmosBtn.style.opacity = '1';
                                        gizmosBtn.style.background = 'rgba(0,0,0,0.75)';
                                    }
                                    console.log('[Viewer] Auto-enabled gizmos on QWER mode change');
                                }
                            });
                        }
                    });

                    // Reset to origin button
                    const resetBtn = document.getElementById('transform-reset-btn');
                    if (resetBtn) {
                        resetBtn.addEventListener('click', () => {
                            if (currentModel) {
                                // Reset model transform to origin
                                currentModel.position.set(0, 0, 0);
                                currentModel.rotation.set(0, 0, 0);
                                currentModel.scale.set(1, 1, 1);
                                
                                // Update viewerState
                                viewerState.modelTransform = {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0 },
                                    scale: { x: 1, y: 1, z: 1 }
                                };
                                
                                // Sync to server
                                if (typeof forceSyncToServer === 'function') {
                                    forceSyncToServer();
                                }
                                
                                console.log('[Viewer] Model reset to origin (0,0,0)');
                            }
                        });
                    }

                    console.log('[Viewer] QWER toolbar setup complete');
                }
                
                // Update QWER toolbar active state and context panel
                function updateTransformToolbarUI(mode) {
                    const modeToBtn = {
                        [TransformMode.SELECT]: 'transform-select-btn',
                        [TransformMode.MOVE]: 'transform-move-btn',
                        [TransformMode.ROTATE]: 'transform-rotate-btn',
                        [TransformMode.SCALE]: 'transform-scale-btn'
                    };
                    
                    // Remove active from all
                    document.querySelectorAll('#qwer-toolbar button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Add active to current
                    const activeBtn = document.getElementById(modeToBtn[mode]);
                    if (activeBtn) activeBtn.classList.add('active');
                    
                    // Update context panel
                    if (window.updateContextPanel) {
                        window.updateContextPanel(mode);
                    }
                }
                
                // Setup hierarchy navigation buttons
                function setupHierarchyNav() {
                    const upBtn = document.getElementById('hierarchy-up-btn');
                    const downBtn = document.getElementById('hierarchy-down-btn');
                    
                    if (upBtn) {
                        upBtn.addEventListener('click', () => {
                            if (hierarchyNavigator) hierarchyNavigator.goToParent();
                        });
                    }
                    
                    if (downBtn) {
                        downBtn.addEventListener('click', () => {
                            if (hierarchyNavigator) hierarchyNavigator.enterChildren();
                        });
                    }
                    
                    console.log('[Viewer] Hierarchy nav setup complete');
                }
                
                // Update hierarchy UI (global for access from loadGlb/loadFbx)
                window.updateHierarchyUI = function() {
                    if (!hierarchyNavigator) return;
                    
                    const currentEl = document.getElementById('hierarchy-current');
                    const upBtn = document.getElementById('hierarchy-up-btn');
                    
                    if (currentEl) {
                        currentEl.textContent = hierarchyNavigator.getCurrentLevelName();
                    }
                    
                    if (upBtn) {
                        upBtn.disabled = hierarchyNavigator.navigationStack.length === 0;
                    }
                }
                
                // Setup T-pose toggle button and controls
                function setupTPoseToggle() {
                    const btn = document.getElementById('tpose-toggle-btn');
                    const colorPicker = document.getElementById('tpose-color');
                    const opacitySlider = document.getElementById('tpose-opacity');
                    
                    if (btn) {
                        btn.addEventListener('click', () => {
                            if (tPoseReference) {
                                const visible = tPoseReference.toggle();
                                btn.classList.toggle('active', visible);
                            }
                        });
                    }
                    
                    if (colorPicker) {
                        colorPicker.addEventListener('input', (e) => {
                            if (tPoseReference) {
                                tPoseReference.setColor(e.target.value);
                            }
                        });
                    }
                    
                    if (opacitySlider) {
                        opacitySlider.addEventListener('input', (e) => {
                            if (tPoseReference) {
                                tPoseReference.setOpacity(parseFloat(e.target.value));
                            }
                        });
                    }
                    
                    console.log('[Viewer] T-pose toggle and controls setup complete');
                }
                
                // Setup snap settings inputs (now integrated into context panels)
                function setupSnapSettings() {
                    const moveInput = document.getElementById('snap-move');
                    const rotateInput = document.getElementById('snap-rotate');
                    const scaleInput = document.getElementById('snap-scale');
                    const ctxSnapMove = document.getElementById('ctx-snap-move');
                    const ctxSnapRotate = document.getElementById('ctx-snap-rotate');
                    const ctxSnapScale = document.getElementById('ctx-snap-scale');
                    
                    const updateSnap = () => {
                        if (transformManager) {
                            // Check which snap checkboxes are enabled
                            const moveEnabled = ctxSnapMove?.checked ?? true;
                            const rotateEnabled = ctxSnapRotate?.checked ?? true;
                            const scaleEnabled = ctxSnapScale?.checked ?? true;
                            
                            transformManager.setSnapSettings({
                                move: moveEnabled ? (parseFloat(moveInput?.value) || 0.1) : 0,
                                rotation: rotateEnabled ? (parseFloat(rotateInput?.value) || 15) : 0,
                                scale: scaleEnabled ? (parseFloat(scaleInput?.value) || 0.1) : 0
                            });
                        }
                    };
                    
                    [moveInput, rotateInput, scaleInput].forEach(input => {
                        if (input) input.addEventListener('change', updateSnap);
                    });
                    
                    [ctxSnapMove, ctxSnapRotate, ctxSnapScale].forEach(checkbox => {
                        if (checkbox) checkbox.addEventListener('change', updateSnap);
                    });
                    
                    console.log('[Viewer] Snap settings setup complete');
                }
                
                // Setup Settings Toggle Button
                function setupSettingsToggle() {
                    const btn = document.getElementById('settings-toggle-btn');
                    const lightingWrap = document.getElementById('viewer-lighting-wrap');
                    const adjustmentsWrap = document.getElementById('viewer-adjustments-wrap');
                    const contextPanel = document.getElementById('transform-context-panel');
                    const hierarchyWrap = document.getElementById('viewer-hierarchy-wrap');
                    const transformWrap = document.getElementById('viewer-transform-wrap');

                    if (btn) {
                        btn.addEventListener('click', () => {
                            btn.classList.toggle('active');
                            const isActive = btn.classList.contains('active');

                            // Toggle settings panels visibility
                            if (lightingWrap) lightingWrap.classList.toggle('hidden', !isActive);
                            if (adjustmentsWrap) adjustmentsWrap.classList.toggle('hidden', !isActive);
                            
                            // Hide other panels when settings are open
                            if (contextPanel) contextPanel.classList.toggle('hidden', isActive);
                            if (hierarchyWrap) hierarchyWrap.classList.toggle('hidden', isActive);
                            // Keep QWER toolbar visible but hide context panel inside
                            if (transformWrap) {
                                const qwerToolbar = transformWrap.querySelector('.qwer-toolbar');
                                if (qwerToolbar) qwerToolbar.style.display = isActive ? 'none' : 'flex';
                            }

                            console.log('[Viewer] Settings toggle:', isActive);
                        });
                    }
                    console.log('[Viewer] Settings toggle setup complete');
                }
                
                // Setup View Mode Selector (T-Pose / RIG / Animation)
                // Note: currentModelType is defined at outer scope for access by waitAndInitViewer
                
                // Model cache to avoid reloading large files
                const modelCache = {
                    animations: null,  // Cached animations model (100MB+)
                    prepared: null,    // Cached prepared model
                    animationsData: null, // Cached animations array
                    preparedData: null
                };
                window.modelCache = modelCache; // Debug access
                
                // Swap cached model into scene (fast, no network)
                function swapToCache(cacheKey) {
                    if (!modelCache[cacheKey]) return false;
                    
                    console.log(`[Viewer] Swapping to cached ${cacheKey} model`);
                    
                    // Remove current model
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    // Add cached model
                    currentModel = modelCache[cacheKey];
                    scene.add(currentModel);
                    
                    // Set root model for transforms
                    if (transformManager) transformManager.setRootModel(currentModel);
                    
                    // Restore animations if any
                    if (modelCache[cacheKey + 'Data']) {
                        animations = modelCache[cacheKey + 'Data'];
                        if (mixer) {
                            mixer.stopAllAction();
                        }
                        if (animations.length > 0) {
                            mixer = new THREE.AnimationMixer(currentModel);
                        }
                    }
                    
                    // Update references
                    if (transformManager) transformManager.setModel(currentModel);
                    if (hierarchyNavigator) {
                        hierarchyNavigator.setModel(currentModel);
                        window.updateHierarchyUI?.();
                    }
                    if (window.recreateWireframe) window.recreateWireframe();
                    
                    return true;
                }
                
                // Hide all UI during loading
                function setLoadingUIState(isLoading) {
                    const elementsToHide = [
                        'viewer-settings-area',
                        'viewer-adjustments-wrap', 
                        'viewer-hierarchy-wrap',
                        'viewer-transform-wrap',
                        'viewer-rigtype-wrap'
                    ];
                    
                    elementsToHide.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.opacity = isLoading ? '0.3' : '1';
                            el.style.pointerEvents = isLoading ? 'none' : 'auto';
                        }
                    });
                }
                
                function setupViewModeSelector() {
                    const tposeBtn = document.getElementById('view-mode-tpose');
                    const rigBtn = document.getElementById('view-mode-rig');
                    const animBtn = document.getElementById('view-mode-anim');
                    const allBtns = [tposeBtn, rigBtn, animBtn];
                    
                    const setActiveMode = async (mode) => {
                        console.log('[Viewer] setActiveMode:', mode, 
                            'currentType:', currentModelType, 
                            'cacheHasPrepared:', !!modelCache.prepared,
                            'cacheHasAnimations:', !!modelCache.animations);
                        allBtns.forEach(b => b?.classList.remove('active'));
                        
                        switch (mode) {
                            case 'tpose':
                            case 'rig':
                                // For T-Pose and RIG modes, load prepared.glb (static model for editing)
                                if (mode === 'tpose') {
                                    tposeBtn?.classList.add('active');
                                    // Show T-Pose reference and update button state
                                    if (tPoseReference) {
                                        tPoseReference.setVisible(true);
                                        const tposeToggleBtn = document.getElementById('tpose-toggle-btn');
                                        if (tposeToggleBtn) tposeToggleBtn.classList.add('active');
                                    }
                                } else {
                                    rigBtn?.classList.add('active');
                                    // Hide T-Pose reference
                                    if (tPoseReference) {
                                        tPoseReference.setVisible(false);
                                        const tposeToggleBtn = document.getElementById('tpose-toggle-btn');
                                        if (tposeToggleBtn) tposeToggleBtn.classList.remove('active');
                                    }
                                }
                                
                                // Load prepared.glb if not already loaded
                                if (currentModelType !== 'prepared') {
                                    // Try cache first (instant swap)
                                    if (modelCache.prepared && swapToCache('prepared')) {
                                        currentModelType = 'prepared';
                                        // Stop animations
                                        if (mixer) {
                                            mixer.stopAllAction();
                                        }
                                        animations.length = 0;
                                        
                                        // Hide animation UI after cache swap to prepared
                                        if (sel) sel.classList.add('hidden');
                                        if (playBtn) playBtn.classList.add('hidden');
                                        if (pauseBtn) pauseBtn.classList.add('hidden');
                                        
                                        console.log('[Viewer] ‚úì Swapped to cached prepared model');
                                    } else {
                                        // Need to load from server
                                        console.log('[Viewer] Loading prepared.glb from server...');
                                        setLoadingUIState(true);
                                        loadingManager.show('Loading Model');
                                        loadingManager.setQueue([{ name: 'Prepared Model', status: 'pending' }]);
                                        const ok = await loadModel(`/api/task/${taskId}/prepared.glb`, 'Prepared Model');
                                        if (ok) {
                                            currentModelType = 'prepared';
                                            // Cache for future use
                                            modelCache.prepared = currentModel;
                                            modelCache.preparedData = [];
                                            console.log('[Viewer] ‚úì Cached prepared model');
                                            // Stop animations if any
                                            if (mixer) {
                                                mixer.stopAllAction();
                                                animations.length = 0;
                                            }
                                        }
                                        setLoadingUIState(false);
                                    }
                                }
                                break;
                                
                            case 'animation':
                                animBtn?.classList.add('active');
                                // Hide T-Pose reference
                                if (tPoseReference) {
                                    tPoseReference.setVisible(false);
                                    const tposeToggleBtn = document.getElementById('tpose-toggle-btn');
                                    if (tposeToggleBtn) tposeToggleBtn.classList.remove('active');
                                }
                                
                                // Load animations.glb if not already loaded
                                if (currentModelType !== 'animations') {
                                    // Try cache first (instant swap)
                                    if (modelCache.animations && swapToCache('animations')) {
                                        currentModelType = 'animations';
                                        console.log('[Viewer] ‚úì Swapped to cached animations model');
                                        
                                        // Setup animation UI after cache swap
                                        if (animations.length && sel && playBtn && pauseBtn) {
                                            sel.innerHTML = animations.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
                                            sel.classList.remove('hidden');
                                            playBtn.classList.remove('hidden');
                                            pauseBtn.classList.remove('hidden');
                                            
                                            // Auto-play first animation
                                            try {
                                                play(sel.value);
                                                console.log('[Viewer] ‚úì Auto-playing animation after cache swap:', sel.value);
                                            } catch (e) {
                                                console.warn('[Viewer] Auto-play after cache swap failed:', e);
                                            }
                                        }
                                    } else {
                                        // Need to load from server
                                        console.log('[Viewer] Loading animations.glb from server...');
                                        setLoadingUIState(true);
                                        loadingManager.show('Loading Animations');
                                        loadingManager.setQueue([
                                            { name: 'Animations GLB', status: 'pending' },
                                            { name: 'Animations FBX', status: 'pending' }
                                        ]);
                                        let ok = await loadModel(`/api/task/${taskId}/animations.glb`, 'Animations GLB');
                                        if (!ok) {
                                            ok = await loadFBX(`/api/task/${taskId}/animations.fbx`, 'Animations FBX');
                                        }
                                        if (ok) {
                                            currentModelType = 'animations';
                                            // Cache for future use
                                            modelCache.animations = currentModel;
                                            modelCache.animationsData = [...animations];
                                            console.log('[Viewer] ‚úì Cached animations model');
                                        }
                                        setLoadingUIState(false);
                                    }
                                }
                                break;
                        }
                        
                        if (viewerControls) {
                            viewerControls.setViewMode(mode);
                        }
                    };
                    
                    tposeBtn?.addEventListener('click', () => setActiveMode('tpose'));
                    rigBtn?.addEventListener('click', () => setActiveMode('rig'));
                    animBtn?.addEventListener('click', () => setActiveMode('animation'));
                    
                    // Expose for external use
                    window.setViewMode = setActiveMode;
                    
                    // Initialize to T-Pose mode by default (don't load model yet, will be loaded by waitAndInitViewer)
                    tposeBtn?.classList.add('active');
                    if (viewerControls) viewerControls.setViewMode('tpose');
                    
                    // Enable T-Pose reference by default in T-Pose mode
                    if (tPoseReference) {
                        tPoseReference.setVisible(true);
                        const tposeToggleBtn = document.getElementById('tpose-toggle-btn');
                        if (tposeToggleBtn) tposeToggleBtn.classList.add('active');
                    }
                    
                    console.log('[Viewer] View mode selector setup complete');
                }
                
                // Setup Context Panels for QWER modes
                function setupContextPanels() {
                    const contextSelect = document.getElementById('context-select');
                    const contextMove = document.getElementById('context-move');
                    const contextRotate = document.getElementById('context-rotate');
                    const contextScale = document.getElementById('context-scale');
                    const allContexts = [contextSelect, contextMove, contextRotate, contextScale];
                    
                    // Switch context panel based on transform mode
                    window.updateContextPanel = (mode) => {
                        allContexts.forEach(ctx => ctx?.classList.add('hidden'));
                        
                        switch (mode) {
                            case TransformMode.SELECT:
                                contextSelect?.classList.remove('hidden');
                                updateSelectContext();
                                break;
                            case TransformMode.MOVE:
                                contextMove?.classList.remove('hidden');
                                updateMoveContext();
                                break;
                            case TransformMode.ROTATE:
                                contextRotate?.classList.remove('hidden');
                                updateRotateContext();
                                break;
                            case TransformMode.SCALE:
                                contextScale?.classList.remove('hidden');
                                updateScaleContext();
                                break;
                        }
                    };
                    
                    // Update Select context panel
                    function updateSelectContext() {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        const nameEl = document.getElementById('ctx-select-name');
                        const parentEl = document.getElementById('ctx-select-parent');
                        const childrenEl = document.getElementById('ctx-select-children');
                        
                        if (nameEl) nameEl.textContent = selected?.name || '‚Äî';
                        if (parentEl) parentEl.textContent = selected?.parent?.name || '‚Äî';
                        if (childrenEl) {
                            if (selected?.children?.length > 0) {
                                const childNames = selected.children.slice(0, 3).map(c => c.name || 'unnamed');
                                childrenEl.innerHTML = childNames.map(n => 
                                    `<div class="child-item">${n}</div>`
                                ).join('');
                                if (selected.children.length > 3) {
                                    childrenEl.innerHTML += `<div style="opacity:0.5">+${selected.children.length - 3} more</div>`;
                                }
                            } else {
                                childrenEl.textContent = '‚Äî';
                            }
                        }
                    }
                    
                    // Update Move context panel
                    function updateMoveContext() {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (!selected) return;
                        
                        const xEl = document.getElementById('ctx-pos-x');
                        const yEl = document.getElementById('ctx-pos-y');
                        const zEl = document.getElementById('ctx-pos-z');
                        
                        if (xEl) xEl.value = selected.position.x.toFixed(3);
                        if (yEl) yEl.value = selected.position.y.toFixed(3);
                        if (zEl) zEl.value = selected.position.z.toFixed(3);
                    }
                    
                    // Update Rotate context panel
                    function updateRotateContext() {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (!selected) return;
                        
                        const xEl = document.getElementById('ctx-rot-x');
                        const yEl = document.getElementById('ctx-rot-y');
                        const zEl = document.getElementById('ctx-rot-z');
                        
                        const radToDeg = 180 / Math.PI;
                        if (xEl) xEl.value = (selected.rotation.x * radToDeg).toFixed(1);
                        if (yEl) yEl.value = (selected.rotation.y * radToDeg).toFixed(1);
                        if (zEl) zEl.value = (selected.rotation.z * radToDeg).toFixed(1);
                    }
                    
                    // Update Scale context panel
                    function updateScaleContext() {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (!selected) return;
                        
                        const xEl = document.getElementById('ctx-scale-x');
                        const yEl = document.getElementById('ctx-scale-y');
                        const zEl = document.getElementById('ctx-scale-z');
                        
                        if (xEl) xEl.value = selected.scale.x.toFixed(3);
                        if (yEl) yEl.value = selected.scale.y.toFixed(3);
                        if (zEl) zEl.value = selected.scale.z.toFixed(3);
                    }
                    
                    // Global function to update all context panel values from object
                    // Called when gizmo transforms the object
                    window.updateContextPanelValues = (object) => {
                        if (!object) return;
                        
                        const radToDeg = 180 / Math.PI;
                        
                        // Update position inputs
                        const posX = document.getElementById('ctx-pos-x');
                        const posY = document.getElementById('ctx-pos-y');
                        const posZ = document.getElementById('ctx-pos-z');
                        if (posX) posX.value = object.position.x.toFixed(3);
                        if (posY) posY.value = object.position.y.toFixed(3);
                        if (posZ) posZ.value = object.position.z.toFixed(3);
                        
                        // Update rotation inputs
                        const rotX = document.getElementById('ctx-rot-x');
                        const rotY = document.getElementById('ctx-rot-y');
                        const rotZ = document.getElementById('ctx-rot-z');
                        if (rotX) rotX.value = (object.rotation.x * radToDeg).toFixed(1);
                        if (rotY) rotY.value = (object.rotation.y * radToDeg).toFixed(1);
                        if (rotZ) rotZ.value = (object.rotation.z * radToDeg).toFixed(1);
                        
                        // Update scale inputs
                        const scaleX = document.getElementById('ctx-scale-x');
                        const scaleY = document.getElementById('ctx-scale-y');
                        const scaleZ = document.getElementById('ctx-scale-z');
                        if (scaleX) scaleX.value = object.scale.x.toFixed(3);
                        if (scaleY) scaleY.value = object.scale.y.toFixed(3);
                        if (scaleZ) scaleZ.value = object.scale.z.toFixed(3);
                        
                        // IMPORTANT: Save to viewerState for persistence (gizmo transforms)
                        // Note: Gizmo transforms should be applied to currentModel in rig-editor.js
                        if (currentModel && viewerState.modelTransform) {
                            // Always save root model transform
                            viewerState.modelTransform.position = {
                                x: currentModel.position.x,
                                y: currentModel.position.y,
                                z: currentModel.position.z
                            };
                            viewerState.modelTransform.rotation = {
                                x: currentModel.rotation.x,
                                y: currentModel.rotation.y,
                                z: currentModel.rotation.z
                            };
                            viewerState.modelTransform.scale = {
                                x: currentModel.scale.x,
                                y: currentModel.scale.y,
                                z: currentModel.scale.z
                            };
                            console.log('[Viewer] Model transform saved to viewerState (gizmo):', viewerState.modelTransform);
                        }
                    };
                    
                    // Reset buttons
                    document.getElementById('ctx-select-reset')?.addEventListener('click', () => {
                        if (transformManager?.selectionSystem) {
                            transformManager.selectionSystem.deselect();
                            updateSelectContext();
                        }
                    });
                    
                    document.getElementById('ctx-move-reset')?.addEventListener('click', () => {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (selected) {
                            selected.position.set(0, 0, 0);
                            updateMoveContext();
                            // Save root model transform to viewerState
                            if (currentModel && viewerState.modelTransform) {
                                viewerState.modelTransform.position = { 
                                    x: currentModel.position.x, 
                                    y: currentModel.position.y, 
                                    z: currentModel.position.z 
                                };
                                console.log('[Transform] Reset position saved');
                            }
                        }
                    });
                    
                    document.getElementById('ctx-rotate-reset')?.addEventListener('click', () => {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (selected) {
                            selected.rotation.set(0, 0, 0);
                            updateRotateContext();
                            // Save root model transform to viewerState
                            if (currentModel && viewerState.modelTransform) {
                                viewerState.modelTransform.rotation = { 
                                    x: currentModel.rotation.x, 
                                    y: currentModel.rotation.y, 
                                    z: currentModel.rotation.z 
                                };
                                console.log('[Transform] Reset rotation saved');
                            }
                        }
                    });
                    
                    document.getElementById('ctx-scale-reset')?.addEventListener('click', () => {
                        const selected = transformManager?.selectionSystem?.getSelected();
                        if (selected) {
                            selected.scale.set(1, 1, 1);
                            // Save root model transform to viewerState
                            if (currentModel && viewerState.modelTransform) {
                                viewerState.modelTransform.scale = { 
                                    x: currentModel.scale.x, 
                                    y: currentModel.scale.y, 
                                    z: currentModel.scale.z 
                                };
                                console.log('[Transform] Reset scale saved');
                            }
                            updateScaleContext();
                        }
                    });
                    
                    // Toast notification system
                    let toastTimeout = null;
                    const showToast = (message, type = 'error') => {
                        const toast = document.getElementById('transform-toast');
                        if (!toast) return;
                        
                        // Clear previous timeout
                        if (toastTimeout) {
                            clearTimeout(toastTimeout);
                        }
                        
                        toast.textContent = message;
                        toast.className = 'transform-toast ' + type;
                        
                        // Force reflow then show
                        void toast.offsetWidth;
                        toast.classList.add('visible');
                        
                        // Hide after 3 seconds
                        toastTimeout = setTimeout(() => {
                            toast.classList.remove('visible');
                        }, 3000);
                    };
                    
                    window.showTransformToast = showToast;
                    
                    // Direct transform application - ALWAYS to currentModel (root)
                    const applyTransform = (type, axis, value) => {
                        // Always transform the ROOT model, not children
                        const target = currentModel;
                        if (!target) {
                            showToast('‚ö† No model loaded', 'warning');
                            return false;
                        }

                        console.log(`[Transform] Applying ${type}.${axis} = ${value} to root model`);
                        
                        if (type === 'position') {
                            target.position[axis] = value;
                        } else if (type === 'rotation') {
                            target.rotation[axis] = value;
                        } else if (type === 'scale') {
                            target.scale[axis] = Math.max(0.01, value);
                        }
                        
                        // Save to viewerState for persistence
                        if (viewerState.modelTransform) {
                            viewerState.modelTransform.position = {
                                x: target.position.x,
                                y: target.position.y,
                                z: target.position.z
                            };
                            viewerState.modelTransform.rotation = {
                                x: target.rotation.x,
                                y: target.rotation.y,
                                z: target.rotation.z
                            };
                            viewerState.modelTransform.scale = {
                                x: target.scale.x,
                                y: target.scale.y,
                                z: target.scale.z
                            };
                            console.log('[Transform] Saved to viewerState:', JSON.stringify(viewerState.modelTransform));
                            
                            // Debounced sync - will sync in next interval or use forceSyncToServer()
                        }
                        
                        // Sync wireframe if exists
                        if (window.wireframeOverlay) {
                            window.wireframeOverlay.position.copy(target.position);
                            window.wireframeOverlay.rotation.copy(target.rotation);
                            window.wireframeOverlay.scale.copy(target.scale);
                        }
                        
                        // Update gizmo position
                        if (transformManager?.gizmoLoader) {
                            transformManager.gizmoLoader.attachToObject(target);
                        }
                        
                        return true;
                    };
                    
                    // Setup spinner buttons for an input
                    const setupSpinnerButtons = (inputId, type) => {
                        const input = document.getElementById(inputId);
                        if (!input) return;
                        
                        const wrapper = input.closest('.input-with-spinners');
                        if (!wrapper) return;
                        
                        const buttons = wrapper.querySelectorAll('.spin-btn');
                        const axis = inputId.split('-')[2]; // x, y, or z
                        const step = parseFloat(input.step) || 1;
                        const degToRad = Math.PI / 180;
                        
                        buttons.forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.preventDefault();
                                const dir = btn.dataset.dir === 'up' ? 1 : -1;
                                let currentVal = parseFloat(input.value) || 0;
                                let newVal = currentVal + (step * dir);
                                
                                // Round to step precision
                                newVal = Math.round(newVal / step) * step;
                                newVal = parseFloat(newVal.toFixed(3));
                                
                                input.value = newVal;
                                
                                // Apply to scene
                                if (type === 'rotation') {
                                    applyTransform(type, axis, newVal * degToRad);
                                } else {
                                    applyTransform(type, axis, newVal);
                                }
                            });
                        });
                    };
                    
                    // Position inputs
                    ['ctx-pos-x', 'ctx-pos-y', 'ctx-pos-z'].forEach(id => {
                        const el = document.getElementById(id);
                        if (!el) return;
                        
                        setupSpinnerButtons(id, 'position');
                        
                        const handler = (e) => {
                            const axis = id.split('-')[2];
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val)) {
                                applyTransform('position', axis, val);
                            }
                        };
                        el.addEventListener('input', handler);
                        el.addEventListener('change', handler);
                    });
                    
                    // Rotation inputs (step=90 degrees)
                    ['ctx-rot-x', 'ctx-rot-y', 'ctx-rot-z'].forEach(id => {
                        const el = document.getElementById(id);
                        if (!el) return;
                        
                        setupSpinnerButtons(id, 'rotation');
                        
                        const degToRad = Math.PI / 180;
                        const handler = (e) => {
                            const axis = id.split('-')[2];
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val)) {
                                applyTransform('rotation', axis, val * degToRad);
                            }
                        };
                        el.addEventListener('input', handler);
                        el.addEventListener('change', handler);
                    });
                    
                    // Scale inputs
                    ['ctx-scale-x', 'ctx-scale-y', 'ctx-scale-z'].forEach(id => {
                        const el = document.getElementById(id);
                        if (!el) return;
                        
                        setupSpinnerButtons(id, 'scale');
                        
                        const handler = (e) => {
                            const axis = id.split('-')[2];
                            const val = parseFloat(e.target.value);
                            if (!isNaN(val) && val > 0) {
                                applyTransform('scale', axis, val);
                            }
                        };
                        el.addEventListener('input', handler);
                        el.addEventListener('change', handler);
                    });
                    
                    console.log('[Viewer] Context panels setup complete');
                }
                
                // Show selection info popup and control transform panel visibility
                function showSelectionInfo(object) {
                    const infoEl = document.getElementById('viewer-selection-info');
                    const nameEl = document.getElementById('selection-name');
                    const typeEl = document.getElementById('selection-type');
                    const transformPanel = document.getElementById('transform-context-panel');
                    
                    // Show/hide transform panel based on selection
                    if (transformPanel) {
                        if (object) {
                            transformPanel.style.display = 'block';
                        } else {
                            transformPanel.style.display = 'none';
                        }
                    }
                    
                    if (!infoEl) return;
                    
                    if (!object) {
                        infoEl.style.opacity = '0';
                        return;
                    }
                    
                    if (nameEl) nameEl.textContent = object.name || 'Unnamed';
                    if (typeEl) typeEl.textContent = object.type;
                    infoEl.style.opacity = '1';
                    
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        infoEl.style.opacity = '0';
                    }, 2000);
                }
                
                // Also hide transform panel initially until something is selected
                const transformPanelInit = document.getElementById('transform-context-panel');
                if (transformPanelInit) transformPanelInit.style.display = 'none';

                // Render loop
                function loop() {
                    requestAnimationFrame(loop);

                    // FPS calculation
                    frameCount++;
                    const time = performance.now();
                    if (time >= lastTime + 1000) {
                        if (fpsLabel) {
                            fpsLabel.textContent = `${frameCount} FPS`;
                            if (frameCount >= 55) fpsLabel.style.color = 'rgba(0, 255, 0, 0.4)';
                            else if (frameCount >= 30) fpsLabel.style.color = 'rgba(255, 255, 0, 0.4)';
                            else fpsLabel.style.color = 'rgba(255, 0, 0, 0.4)';
                        }
                        frameCount = 0;
                        lastTime = time;
                    }

                    const dt = clock.getDelta();
                    if (mixer) mixer.update(dt);
                    if (viewerControls) viewerControls.updateFlyCamera(dt);
                    if (transformManager) transformManager.update();
                    if (window.updateZoomInertia) window.updateZoomInertia();
                    controls.update();
                    
                    // Camera sync (only if not in comparison mode AND camera is initialized)
                    if (!isDefaultComparisonOn && cameraInitialized && camera && controls) {
                        // Update camera position in state
                        viewerState.camera.position.x = camera.position.x;
                        viewerState.camera.position.y = camera.position.y;
                        viewerState.camera.position.z = camera.position.z;
                        viewerState.camera.target.x = controls.target.x;
                        viewerState.camera.target.y = controls.target.y;
                        viewerState.camera.target.z = controls.target.z;
                    }
                    
                    if (composer) {
                        composer.render();
                    } else {
                        renderer.render(scene, camera);
                    }
                }
                loop();
            }

            // Get model transform parameters for sending to worker
            // Uses currentModel if available, falls back to viewerState.modelTransform (saved on server)
            function getModelTransform() {
                const radToDeg = 180 / Math.PI;
                
                // Priority 1: Use currentModel if available
                if (currentModel) {
                    return {
                        local_position: [
                            currentModel.position.x,
                            currentModel.position.y,
                            currentModel.position.z
                        ],
                        local_rotation: [
                            currentModel.rotation.x * radToDeg,
                            currentModel.rotation.y * radToDeg,
                            currentModel.rotation.z * radToDeg
                        ],
                        local_scale: [
                            currentModel.scale.x,
                            currentModel.scale.y,
                            currentModel.scale.z
                        ]
                    };
                }
                
                // Priority 2: Use saved viewerState.modelTransform (same data synced with server)
                if (viewerState.modelTransform) {
                    const mt = viewerState.modelTransform;
                    return {
                        local_position: [mt.position.x, mt.position.y, mt.position.z],
                        local_rotation: [
                            mt.rotation.x * radToDeg,
                            mt.rotation.y * radToDeg,
                            mt.rotation.z * radToDeg
                        ],
                        local_scale: [mt.scale.x, mt.scale.y, mt.scale.z]
                    };
                }
                
                return null;
            }
            
            // Expose for debugging
            window.getModelTransform = getModelTransform;

            function setupViewerUI() {
                // Edit Model/Scene button (restart task with transform params)
                const changeRigBtn = document.getElementById('change-rig-btn');
                if (changeRigBtn) {
                    changeRigBtn.addEventListener('click', async () => {
                        const status = window.TaskPage?.task?.status || 'created';
                        const isRunning = status === 'processing' || status === 'created';
                        
                        const lang = (localStorage.getItem('autorig_lang') || 'en').toLowerCase();
                        const isRu = lang.startsWith('ru');
                        
                        let confirmMsg = isRu 
                            ? '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é —Å —Ç–µ–∫—É—â–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ —Å—Ü–µ–Ω—ã? –≠—Ç–æ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç –≤—Å–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏.'
                            : 'Restart conversion with current scene parameters? This will overwrite all generated models.';
                        
                        if (isRunning) {
                            confirmMsg = isRu
                                ? '–¢–µ–∫—É—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ü—Ä–µ—Ä–≤–∞—Ç—å –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Å –Ω–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏?'
                                : 'Current operation is not complete. Interrupt and restart with new parameters?';
                        }
                        
                        if (!confirm(confirmMsg)) return;
                        
                        changeRigBtn.disabled = true;
                        changeRigBtn.querySelector('span:last-child').textContent = '...';
                        
                        try {
                            // Get current model transform to send to worker
                            const transformParams = getModelTransform();
                            console.log('[Viewer] Sending transform params:', transformParams);
                            
                            const resp = await fetch(`/api/task/${taskId}/restart`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(transformParams || {})
                            });
                            if (!resp.ok) {
                                const data = await resp.json().catch(() => ({}));
                                alert(data.detail || 'Restart failed');
                                return;
                            }
                            window.location.reload();
                        } catch (e) {
                            console.error('[Viewer] Restart error:', e);
                            alert('Restart failed');
                        } finally {
                            changeRigBtn.disabled = false;
                            changeRigBtn.querySelector('span:last-child').textContent = t('btn_edit_scene') || 'Edit Model/Scene';
                        }
                    });
                }

                // Camera mode button - cycle through modes
                const cameraModeBtn = document.getElementById('viewer-camera-btn');
                if (cameraModeBtn && viewerControls) {
                    cameraModeBtn.addEventListener('click', () => {
                        const modes = [CameraMode.ORBIT, CameraMode.STATIC, CameraMode.FLY];
                        const currentIdx = modes.indexOf(viewerControls.cameraMode);
                        const nextIdx = (currentIdx + 1) % modes.length;
                        viewerControls.setCameraMode(modes[nextIdx]);
                    });
                    console.log('[Viewer] Camera mode button wired');
                }

                // Gizmos visibility button
                const gizmosBtn = document.getElementById('viewer-gizmos-btn');
                if (gizmosBtn && viewerControls) {
                    gizmosBtn.addEventListener('click', () => {
                        const visible = !viewerControls.gizmosVisible;
                        viewerControls.setGizmosVisibility(visible);
                        gizmosBtn.style.opacity = visible ? '1' : '0.4';
                        gizmosBtn.style.background = visible ? 'rgba(0,0,0,0.75)' : 'rgba(0,0,0,0.4)';
                    });
                    console.log('[Viewer] Gizmos toggle button wired');
                }

                // Zoom In/Out buttons
                const zoomInBtn = document.getElementById('viewer-zoom-in-btn');
                const zoomOutBtn = document.getElementById('viewer-zoom-out-btn');
                if (zoomInBtn) {
                    zoomInBtn.addEventListener('click', () => {
                        if (!zoomState) return;  // Guard against early clicks
                        zoomState.velocity -= zoomState.sensitivity * 3; // Zoom in (negative = closer)
                        controls.autoRotate = false;
                    });
                    console.log('[Viewer] Zoom In button wired');
                }
                if (zoomOutBtn) {
                    zoomOutBtn.addEventListener('click', () => {
                        if (!zoomState) return;  // Guard against early clicks
                        zoomState.velocity += zoomState.sensitivity * 3; // Zoom out (positive = further)
                        controls.autoRotate = false;
                    });
                    console.log('[Viewer] Zoom Out button wired');
                }

                // Wireframe overlay toggle
                let wireframeOverlay = null;
                window.wireframeOverlay = null; // Global reference for sync
                let wireframeEnabled = false;
                
                function toggleWireframe() {
                    if (wireframeOverlay) {
                        // Remove wireframe overlay
                        scene.remove(wireframeOverlay);
                        wireframeOverlay.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        wireframeOverlay = null;
                        window.wireframeOverlay = null;
                        wireframeEnabled = false;
                        return false;
                    }

                    if (!currentModel) return false;

                    // Create wireframe overlay (clone of model with wireframe material)
                    wireframeOverlay = currentModel.clone();
                    window.wireframeOverlay = wireframeOverlay;
                    
                    // Copy current model transform to wireframe
                    wireframeOverlay.position.copy(currentModel.position);
                    wireframeOverlay.rotation.copy(currentModel.rotation);
                    wireframeOverlay.scale.copy(currentModel.scale);
                    
                    const wireframeMat = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.4,
                        depthTest: true,
                        depthWrite: false
                    });

                    wireframeOverlay.traverse(child => {
                        if (child.isMesh) {
                            child.material = wireframeMat.clone();
                        }
                    });

                    scene.add(wireframeOverlay);
                    wireframeEnabled = true;
                    return true;
                }
                
                // Store reference for model reload
                window.recreateWireframe = function() {
                    if (wireframeEnabled && currentModel) {
                        // Remove old wireframe
                        if (wireframeOverlay) {
                            scene.remove(wireframeOverlay);
                            wireframeOverlay.traverse(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) child.material.dispose();
                            });
                        }
                        // Create new wireframe for new model
                        wireframeOverlay = currentModel.clone();
                        window.wireframeOverlay = wireframeOverlay;
                        
                        // Copy current model transform to wireframe
                        wireframeOverlay.position.copy(currentModel.position);
                        wireframeOverlay.rotation.copy(currentModel.rotation);
                        wireframeOverlay.scale.copy(currentModel.scale);
                        
                        const wireframeMat = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.4,
                            depthTest: true,
                            depthWrite: false
                        });
                        wireframeOverlay.traverse(child => {
                            if (child.isMesh) {
                                child.material = wireframeMat.clone();
                            }
                        });
                        scene.add(wireframeOverlay);
                    }
                };
                
                const wireframeBtn = document.getElementById('viewer-wireframe-btn');
                if (wireframeBtn) {
                    wireframeBtn.addEventListener('click', () => {
                        const enabled = toggleWireframe();
                        wireframeBtn.style.opacity = enabled ? '1' : '0.4';
                        wireframeBtn.style.background = enabled ? 'rgba(0,0,0,0.75)' : 'rgba(0,0,0,0.4)';
                        wireframeBtn.style.borderColor = enabled ? '#00ffff' : 'rgba(255,255,255,0.2)';
                    });
                    // Initialize button state
                    wireframeBtn.style.opacity = '0.4';
                    wireframeBtn.style.background = 'rgba(0,0,0,0.4)';
                    console.log('[Viewer] Wireframe toggle button wired');
                }

                // Fullscreen button
                const fullscreenBtn = document.getElementById('viewer-fullscreen-btn');
                if (fullscreenBtn && renderer) {
                    fullscreenBtn.addEventListener('click', () => {
                        toggleFullscreen();
                    });
                    updateFullscreenButton(); // Initialize button state
                    console.log('[Viewer] Fullscreen button wired');
                }

                // Default/Saved comparison toggle
                const defaultToggleBtn = document.getElementById('viewer-default-toggle');
                if (defaultToggleBtn && viewerControls) {
                    defaultToggleBtn.addEventListener('click', () => {
                        isDefaultComparisonOn = !isDefaultComparisonOn;
                        
                        if (isDefaultComparisonOn) {
                            // Apply neutral defaults
                            const defaults = {
                                mainLightIntensity: 3.0,
                                envIntensity: 1.0,
                                reflectionIntensity: 3.0,
                                bgColor: '#000000',
                                bloom: { strength: 0.0, threshold: 0.8, radius: 0.4 },
                                groundColor: '#222222',
                                groundSize: 100.0,
                                fogColor: '#000000',
                                fogDensity: 0.0,
                                adjustments: {}
                            };
                            const channels = ['albedo', 'ao', 'normal', 'roughness', 'metalness', 'emissive'];
                            channels.forEach(c => {
                                defaults.adjustments[c] = { brightness: 1.0, contrast: 1.0, saturation: 1.0, mode: 0, maskColor: '#ffffff', softness: 0.5, emissiveMult: 2.0, blendColor: '#ffffff', invert: false };
                            });

                            // Temporarily override visual state
                            // 1. Lighting
                            if (sunLight) sunLight.intensity = LIGHTING_CONFIG.sunIntensity * defaults.mainLightIntensity;
                            if (ambientLight) ambientLight.intensity = LIGHTING_CONFIG.ambientIntensity * defaults.mainLightIntensity;
                            if (hemiLight) hemiLight.intensity = LIGHTING_CONFIG.hemiIntensity * defaults.mainLightIntensity;
                            if (scene && 'environmentIntensity' in scene) scene.environmentIntensity = defaults.envIntensity;
                            if (scene) scene.background = new THREE.Color(defaults.bgColor);
                            
                            // 2. Props
                            viewerControls.setBloomSettings(defaults.bloom);
                            viewerControls.setGroundParams({ color: defaults.groundColor, size: defaults.groundSize });

                            // Fog
                            if (scene) {
                                if (defaults.fogDensity > 0) {
                                    scene.fog = new THREE.FogExp2(defaults.fogColor, defaults.fogDensity);
                                } else {
                                    scene.fog = null;
                                }
                            }
                            
                            // 3. Adjustments
                            for (const chan in defaults.adjustments) {
                                viewerControls.setChannelAdjustments(chan, defaults.adjustments[chan]);
                            }

                            defaultToggleBtn.style.background = 'var(--accent)';
                            defaultToggleBtn.style.opacity = '1';
                        } else {
                            // Restore actual state
                            applyViewerState();
                            defaultToggleBtn.style.background = 'rgba(0,0,0,0.75)';
                            defaultToggleBtn.style.opacity = '0.5';
                        }
                    });
                    console.log('[Viewer] Default toggle button wired');
                }

                // Collapsible Panels
                const setupPanel = (headerId, contentId, arrowId) => {
                    const header = document.getElementById(headerId);
                    const content = document.getElementById(contentId);
                    const arrow = document.getElementById(arrowId);
                    if (!header || !content) return;

                    header.addEventListener('click', () => {
                        const isHidden = content.classList.contains('hidden');
                        if (isHidden) {
                            content.classList.remove('hidden');
                            if (arrow) arrow.style.transform = 'rotate(0deg)';
                        } else {
                            content.classList.add('hidden');
                            if (arrow) arrow.style.transform = 'rotate(-90deg)';
                        }
                    });
                    
                    // Initial state: rotated arrow for hidden content
                    if (content.classList.contains('hidden') && arrow) {
                        arrow.style.transform = 'rotate(-90deg)';
                    }
                };

                setupPanel('lighting-panel-header', 'lighting-panel-content', 'lighting-panel-arrow');
                setupPanel('adjustments-panel-header', 'adjustments-panel-content', 'adjustments-panel-arrow');

                // Rig type selector - direct switching
                const rigTypeSelect = document.getElementById('viewer-rigtype-select');
                if (rigTypeSelect && viewerControls) {
                    rigTypeSelect.addEventListener('change', (e) => {
                        const rigType = e.target.value;
                        console.log('[Viewer] Switching rig type to:', rigType);
                        viewerControls.setRigType(rigType);
                    });
                    console.log('[Viewer] Rig type selector wired');
                }

                // Channel selector
                const channelSelect = document.getElementById('viewer-channel-select');
                if (channelSelect && viewerControls) {
                    channelSelect.addEventListener('change', (e) => {
                        const channel = parseInt(e.target.value, 10);
                        viewerControls.setMaterialChannel(channel);
                    });
                    console.log('[Viewer] Channel selector wired');
                }

                // ================================================================
                // XYZ Rotation Buttons (+90 degrees)
                // ================================================================
                let modelRotationDegrees = { x: 0, y: 0, z: 0 };  // Track rotation in degrees

                function rotateModel(axis) {
                    if (!currentModel) {
                        console.warn('[Rotation] No model loaded');
                        return;
                    }

                    // Add 90 degrees (wrap at 360)
                    modelRotationDegrees[axis] = (modelRotationDegrees[axis] + 90) % 360;

                    // Apply rotation to model (convert to radians)
                    currentModel.rotation.set(
                        THREE.MathUtils.degToRad(modelRotationDegrees.x),
                        THREE.MathUtils.degToRad(modelRotationDegrees.y),
                        THREE.MathUtils.degToRad(modelRotationDegrees.z)
                    );

                    // Center model and fit to ground (bbox min Y = 0, centered on XZ)
                    updateGroundPosition();

                    // Update wireframe rotation and position if enabled
                    if (window.wireframeOverlay) {
                        window.wireframeOverlay.rotation.copy(currentModel.rotation);
                    }
                    
                    // Update viewerState for persistence (both position and rotation)
                    if (viewerState.modelTransform) {
                        viewerState.modelTransform.position = {
                            x: currentModel.position.x,
                            y: currentModel.position.y,
                            z: currentModel.position.z
                        };
                        viewerState.modelTransform.rotation = {
                            x: currentModel.rotation.x,
                            y: currentModel.rotation.y,
                            z: currentModel.rotation.z
                        };
                    }
                    
                    // Force sync to server
                    forceSyncToServer();
                    
                    console.log(`[Rotation] ${axis.toUpperCase()} +90¬∞ ‚Üí rot(${modelRotationDegrees.x}¬∞, ${modelRotationDegrees.y}¬∞, ${modelRotationDegrees.z}¬∞) pos(${currentModel.position.x.toFixed(2)}, ${currentModel.position.y.toFixed(2)}, ${currentModel.position.z.toFixed(2)})`);
                }
                
                // Update ground plane to model's lowest Y point
                function updateGroundPosition() {
                    if (!currentModel || !viewerControls) return;

                    // Reset position to origin first to get accurate bounding box
                    currentModel.position.set(0, 0, 0);

                    // Calculate bounding box after rotation (with position at origin)
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const minY = box.min.y;

                    // Center model on X and Z axes, set bottom (min Y) to 0
                    currentModel.position.x = -center.x;
                    currentModel.position.z = -center.z;
                    currentModel.position.y = -minY;  // Lift model so bottom is at Y=0

                    // Update ground plane position (should be at Y=0 now)
                    if (viewerControls.groundPlane) {
                        viewerControls.groundPlane.position.y = 0;
                    }

                    // Update wireframe overlay position if exists
                    if (window.wireframeOverlay) {
                        window.wireframeOverlay.position.copy(currentModel.position);
                    }

                    console.log('[Rotation] Model centered and grounded. Position:', 
                        currentModel.position.x.toFixed(3), 
                        currentModel.position.y.toFixed(3), 
                        currentModel.position.z.toFixed(3));
                }
                
                // Wire up XYZ buttons
                const rotateXBtn = document.getElementById('rotate-x-btn');
                const rotateYBtn = document.getElementById('rotate-y-btn');
                const rotateZBtn = document.getElementById('rotate-z-btn');
                
                if (rotateXBtn) {
                    rotateXBtn.addEventListener('click', () => rotateModel('x'));
                }
                if (rotateYBtn) {
                    rotateYBtn.addEventListener('click', () => rotateModel('y'));
                }
                if (rotateZBtn) {
                    rotateZBtn.addEventListener('click', () => rotateModel('z'));
                }
                console.log('[Viewer] XYZ rotation buttons wired');
                
                // Initialize rotation from saved state
                function initRotationFromState() {
                    if (viewerState.modelTransform && currentModel) {
                        const rot = viewerState.modelTransform.rotation;
                        modelRotationDegrees = {
                            x: Math.round(THREE.MathUtils.radToDeg(rot.x || 0)) % 360,
                            y: Math.round(THREE.MathUtils.radToDeg(rot.y || 0)) % 360,
                            z: Math.round(THREE.MathUtils.radToDeg(rot.z || 0)) % 360
                        };
                        console.log('[Rotation] Initialized from state:', modelRotationDegrees);
                    }
                }
                
                // Expose functions
                window.rotateModel = rotateModel;
                window.initRotationFromState = initRotationFromState;
                
                // ================================================================
                // SAVE RIG T-POSE Button
                // ================================================================
                const saveRigBtn = document.getElementById('save-rig-btn');
                if (saveRigBtn) {
                    saveRigBtn.addEventListener('click', async () => {
                        if (!currentModel) {
                            console.warn('[SaveRig] No model loaded');
                            return;
                        }
                        
                        saveRigBtn.disabled = true;
                        const originalText = saveRigBtn.innerHTML;
                        saveRigBtn.innerHTML = '<span>' + (t('btn_save_rig_tpose_saving') || 'Saving...') + '</span>';
                        
                        try {
                            // 1. Force sync current state to server
                            await forceSyncToServer();
                            console.log('[SaveRig] Settings synced to server');
                            
                            // 2. Get current model transform for restart
                            const transformParams = getModelTransform();
                            console.log('[SaveRig] Transform params:', transformParams);
                            
                            // 3. Call restart endpoint
                            const resp = await fetch(`/api/task/${taskId}/restart`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(transformParams || {})
                            });
                            
                            if (!resp.ok) {
                                const data = await resp.json().catch(() => ({}));
                                throw new Error(data.detail || 'Restart failed');
                            }
                            
                            console.log('[SaveRig] Task restarted, reloading page...');
                            
                            // 4. Reload page (will load saved transforms)
                            window.location.reload();
                            
                        } catch (err) {
                            console.error('[SaveRig] Error:', err);
                            alert(err.message || 'Failed to save');
                            saveRigBtn.disabled = false;
                            saveRigBtn.innerHTML = originalText;
                        }
                    });
                    console.log('[Viewer] SAVE RIG T-POSE button wired');
                }
                // ================================================================

                // Admin-only: Z button (in settings area, visible when settings open)
                ensureViewerAdmin().then((isAdmin) => {
                    if (!isAdmin) return;
                    const settingsArea = document.getElementById('viewer-settings-area');
                    if (!settingsArea) return;
                    if (document.getElementById('viewer-save-default-btn')) return;

                    const btn = document.createElement('button');
                    btn.id = 'viewer-save-default-btn';
                    btn.className = 'btn btn-primary hidden';
                    btn.innerHTML = 'üíæ <span style="font-size:0.7rem;">Save Defaults (Z)</span>';
                    btn.title = 'Save default viewer settings (Z)';
                    btn.style.width = '100%';
                    btn.style.padding = '0.4rem 0.6rem';
                    btn.style.borderRadius = '8px';
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                    btn.style.gap = '0.3rem';
                    btn.style.fontSize = '0.85rem';
                    btn.style.pointerEvents = 'auto';

                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        saveDefaultViewerSettings('button');
                    });

                    // Insert after settings toggle button
                    const lightingWrap = document.getElementById('viewer-lighting-wrap');
                    if (lightingWrap) {
                        settingsArea.insertBefore(btn, lightingWrap);
                    } else {
                        settingsArea.appendChild(btn);
                    }
                    
                    // Show/hide with settings toggle
                    const settingsToggle = document.getElementById('settings-toggle-btn');
                    if (settingsToggle) {
                        const originalHandler = settingsToggle.onclick;
                        settingsToggle.addEventListener('click', () => {
                            const isActive = settingsToggle.classList.contains('active');
                            btn.classList.toggle('hidden', !isActive);
                        });
                    }
                    
                    console.log('[Viewer] Admin Z button added to settings area');
                });
            }

            // Track if current model is from Free3D (needs rotation fix)
            let isFree3DModel = false;

            /**
             * Apply improved materials for models without textures
             * Makes them darker and more reflective for better visibility
             */
            function applyImprovedMaterials(model) {
                if (!model) return;
                
                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const mat = child.material;
                        
                        // Check if material has no albedo/diffuse texture
                        const hasTexture = mat.map || mat.diffuseMap || mat.albedoMap;
                        
                        if (!hasTexture) {
                            // Model without texture - apply improved material
                            // Color: medium gray (#808080)
                            // Metalness: ~0.22 (56/255)
                            // Roughness: 0.88
                            // Enhanced reflections
                            
                            if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                                // Check if color is default white or unset
                                const isDefaultColor = !mat.color || 
                                    (mat.color.r > 0.9 && mat.color.g > 0.9 && mat.color.b > 0.9);
                                
                                if (isDefaultColor) {
                                    mat.color.setRGB(128/255, 128/255, 128/255);  // #808080
                                }
                                mat.metalness = 0.22;
                                mat.roughness = 0.88;
                                mat.envMapIntensity = 1.5;  // Enhanced reflections
                                mat.needsUpdate = true;
                                
                                console.log('[Materials] Applied improved material (no texture):', child.name);
                            }
                        } else {
                            // Model with texture - make slightly darker and more reflective
                            if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
                                mat.metalness = Math.max(mat.metalness, 0.3);
                                mat.roughness = Math.min(mat.roughness, 0.7);
                                mat.envMapIntensity = Math.max(mat.envMapIntensity || 1, 1.2);
                                mat.needsUpdate = true;
                            }
                        }
                    }
                });
                
                console.log('[Materials] Applied improved materials to model');
            }

            async function loadModel(glbUrl, label = 'GLB', retryCount = 0) {
                if (!sceneInited) await initScene();

                setStatus(`Loading ${label}...`);
                console.log(`[Viewer] loadModel started: ${label} from ${glbUrl}`);
                
                // Show loading overlay
                if (!loadingManager.isVisible) {
                    loadingManager.show('Loading Scene');
                }
                loadingManager.setItemStatus(label, 'active');
                loadingManager.updateProgress(10, `Fetching ${label}...`);
                
                const loader = new GLTFLoader();
                let gltf;
                let lastProgress = Date.now();
                const TIMEOUT_MS = 30000; // 30 second timeout
                
                try {
                    gltf = await new Promise((resolve, reject) => {
                        // Timeout check interval
                        const timeoutCheck = setInterval(() => {
                            if (Date.now() - lastProgress > TIMEOUT_MS) {
                                clearInterval(timeoutCheck);
                                reject(new Error(`Timeout: no progress for ${TIMEOUT_MS/1000}s`));
                            }
                        }, 5000);
                        
                        loader.load(
                            glbUrl, 
                            (result) => {
                                clearInterval(timeoutCheck);
                                resolve(result);
                            }, 
                            // Progress callback
                            (xhr) => {
                                lastProgress = Date.now();
                                if (xhr.lengthComputable) {
                                    const percent = 10 + (xhr.loaded / xhr.total) * 70;
                                    loadingManager.updateProgress(percent, `Downloading ${label}... ${Math.round(xhr.loaded / 1024)}KB`);
                                } else if (xhr.loaded > 0) {
                                    loadingManager.updateProgress(30, `Downloading ${label}... ${Math.round(xhr.loaded / 1024)}KB`);
                                }
                            },
                            (err) => {
                                clearInterval(timeoutCheck);
                                // If it's a network error/protocol error and we haven't retried yet
                                if (retryCount < 2) {
                                    console.warn(`[Viewer] Load failed for ${label}, will retry (${retryCount + 1}/2)...`, err);
                                    resolve(null); // Signal retry
                                } else {
                                    reject(err);
                                }
                            }
                        );
                    });
                    
                    if (gltf === null) {
                        loadingManager.updateProgress(5, `Retrying ${label}...`);
                        console.log(`[Viewer] Retrying ${label} in 1s...`);
                        // Wait a bit before retry
                        await new Promise(r => setTimeout(r, 1000));
                        return await loadModel(glbUrl, label, retryCount + 1);
                    }
                } catch (e) {
                    setStatus(`${label} failed`);
                    console.error(`[Viewer] Failed to load ${label}:`, e);
                    loadingManager.setItemStatus(label, 'error');
                    loadingManager.hide();
                    return false;
                }
                
                loadingManager.updateProgress(85, `Processing ${label}...`);

                // Remove previous model
                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel = null;
                }

                const model = gltf.scene;
                scene.add(model);
                currentModel = model;
                
                // Set root model for transforms
                if (transformManager) transformManager.setRootModel(currentModel);

                // Apply saved model transform or auto-ground if first load
                if (viewerState.modelTransform) {
                    const mt = viewerState.modelTransform;
                    
                    // Check if transform is default (never saved before)
                    const isDefaultTransform = (
                        mt.position.x === 0 && mt.position.y === 0 && mt.position.z === 0 &&
                        mt.rotation.x === 0 && mt.rotation.y === 0 && mt.rotation.z === 0 &&
                        mt.scale.x === 1 && mt.scale.y === 1 && mt.scale.z === 1
                    );
                    
                    if (isDefaultTransform) {
                        // Check if this is a Free3D model (detected in waitAndInitViewer)
                        const isFree3D = window.currentTaskIsFree3D || false;
                        
                        if (isFree3D) {
                            // Free3D: position (0,0,0), rotation (0, -90deg, 0), scale (1,1,1)
                            const rotY = -90 * (Math.PI / 180); // -90 degrees in radians
                            model.position.set(0, 0, 0);
                            model.rotation.set(0, rotY, 0);
                            
                            viewerState.modelTransform.position = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.rotation = { x: 0, y: rotY, z: 0 };
                            viewerState.modelTransform.scale = { x: 1, y: 1, z: 1 };
                            console.log('[Viewer] Free3D model: position=origin, rotation Y=-90deg');
                        } else {
                            // Non-Free3D: position (0,0,0), rotation (0,0,0), scale (1,1,1)
                            model.position.set(0, 0, 0);
                            model.rotation.set(0, 0, 0);
                            
                            viewerState.modelTransform.position = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.rotation = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.scale = { x: 1, y: 1, z: 1 };
                            console.log('[Viewer] First load: position=origin, rotation=0');
                        }
                    } else {
                        // Apply saved transform
                        model.position.set(mt.position.x, mt.position.y, mt.position.z);
                        model.rotation.set(mt.rotation.x, mt.rotation.y, mt.rotation.z);
                        model.scale.set(mt.scale.x, mt.scale.y, mt.scale.z);
                        console.log('[Viewer] Applied saved model transform');
                    }
                }
                
                // Recreate wireframe overlay if enabled
                if (window.recreateWireframe) window.recreateWireframe();

                // Update ViewerControls with new model (applies rotation & alignment)
                if (viewerControls) {
                    // Apply AO settings before baking
                    viewerControls.setAOSettings(viewerState.aoSettings);
                    viewerControls.setModel(model);
                }
                
                // Apply improved materials for models without textures (darker, reflective)
                applyImprovedMaterials(model);
                
                // Initialize rotation state from saved transform
                if (window.initRotationFromState) {
                    window.initRotationFromState();
                }
                
                // Update TransformManager and HierarchyNavigator with new model
                if (transformManager) {
                    transformManager.setModel(model);
                }
                if (hierarchyNavigator) {
                    hierarchyNavigator.setModel(model);
                    window.updateHierarchyUI();
                }

                // Restore camera from saved state (or use defaults if no saved state)
                if (savedCameraPosition && savedCameraTarget) {
                    restoreSavedCamera();
                } else {
                    // No saved camera - calculate static above-side position based on model size
                        console.log('[Viewer] Setting up static camera for T-pose view');
                        try {
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const distance = maxDim * 2;

                            // Target the center of the model
                            const targetY = center.y;
                            controls.target.set(0, targetY, 0);
                            
                            // Static camera: above-side view (45¬∞ from above, 45¬∞ from side)
                            // Position: front-right diagonal
                            camera.position.set(
                                distance * 0.7,   // X: to the right
                                targetY + distance * 0.5,  // Y: above
                                distance * 0.7    // Z: in front
                            );
                            camera.lookAt(0, targetY, 0);
                            controls.update();

                            // Save this position to state
                            viewerState.camera = {
                                position: { 
                                    x: distance * 0.7, 
                                    y: targetY + distance * 0.5, 
                                    z: distance * 0.7 
                                },
                                target: { x: 0, y: targetY, z: 0 }
                            };
                            console.log('[Viewer] Static camera set:', viewerState.camera);
                        } catch (err) {
                            console.error('[Viewer] Camera setup error:', err);
                        }
                        cameraInitialized = true; // Allow sync
                    }
                
                // Mark loading complete
                loadingManager.updateProgress(100, `${label} loaded!`);
                loadingManager.setItemStatus(label, 'done');
                
                // Hide loading overlay after a short delay
                setTimeout(() => hideLoadingOverlay(), 300);

                animations = gltf.animations || [];
                console.log(`[Viewer] ${label} loaded. Animations found:`, animations.length);
                if (animations.length) {
                    console.log('[Viewer] Animation names:', animations.map(a => a.name));
                }
                
                mixer = animations.length ? new THREE.AnimationMixer(model) : null;

                // UI for animations
                if (sel && playBtn && pauseBtn && animations.length) {
                    console.log('[Viewer] Setting up animation UI controls...');
                    sel.innerHTML = animations.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
                    sel.classList.remove('hidden');
                    playBtn.classList.remove('hidden');
                    pauseBtn.classList.remove('hidden');
                    
                    // Remove old listeners and add new ones
                    const newSel = sel.cloneNode(true);
                    sel.parentNode.replaceChild(newSel, sel);
                    sel = newSel;
                    
                    const newPlayBtn = playBtn.cloneNode(true);
                    playBtn.parentNode.replaceChild(newPlayBtn, playBtn);
                    playBtn = newPlayBtn;
                    
                    const newPauseBtn = pauseBtn.cloneNode(true);
                    pauseBtn.parentNode.replaceChild(newPauseBtn, pauseBtn);
                    pauseBtn = newPauseBtn;
                    
                    sel.addEventListener('change', () => {
                        console.log('[Viewer] Animation changed to:', sel.value);
                        play(sel.value);
                    });
                    playBtn.addEventListener('click', () => {
                        console.log('[Viewer] Play clicked, animation:', sel.value);
                        play(sel.value);
                    });
                    pauseBtn.addEventListener('click', () => {
                        console.log('[Viewer] Pause clicked');
                        if (mixer) mixer.timeScale = 0;
                    });
                    
                    try {
                        console.log('[Viewer] Auto-playing first animation:', sel.value);
                        play(sel.value);
                    } catch (e) {
                        console.warn('[Viewer] Auto-play failed:', e);
                    }
                } else {
                    console.log('[Viewer] No animations or UI elements missing');
                    sel?.classList.add('hidden');
                    playBtn?.classList.add('hidden');
                    pauseBtn?.classList.add('hidden');
                }

                const statusText = animations.length ? `Ready (${animations.length} animations)` : 'Ready (no animations)';
                setStatus(statusText);
                console.log('[Viewer] Status:', statusText);
                return true;
            }

            // Load FBX model with animations
            async function loadFBX(fbxUrl, label = 'FBX', retryCount = 0) {
                if (!sceneInited) await initScene();

                setStatus(`Loading ${label}...`);
                
                // Show loading overlay
                if (!loadingManager.isVisible) {
                    loadingManager.show('Loading Scene');
                }
                loadingManager.setItemStatus(label, 'active');
                loadingManager.updateProgress(10, `Fetching ${label}...`);
                
                const loader = new FBXLoader();
                let model;
                try {
                    model = await new Promise((resolve, reject) => {
                        loader.load(
                            fbxUrl, 
                            resolve, 
                            // Progress callback
                            (xhr) => {
                                if (xhr.lengthComputable) {
                                    const percent = 10 + (xhr.loaded / xhr.total) * 70;
                                    loadingManager.updateProgress(percent, `Downloading ${label}... ${Math.round(xhr.loaded / 1024)}KB`);
                                }
                            },
                            (err) => {
                                if (retryCount < 1) {
                                    console.warn(`[Viewer] Load failed for ${label}, retrying...`, err);
                                    resolve(null);
                                } else {
                                    reject(err);
                                }
                            }
                        );
                    });

                    if (model === null) {
                        loadingManager.updateProgress(5, `Retrying ${label}...`);
                        await new Promise(r => setTimeout(r, 1000));
                        return await loadFBX(fbxUrl, label, retryCount + 1);
                    }
                } catch (e) {
                    setStatus(`${label} not found`);
                    console.warn(`[Viewer] Failed to load ${label}:`, e);
                    loadingManager.setItemStatus(label, 'error');
                    return false;
                }
                
                loadingManager.updateProgress(85, `Processing ${label}...`);

                // Remove previous model
                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel = null;
                }

                scene.add(model);
                currentModel = model;
                
                // Set root model for transforms
                if (transformManager) transformManager.setRootModel(currentModel);

                // Apply saved model transform or auto-ground if first load (FBX)
                if (viewerState.modelTransform) {
                    const mt = viewerState.modelTransform;
                    
                    // Check if transform is default (never saved before)
                    const isDefaultTransform = (
                        mt.position.x === 0 && mt.position.y === 0 && mt.position.z === 0 &&
                        mt.rotation.x === 0 && mt.rotation.y === 0 && mt.rotation.z === 0 &&
                        mt.scale.x === 1 && mt.scale.y === 1 && mt.scale.z === 1
                    );
                    
                    if (isDefaultTransform) {
                        // Check if this is a Free3D model (detected in waitAndInitViewer)
                        const isFree3D = window.currentTaskIsFree3D || false;
                        
                        if (isFree3D) {
                            // Free3D: position (0,0,0), rotation (0, -90deg, 0), scale (1,1,1)
                            const rotY = -90 * (Math.PI / 180); // -90 degrees in radians
                            model.position.set(0, 0, 0);
                            model.rotation.set(0, rotY, 0);
                            
                            viewerState.modelTransform.position = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.rotation = { x: 0, y: rotY, z: 0 };
                            viewerState.modelTransform.scale = { x: 1, y: 1, z: 1 };
                            console.log('[Viewer] Free3D FBX model: position=origin, rotation Y=-90deg');
                        } else {
                            // Non-Free3D: position (0,0,0), rotation (0,0,0), scale (1,1,1)
                            model.position.set(0, 0, 0);
                            model.rotation.set(0, 0, 0);
                            
                            viewerState.modelTransform.position = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.rotation = { x: 0, y: 0, z: 0 };
                            viewerState.modelTransform.scale = { x: 1, y: 1, z: 1 };
                            console.log('[Viewer] First load (FBX): position=origin, rotation=0');
                        }
                    } else {
                        // Apply saved transform
                        model.position.set(mt.position.x, mt.position.y, mt.position.z);
                        model.rotation.set(mt.rotation.x, mt.rotation.y, mt.rotation.z);
                        model.scale.set(mt.scale.x, mt.scale.y, mt.scale.z);
                        console.log('[Viewer] Applied saved model transform (FBX)');
                    }
                }
                
                // Recreate wireframe overlay if enabled
                if (window.recreateWireframe) window.recreateWireframe();

                // Update ViewerControls with new model (applies rotation & alignment)
                if (viewerControls) {
                    // Apply AO settings before baking
                    viewerControls.setAOSettings(viewerState.aoSettings);
                    viewerControls.setModel(model);
                }
                
                // Apply improved materials for models without textures (darker, reflective)
                applyImprovedMaterials(model);
                
                // Initialize rotation state from saved transform
                if (window.initRotationFromState) {
                    window.initRotationFromState();
                }

                // Update TransformManager and HierarchyNavigator with new model (FBX path)
                if (transformManager) {
                    transformManager.setModel(model);
                }
                if (hierarchyNavigator) {
                    hierarchyNavigator.setModel(model);
                    updateHierarchyUI();
                }

                // Restore camera from saved state (or use defaults if no saved state)
                if (savedCameraPosition && savedCameraTarget) {
                    restoreSavedCamera();
                } else {
                    // No saved camera - calculate static above-side position (FBX)
                    console.log('[Viewer] Setting up static camera for T-pose view (FBX)');
                    try {
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const distance = maxDim * 2;
                        
                        // Target the center of the model
                        const targetY = center.y;
                        controls.target.set(0, targetY, 0);
                        
                        // Static camera: above-side view (45¬∞ from above, 45¬∞ from side)
                        camera.position.set(
                            distance * 0.7,   // X: to the right
                            targetY + distance * 0.5,  // Y: above
                            distance * 0.7    // Z: in front
                        );
                        camera.lookAt(0, targetY, 0);
                        controls.update();
                        
                        // Save this position to state
                        viewerState.camera = {
                            position: { 
                                x: distance * 0.7, 
                                y: targetY + distance * 0.5, 
                                z: distance * 0.7 
                            },
                            target: { x: 0, y: targetY, z: 0 }
                        };
                        console.log('[Viewer] Static camera set (FBX):', viewerState.camera);
                    } catch (err) {
                        console.error('[Viewer] FBX camera setup error:', err);
                    }
                    cameraInitialized = true; // Allow sync
                }
                
                // Mark loading complete
                loadingManager.updateProgress(100, `${label} loaded!`);
                loadingManager.setItemStatus(label, 'done');
                
                // Hide loading overlay after a short delay
                setTimeout(() => hideLoadingOverlay(), 300);

                // FBX animations are stored on the model object directly
                animations = model.animations || [];
                console.log(`[Viewer] ${label} loaded. Animations found:`, animations.length);
                if (animations.length) {
                    console.log('[Viewer] Animation names:', animations.map(a => a.name));
                }
                
                mixer = animations.length ? new THREE.AnimationMixer(model) : null;

                // UI for animations
                if (sel && playBtn && pauseBtn && animations.length) {
                    console.log('[Viewer] Setting up animation UI controls...');
                    sel.innerHTML = animations.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
                    sel.classList.remove('hidden');
                    playBtn.classList.remove('hidden');
                    pauseBtn.classList.remove('hidden');
                    
                    // Remove old listeners and add new ones
                    const newSel = sel.cloneNode(true);
                    sel.parentNode.replaceChild(newSel, sel);
                    sel = newSel;
                    
                    const newPlayBtn = playBtn.cloneNode(true);
                    playBtn.parentNode.replaceChild(newPlayBtn, playBtn);
                    playBtn = newPlayBtn;
                    
                    const newPauseBtn = pauseBtn.cloneNode(true);
                    pauseBtn.parentNode.replaceChild(newPauseBtn, pauseBtn);
                    pauseBtn = newPauseBtn;
                    
                    sel.addEventListener('change', () => {
                        console.log('[Viewer] Animation changed to:', sel.value);
                        play(sel.value);
                    });
                    playBtn.addEventListener('click', () => {
                        console.log('[Viewer] Play clicked, animation:', sel.value);
                        play(sel.value);
                    });
                    pauseBtn.addEventListener('click', () => {
                        console.log('[Viewer] Pause clicked');
                        if (mixer) mixer.timeScale = 0;
                    });
                    
                    try {
                        console.log('[Viewer] Auto-playing first animation:', sel.value);
                        play(sel.value);
                    } catch (e) {
                        console.warn('[Viewer] Auto-play failed:', e);
                    }
                } else {
                    console.log('[Viewer] No animations or UI elements missing');
                    sel?.classList.add('hidden');
                    playBtn?.classList.add('hidden');
                    pauseBtn?.classList.add('hidden');
                }

                const statusText = animations.length ? `Ready (${animations.length} animations)` : 'Ready (no animations)';
                setStatus(statusText);
                console.log('[Viewer] Status:', statusText);
                return true;
            }

            // Track which models are loaded
            let animationsLoaded = false;
            let free3dModelLoaded = false;
            
            // Track which model type is currently loaded (outer scope for access by waitAndInitViewer)
            let currentModelType = 'unknown'; // 'prepared', 'animations', 'unknown'
            
            // Prevent race condition between preparedModelReady event and waitAndInitViewer
            let preparedLoadingInProgress = false;

            // Background loader for animations (non-blocking)
            let animationsLoadingInBackground = false;
            
            async function loadAnimationsInBackground() {
                if (animationsLoadingInBackground || modelCache.animations) {
                    return; // Already loading or cached
                }
                
                animationsLoadingInBackground = true;
                console.log('[Viewer] üîÑ Starting background load of animations...');
                
                try {
                    // Load animations GLB silently (no loading overlay)
                    const { GLTFLoader } = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js');
                    const loader = new GLTFLoader();
                    
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(
                            `/api/task/${taskId}/animations.glb`,
                            resolve,
                            (xhr) => {
                                if (xhr.total > 0) {
                                    const pct = Math.round((xhr.loaded / xhr.total) * 100);
                                    console.log(`[Viewer] Background animations: ${pct}%`);
                                }
                            },
                            reject
                        );
                    });
                    
                    // Cache the loaded model (don't add to scene yet)
                    const model = gltf.scene;
                    const loadedAnimations = gltf.animations || [];
                    
                    modelCache.animations = model;
                    modelCache.animationsData = loadedAnimations;
                    animationsLoaded = true;
                    
                    console.log('[Viewer] ‚úì Background animations loaded and cached!', loadedAnimations.length, 'animations');
                    
                    // Show notification that animations are ready
                    showAnimationsReadyNotification();
                    
                } catch (err) {
                    console.warn('[Viewer] Background animations load failed, will try FBX later:', err.message);
                } finally {
                    animationsLoadingInBackground = false;
                }
            }
            
            // Show notification that animations are ready
            function showAnimationsReadyNotification() {
                const animBtn = document.getElementById('view-mode-anim');
                if (animBtn && !animBtn.classList.contains('ready-pulse')) {
                    animBtn.classList.add('ready-pulse');
                    animBtn.title = 'Animations ready! Click to view';
                    
                    // Add pulsing animation
                    animBtn.style.animation = 'pulse-ready 1s ease-in-out 3';
                    setTimeout(() => {
                        animBtn.style.animation = '';
                    }, 3000);
                }
            }
            
            // Init viewer: Free3D loads immediately, others wait for prepared/done
            async function waitAndInitViewer() {
                try {
                    console.log('[Viewer] Polling task status...');
                    const r = await fetch(`/api/task/${taskId}`);
                    const t = await r.json();
                    console.log('[Viewer] Task status:', t.status, 'prepared_glb_ready:', t.prepared_glb_ready);

                    const isFree3DTask = t && t.input_url && t.input_url.includes('free3d.online');
                    window.currentTaskIsFree3D = isFree3DTask; // Global flag for loadModel to use

                    // 1. FREE3D: Load immediately from free3d.online (no waiting for worker)
                    if (isFree3DTask && !free3dModelLoaded) {
                        console.log('[Viewer] Free3D task detected - loading directly from free3d.online...');

                        // Setup loading queue for Free3D
                        loadingManager.show('Loading Free3D Model');
                        loadingManager.setQueue([{ name: 'Free3D Model', status: 'pending' }]);

                        // Default to X -90 fix for Free3D models
                        if (viewerState.modelRotation === 'none' || viewerState.modelRotation === 'z180') {
                            console.log('[Viewer] Defaulting Free3D to X -90 rotation');
                            viewerState.modelRotation = 'x90_neg';
                            updateViewerUI();
                        }

                        const urlMatch = t.input_url.match(/\/data\/([a-f0-9-]+)\//i);
                        if (urlMatch) {
                            const guid = urlMatch[1];
                            const proxyUrl = `/api/free3d/glb/${guid}/${guid}.glb`;
                            const ok = await loadModel(proxyUrl, 'Free3D Model');
                            if (ok) {
                                free3dModelLoaded = true;
                                preparedLoaded = true;
                                // Transform already applied in loadModel based on window.currentTaskIsFree3D
                                console.log('[Viewer] ‚úì Free3D model loaded immediately');
                            }
                        }
                    }

                    // 2. Load PREPARED model first for instant preview (non-blocking)
                    if (!isFree3DTask && t && t.prepared_glb_ready && !preparedLoaded && !preparedLoadingInProgress) {
                        preparedLoadingInProgress = true;
                        console.log('[Viewer] Loading prepared model for instant preview...');
                        
                        // Setup loading queue for preview
                        loadingManager.show('Loading Model');
                        loadingManager.setQueue([{ name: 'Prepared Model', status: 'pending' }]);
                        
                        try {
                            const ok = await loadModel(`/api/task/${taskId}/prepared.glb`, 'Prepared Model');
                            if (ok) {
                                preparedLoaded = true;
                                currentModelType = 'prepared';
                                // Cache prepared model
                                modelCache.prepared = currentModel;
                                modelCache.preparedData = [];
                                console.log('[Viewer] ‚úì Prepared model loaded and cached');
                                
                                // Start loading animations in BACKGROUND (non-blocking)
                                if (t.status === 'done' && !modelCache.animations) {
                                    loadAnimationsInBackground();
                                }
                            }
                        } finally {
                            preparedLoadingInProgress = false;
                        }
                    }
                    
                    // 3. If task is done and we haven't started background load yet, start it
                    if (t && t.status === 'done' && preparedLoaded && !modelCache.animations && !animationsLoadingInBackground) {
                        loadAnimationsInBackground();
                    }
                    
                    // 4. If task is done and animations are cached but not shown, we can auto-switch
                    if (t && t.status === 'done' && modelCache.animations && !finalLoaded) {
                        finalLoaded = true;
                        console.log('[Viewer] ‚úì Task complete, animations ready in cache');
                        
                        // Don't auto-switch - let user click the Anim button
                        // Just mark it as ready
                        showAnimationsReadyNotification();
                    }

                    // Update RigEditor status
                    if (rigEditor && t) rigEditor.setTaskStatus(t.status);
                    
                    // Stop polling if task is done and everything is loaded
                    if (t && t.status === 'done' && preparedLoaded && (modelCache.animations || animationsLoadingInBackground)) {
                        console.log('[Viewer] Task done, models loaded/loading. Stopping poll.');
                        return;
                    }
                    
                } catch (e) {
                    console.warn('[Viewer] Poll error:', e);
                }
                // Keep polling until task is done
                setTimeout(waitAndInitViewer, 3000);
            }

            console.log('[Viewer] Starting viewer initialization...');
            waitAndInitViewer();

            // Listen for early trigger from progress log parsing
            window.addEventListener('preparedModelReady', async () => {
                if (preparedLoaded || finalLoaded || preparedLoadingInProgress) {
                    console.log('[Viewer] preparedModelReady event: already loaded/loading, skipping');
                    return;
                }
                preparedLoadingInProgress = true;
                console.log('[Viewer] preparedModelReady event: attempting early load...');
                
                try {
                    const ok = await loadModel(`/api/task/${taskId}/prepared.glb`, 'Prepared Model (Early)');
                    if (ok) {
                        preparedLoaded = true;
                        currentModelType = 'prepared';
                        modelCache.prepared = currentModel;
                        modelCache.preparedData = [];
                        console.log('[Viewer] ‚úì Prepared model loaded from event trigger');
                        
                        // Start background animations load
                        loadAnimationsInBackground();
                    } else {
                        console.warn('[Viewer] preparedModelReady: loadModel returned false');
                    }
                } catch (err) {
                    console.error('[Viewer] preparedModelReady: load error:', err);
                } finally {
                    preparedLoadingInProgress = false;
                }
            });
        }
    </script>

    <!-- Telegram WebApp Integration -->
    <script>
        window.TelegramApp = {
            shareTask(taskId) {
                const webappUrl = `${window.location.origin}/task?id=${taskId}&mode=webapp`;
                
                if (window.Telegram?.WebApp) {
                    // Inside Telegram - use switchInlineQuery to share
                    window.Telegram.WebApp.switchInlineQuery(webappUrl, ['users', 'groups', 'channels']);
                } else {
                    // Outside Telegram - open Telegram share URL
                    const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(webappUrl)}&text=${encodeURIComponent('Check out this 3D model!')}`;
                    window.open(shareUrl, '_blank');
                }
            },
            hapticFeedback(type) {
                if (window.Telegram?.WebApp?.HapticFeedback) {
                    if (type === 'success') window.Telegram.WebApp.HapticFeedback.notificationOccurred('success');
                    else if (type === 'error') window.Telegram.WebApp.HapticFeedback.notificationOccurred('error');
                }
            }
        };
        
        // Log if running as Telegram WebApp
        if (window.Telegram?.WebApp?.initData) {
            console.log('[Telegram] Running as Telegram WebApp');
        }
    </script>

    <!-- Site Header Component -->
    <script src="/static/js/header.js"></script>
    <script>
        // Inject site header (skip in webapp mode)
        (function() {
            const params = new URLSearchParams(window.location.search);
            const isWebAppMode = params.get('mode') === 'webapp';
            
            if (!isWebAppMode) {
                const headerContainer = document.getElementById('site-header');
                if (headerContainer && window.SiteHeader) {
                    // Render header with search enabled
                    headerContainer.innerHTML = SiteHeader.render({ showSearch: true });
                    
                    // Initialize header functionality
                    SiteHeader.init();
                    
                    // Initialize Free3D search with callback to start task
                    SiteHeader.initSearch((modelUrl, modelName) => {
                        // Navigate to home page with URL to start conversion
                        window.location.href = `/?url=${encodeURIComponent(modelUrl)}`;
                    });
                }
            }
        })();
    </script>
</body>
</html>

